<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>rcl: include/rcl/publisher.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rcl
   &#160;<span id="projectnumber">master</span>
   </div>
   <div id="projectbrief">C API providing common ROS client library functionality.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_283a3917c54ce6b1b3757c2d5b61678e.html">rcl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">publisher.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;rosidl_generator_c/message_type_support_struct.h&quot;</code><br />
<code>#include &quot;<a class="el" href="macros_8h_source.html">rcl/macros.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="node_8h_source.html">rcl/node.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="visibility__control_8h_source.html">rcl/visibility_control.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for publisher.h:</div>
<div class="dyncontent">
<div class="center"><img src="publisher_8h__incl.png" border="0" usemap="#include_2rcl_2publisher_8h" alt=""/></div>
<map name="include_2rcl_2publisher_8h" id="include_2rcl_2publisher_8h">
<area shape="rect" id="node3" href="macros_8h.html" title="rcl/macros.h" alt="" coords="1269,789,1364,815"/>
<area shape="rect" id="node4" href="node_8h.html" title="rcl/node.h" alt="" coords="376,95,455,121"/>
<area shape="rect" id="node11" href="visibility__control_8h.html" title="rcutils/visibility\l_control.h" alt="" coords="553,781,661,823"/>
<area shape="rect" id="node6" href="allocator_8h.html" title="rcl/allocator.h" alt="" coords="408,632,508,659"/>
<area shape="rect" id="node14" href="arguments_8h.html" title="rcl/arguments.h" alt="" coords="426,184,538,211"/>
<area shape="rect" id="node15" href="types_8h.html" title="rcl/types.h" alt="" coords="579,259,662,285"/>
<area shape="rect" id="node18" href="context_8h.html" title="rcl/context.h" alt="" coords="508,483,603,509"/>
<area shape="rect" id="node7" doxygen="/home/steven/osrf/crystal-release/ros2_doc_ws/doxygen_tag_files/rcutils.tag:http://docs.ros2.org/crystal/api/rcutils/" href="http://docs.ros2.org/crystal/api/rcutils/allocator_8h.html" title="rcutils/allocator.h" alt="" coords="397,707,519,733"/>
<area shape="rect" id="node8" doxygen="/home/steven/osrf/crystal-release/ros2_doc_ws/doxygen_tag_files/rmw.tag:http://docs.ros2.org/crystal/api/rmw/" href="http://docs.ros2.org/crystal/api/rmw/macros_8h.html" title="rcutils/macros.h" alt="" coords="743,789,858,815"/>
<area shape="rect" id="node9" doxygen="/home/steven/osrf/crystal-release/ros2_doc_ws/doxygen_tag_files/rcutils.tag:http://docs.ros2.org/crystal/api/rcutils/" href="http://docs.ros2.org/crystal/api/rcutils/macros_8h.html" title="rcutils/macros.h" alt="" coords="258,789,373,815"/>
<area shape="rect" id="node10" doxygen="/home/steven/osrf/crystal-release/ros2_doc_ws/doxygen_tag_files/rcutils.tag:http://docs.ros2.org/crystal/api/rcutils/" href="http://docs.ros2.org/crystal/api/rcutils/rcutils__ret_8h.html" title="rcutils/types/rcutils\l_ret.h" alt="" coords="397,781,529,823"/>
<area shape="rect" id="node12" doxygen="/home/steven/osrf/crystal-release/ros2_doc_ws/doxygen_tag_files/rmw.tag:http://docs.ros2.org/crystal/api/rmw/" href="http://docs.ros2.org/crystal/api/rmw/visibility__control_8h.html" title="rcutils/visibility\l_control.h" alt="" coords="883,781,991,823"/>
<area shape="rect" id="node13" doxygen="/home/steven/osrf/crystal-release/ros2_doc_ws/doxygen_tag_files/rcutils.tag:http://docs.ros2.org/crystal/api/rcutils/" href="http://docs.ros2.org/crystal/api/rcutils/visibility__control_8h.html" title="rcutils/visibility\l_control.h" alt="" coords="125,781,233,823"/>
<area shape="rect" id="node16" doxygen="/home/steven/osrf/crystal-release/ros2_doc_ws/doxygen_tag_files/rmw.tag:http://docs.ros2.org/crystal/api/rmw/" href="http://docs.ros2.org/crystal/api/rmw/types_8h.html" title="rmw/types.h" alt="" coords="917,333,1012,360"/>
<area shape="rect" id="node17" href="init_8h.html" title="rmw/init.h" alt="" coords="605,408,684,435"/>
<area shape="rect" id="node19" doxygen="/home/steven/osrf/crystal-release/ros2_doc_ws/doxygen_tag_files/rmw.tag:http://docs.ros2.org/crystal/api/rmw/" href="http://docs.ros2.org/crystal/api/rmw/init_8h.html" title="rmw/init.h" alt="" coords="821,632,900,659"/>
<area shape="rect" id="node22" doxygen="/home/steven/osrf/crystal-release/ros2_doc_ws/doxygen_tag_files/rmw.tag:http://docs.ros2.org/crystal/api/rmw/" href="http://docs.ros2.org/crystal/api/rmw/ret__types_8h.html" title="rmw/ret_types.h" alt="" coords="1015,789,1131,815"/>
<area shape="rect" id="node23" doxygen="/home/steven/osrf/crystal-release/ros2_doc_ws/doxygen_tag_files/rmw.tag:http://docs.ros2.org/crystal/api/rmw/" href="http://docs.ros2.org/crystal/api/rmw/serialized__message_8h.html" title="rmw/serialized_message.h" alt="" coords="1003,408,1180,435"/>
<area shape="rect" id="node20" href="init__options_8h.html" title="rmw/init_options.h" alt="" coords="698,557,826,584"/>
<area shape="rect" id="node21" doxygen="/home/steven/osrf/crystal-release/ros2_doc_ws/doxygen_tag_files/rmw.tag:http://docs.ros2.org/crystal/api/rmw/" href="http://docs.ros2.org/crystal/api/rmw/init__options_8h.html" title="rmw/init_options.h" alt="" coords="847,707,975,733"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="publisher_8h__dep__incl.png" border="0" usemap="#include_2rcl_2publisher_8hdep" alt=""/></div>
<map name="include_2rcl_2publisher_8hdep" id="include_2rcl_2publisher_8hdep">
<area shape="rect" id="node2" href="rcl_8h.html" title="include/rcl/rcl.h" alt="" coords="24,80,135,107"/>
</map>
</div>
</div>
<p><a href="publisher_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrcl__publisher__t.html">rcl_publisher_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure which encapsulates a ROS Publisher.  <a href="structrcl__publisher__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrcl__publisher__options__t.html">rcl_publisher_options_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options available for a rcl publisher.  <a href="structrcl__publisher__options__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a1e62d26c2d1415a9474f70794edf979f"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structrcl__publisher__t.html">rcl_publisher_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="publisher_8h.html#a1e62d26c2d1415a9474f70794edf979f">rcl_publisher_t</a></td></tr>
<tr class="memdesc:a1e62d26c2d1415a9474f70794edf979f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure which encapsulates a ROS Publisher.  <a href="#a1e62d26c2d1415a9474f70794edf979f">More...</a><br /></td></tr>
<tr class="separator:a1e62d26c2d1415a9474f70794edf979f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01fb55e4b1253cc43b3ec4520b404e41"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structrcl__publisher__options__t.html">rcl_publisher_options_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="publisher_8h.html#a01fb55e4b1253cc43b3ec4520b404e41">rcl_publisher_options_t</a></td></tr>
<tr class="memdesc:a01fb55e4b1253cc43b3ec4520b404e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options available for a rcl publisher.  <a href="#a01fb55e4b1253cc43b3ec4520b404e41">More...</a><br /></td></tr>
<tr class="separator:a01fb55e4b1253cc43b3ec4520b404e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a80f543fef948b8d5521a5425b8e9de8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrcl__publisher__t.html">rcl_publisher_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="publisher_8h.html#a80f543fef948b8d5521a5425b8e9de8f">rcl_get_zero_initialized_publisher</a> (void)</td></tr>
<tr class="memdesc:a80f543fef948b8d5521a5425b8e9de8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="structrcl__publisher__t.html" title="Structure which encapsulates a ROS Publisher. ">rcl_publisher_t</a> struct with members set to <code>NULL</code>.  <a href="#a80f543fef948b8d5521a5425b8e9de8f">More...</a><br /></td></tr>
<tr class="separator:a80f543fef948b8d5521a5425b8e9de8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f09bd85795259f6c96f38c875d19d13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="publisher_8h.html#a0f09bd85795259f6c96f38c875d19d13">rcl_publisher_init</a> (<a class="el" href="structrcl__publisher__t.html">rcl_publisher_t</a> *publisher, const <a class="el" href="structrcl__node__t.html">rcl_node_t</a> *node, const rosidl_message_type_support_t *type_support, const char *topic_name, const <a class="el" href="structrcl__publisher__options__t.html">rcl_publisher_options_t</a> *options)</td></tr>
<tr class="memdesc:a0f09bd85795259f6c96f38c875d19d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a rcl publisher.  <a href="#a0f09bd85795259f6c96f38c875d19d13">More...</a><br /></td></tr>
<tr class="separator:a0f09bd85795259f6c96f38c875d19d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4994e28119c12621e77a979f2d99fc8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="publisher_8h.html#a4994e28119c12621e77a979f2d99fc8f">rcl_publisher_fini</a> (<a class="el" href="structrcl__publisher__t.html">rcl_publisher_t</a> *publisher, <a class="el" href="structrcl__node__t.html">rcl_node_t</a> *node)</td></tr>
<tr class="memdesc:a4994e28119c12621e77a979f2d99fc8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a <a class="el" href="structrcl__publisher__t.html" title="Structure which encapsulates a ROS Publisher. ">rcl_publisher_t</a>.  <a href="#a4994e28119c12621e77a979f2d99fc8f">More...</a><br /></td></tr>
<tr class="separator:a4994e28119c12621e77a979f2d99fc8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b820b9ca1a63f4843d08db058825e0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrcl__publisher__options__t.html">rcl_publisher_options_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="publisher_8h.html#a6b820b9ca1a63f4843d08db058825e0a">rcl_publisher_get_default_options</a> (void)</td></tr>
<tr class="memdesc:a6b820b9ca1a63f4843d08db058825e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the default publisher options in a <a class="el" href="structrcl__publisher__options__t.html" title="Options available for a rcl publisher. ">rcl_publisher_options_t</a>.  <a href="#a6b820b9ca1a63f4843d08db058825e0a">More...</a><br /></td></tr>
<tr class="separator:a6b820b9ca1a63f4843d08db058825e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082c7e5c9e8d8db2e857cc38f74b2580"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="publisher_8h.html#a082c7e5c9e8d8db2e857cc38f74b2580">rcl_publish</a> (const <a class="el" href="structrcl__publisher__t.html">rcl_publisher_t</a> *publisher, const void *ros_message)</td></tr>
<tr class="memdesc:a082c7e5c9e8d8db2e857cc38f74b2580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish a ROS message on a topic using a publisher.  <a href="#a082c7e5c9e8d8db2e857cc38f74b2580">More...</a><br /></td></tr>
<tr class="separator:a082c7e5c9e8d8db2e857cc38f74b2580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3037a9f1df9de8b1339a5c0bebb40d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="publisher_8h.html#a8f3037a9f1df9de8b1339a5c0bebb40d">rcl_publish_serialized_message</a> (const <a class="el" href="structrcl__publisher__t.html">rcl_publisher_t</a> *publisher, const <a class="el" href="types_8h.html#aacac4adc45d07815b73188eafd77d705">rcl_serialized_message_t</a> *serialized_message)</td></tr>
<tr class="memdesc:a8f3037a9f1df9de8b1339a5c0bebb40d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish a serialized message on a topic using a publisher.  <a href="#a8f3037a9f1df9de8b1339a5c0bebb40d">More...</a><br /></td></tr>
<tr class="separator:a8f3037a9f1df9de8b1339a5c0bebb40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3171eb977050c07da7c5a700f2a3e03"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="publisher_8h.html#ab3171eb977050c07da7c5a700f2a3e03">rcl_publisher_get_topic_name</a> (const <a class="el" href="structrcl__publisher__t.html">rcl_publisher_t</a> *publisher)</td></tr>
<tr class="memdesc:ab3171eb977050c07da7c5a700f2a3e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the topic name for the publisher.  <a href="#ab3171eb977050c07da7c5a700f2a3e03">More...</a><br /></td></tr>
<tr class="separator:ab3171eb977050c07da7c5a700f2a3e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab019e5586f55cac908bd800458d60e96"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structrcl__publisher__options__t.html">rcl_publisher_options_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="publisher_8h.html#ab019e5586f55cac908bd800458d60e96">rcl_publisher_get_options</a> (const <a class="el" href="structrcl__publisher__t.html">rcl_publisher_t</a> *publisher)</td></tr>
<tr class="memdesc:ab019e5586f55cac908bd800458d60e96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the rcl publisher options.  <a href="#ab019e5586f55cac908bd800458d60e96">More...</a><br /></td></tr>
<tr class="separator:ab019e5586f55cac908bd800458d60e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae708956b59c0d1efcb7149d8afb93456"><td class="memItemLeft" align="right" valign="top"><a class="elRef" doxygen="/home/steven/osrf/crystal-release/ros2_doc_ws/doxygen_tag_files/rmw.tag:http://docs.ros2.org/crystal/api/rmw/" href="http://docs.ros2.org/crystal/api/rmw/structrmw__publisher__t.html">rmw_publisher_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="publisher_8h.html#ae708956b59c0d1efcb7149d8afb93456">rcl_publisher_get_rmw_handle</a> (const <a class="el" href="structrcl__publisher__t.html">rcl_publisher_t</a> *publisher)</td></tr>
<tr class="memdesc:ae708956b59c0d1efcb7149d8afb93456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the rmw publisher handle.  <a href="#ae708956b59c0d1efcb7149d8afb93456">More...</a><br /></td></tr>
<tr class="separator:ae708956b59c0d1efcb7149d8afb93456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d2e627ed95373ad81f626c8bf9eab3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrcl__context__t.html">rcl_context_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="publisher_8h.html#a03d2e627ed95373ad81f626c8bf9eab3">rcl_publisher_get_context</a> (const <a class="el" href="structrcl__publisher__t.html">rcl_publisher_t</a> *publisher)</td></tr>
<tr class="memdesc:a03d2e627ed95373ad81f626c8bf9eab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the context associated with this publisher.  <a href="#a03d2e627ed95373ad81f626c8bf9eab3">More...</a><br /></td></tr>
<tr class="separator:a03d2e627ed95373ad81f626c8bf9eab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ce5ce9e6594057161583d5973eca2f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="publisher_8h.html#a74ce5ce9e6594057161583d5973eca2f">rcl_publisher_is_valid</a> (const <a class="el" href="structrcl__publisher__t.html">rcl_publisher_t</a> *publisher)</td></tr>
<tr class="memdesc:a74ce5ce9e6594057161583d5973eca2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the publisher is valid, otherwise false.  <a href="#a74ce5ce9e6594057161583d5973eca2f">More...</a><br /></td></tr>
<tr class="separator:a74ce5ce9e6594057161583d5973eca2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc30de5630a5e1de46d53bab73e8e16"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="publisher_8h.html#a1fc30de5630a5e1de46d53bab73e8e16">rcl_publisher_is_valid_except_context</a> (const <a class="el" href="structrcl__publisher__t.html">rcl_publisher_t</a> *publisher)</td></tr>
<tr class="memdesc:a1fc30de5630a5e1de46d53bab73e8e16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the publisher is valid except the context, otherwise false.  <a href="#a1fc30de5630a5e1de46d53bab73e8e16">More...</a><br /></td></tr>
<tr class="separator:a1fc30de5630a5e1de46d53bab73e8e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b19f74be7312ce986fa3a1d2fa734a9"><td class="memItemLeft" align="right" valign="top"><a class="elRef" doxygen="/home/steven/osrf/crystal-release/ros2_doc_ws/doxygen_tag_files/rmw.tag:http://docs.ros2.org/crystal/api/rmw/" href="http://docs.ros2.org/crystal/api/rmw/ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="publisher_8h.html#a8b19f74be7312ce986fa3a1d2fa734a9">rcl_publisher_get_subscription_count</a> (const <a class="el" href="structrcl__publisher__t.html">rcl_publisher_t</a> *publisher, size_t *subscription_count)</td></tr>
<tr class="memdesc:a8b19f74be7312ce986fa3a1d2fa734a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of subscriptions matched to a publisher.  <a href="#a8b19f74be7312ce986fa3a1d2fa734a9">More...</a><br /></td></tr>
<tr class="separator:a8b19f74be7312ce986fa3a1d2fa734a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a1e62d26c2d1415a9474f70794edf979f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structrcl__publisher__t.html">rcl_publisher_t</a>  <a class="el" href="structrcl__publisher__t.html">rcl_publisher_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Structure which encapsulates a ROS Publisher. </p>

</div>
</div>
<a class="anchor" id="a01fb55e4b1253cc43b3ec4520b404e41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structrcl__publisher__options__t.html">rcl_publisher_options_t</a>  <a class="el" href="structrcl__publisher__options__t.html">rcl_publisher_options_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Options available for a rcl publisher. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a80f543fef948b8d5521a5425b8e9de8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrcl__publisher__t.html">rcl_publisher_t</a> rcl_get_zero_initialized_publisher </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <a class="el" href="structrcl__publisher__t.html" title="Structure which encapsulates a ROS Publisher. ">rcl_publisher_t</a> struct with members set to <code>NULL</code>. </p>
<p>Should be called to get a null <a class="el" href="structrcl__publisher__t.html" title="Structure which encapsulates a ROS Publisher. ">rcl_publisher_t</a> before passing to <a class="el" href="publisher_8h.html#a0f09bd85795259f6c96f38c875d19d13" title="Initialize a rcl publisher. ">rcl_publisher_init()</a>. </p>

</div>
</div>
<a class="anchor" id="a0f09bd85795259f6c96f38c875d19d13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> rcl_publisher_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__publisher__t.html">rcl_publisher_t</a> *&#160;</td>
          <td class="paramname"><em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrcl__node__t.html">rcl_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rosidl_message_type_support_t *&#160;</td>
          <td class="paramname"><em>type_support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrcl__publisher__options__t.html">rcl_publisher_options_t</a> *&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a rcl publisher. </p>
<p>After calling this function on a <a class="el" href="structrcl__publisher__t.html" title="Structure which encapsulates a ROS Publisher. ">rcl_publisher_t</a>, it can be used to publish messages of the given type to the given topic using <a class="el" href="publisher_8h.html#a082c7e5c9e8d8db2e857cc38f74b2580" title="Publish a ROS message on a topic using a publisher. ">rcl_publish()</a>.</p>
<p>The given <a class="el" href="structrcl__node__t.html" title="Structure which encapsulates a ROS Node. ">rcl_node_t</a> must be valid and the resulting <a class="el" href="structrcl__publisher__t.html" title="Structure which encapsulates a ROS Publisher. ">rcl_publisher_t</a> is only valid as long as the given <a class="el" href="structrcl__node__t.html" title="Structure which encapsulates a ROS Node. ">rcl_node_t</a> remains valid.</p>
<p>The rosidl_message_type_support_t is obtained on a per .msg type basis. When the user defines a ROS message, code is generated which provides the required rosidl_message_type_support_t object. This object can be obtained using a language appropriate mechanism. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>TODO(wjwwood) write these instructions once and link to it instead</dd></dl>
<p>For C, a macro can be used (for example <code>std_msgs/String</code>):</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;rosidl_generator_c/message_type_support_struct.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;std_msgs/msg/string.h&gt;</span></div><div class="line"><span class="keyword">const</span> rosidl_message_type_support_t * string_ts =</div><div class="line">  ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, String);</div></div><!-- fragment --><p>For C++, a template function is used:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;rosidl_typesupport_cpp/message_type_support.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;std_msgs/msg/string.hpp&gt;</span></div><div class="line"><span class="keyword">const</span> rosidl_message_type_support_t * string_ts =</div><div class="line">  rosidl_typesupport_cpp::get_message_type_support_handle&lt;std_msgs::msg::String&gt;();</div></div><!-- fragment --><p>The rosidl_message_type_support_t object contains message type specific information used to publish messages.</p>
<p>The topic name must be a c string which follows the topic and service name format rules for unexpanded names, also known as non-fully qualified names:</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="expand__topic__name_8h.html#afd76d3899685bd234563afa467b885f2" title="Expand a given topic name into a fully-qualified topic name. ">rcl_expand_topic_name</a></dd></dl>
<p>The options struct allows the user to set the quality of service settings as well as a custom allocator which is used when initializing/finalizing the publisher to allocate space for incidentals, e.g. the topic name string.</p>
<p>Expected usage (for C messages):</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="rcl_8h.html">rcl/rcl.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;rosidl_generator_c/message_type_support_struct.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;std_msgs/msg/string.h&gt;</span></div><div class="line"></div><div class="line"><a class="code" href="structrcl__node__t.html">rcl_node_t</a> node = <a class="code" href="node_8h.html#a81df2a24fd74f87d520fba94297eb583">rcl_get_zero_initialized_node</a>();</div><div class="line"><a class="code" href="structrcl__node__options__t.html">rcl_node_options_t</a> node_ops = <a class="code" href="node_8h.html#a6391b8a89bd72f8e69113a471c005c3c">rcl_node_get_default_options</a>();</div><div class="line"><a class="code" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> ret = <a class="code" href="node_8h.html#a404531a35e68e71f4900ff48544682b5">rcl_node_init</a>(&amp;node, <span class="stringliteral">&quot;node_name&quot;</span>, <span class="stringliteral">&quot;/my_namespace&quot;</span>, &amp;node_ops);</div><div class="line"><span class="comment">// ... error handling</span></div><div class="line"><span class="keyword">const</span> rosidl_message_type_support_t * ts = ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, String);</div><div class="line"><a class="code" href="structrcl__publisher__t.html">rcl_publisher_t</a> publisher = <a class="code" href="publisher_8h.html#a80f543fef948b8d5521a5425b8e9de8f">rcl_get_zero_initialized_publisher</a>();</div><div class="line"><a class="code" href="structrcl__publisher__options__t.html">rcl_publisher_options_t</a> publisher_ops = <a class="code" href="publisher_8h.html#a6b820b9ca1a63f4843d08db058825e0a">rcl_publisher_get_default_options</a>();</div><div class="line">ret = <a class="code" href="publisher_8h.html#a0f09bd85795259f6c96f38c875d19d13">rcl_publisher_init</a>(&amp;publisher, &amp;node, ts, <span class="stringliteral">&quot;chatter&quot;</span>, &amp;publisher_ops);</div><div class="line"><span class="comment">// ... error handling, and on shutdown do finalization:</span></div><div class="line">ret = <a class="code" href="publisher_8h.html#a4994e28119c12621e77a979f2d99fc8f">rcl_publisher_fini</a>(&amp;publisher, &amp;node);</div><div class="line"><span class="comment">// ... error handling for rcl_publisher_fini()</span></div><div class="line">ret = <a class="code" href="node_8h.html#a00d2a1a7959d7b2db49a3653235d414c">rcl_node_fini</a>(&amp;node);</div><div class="line"><span class="comment">// ... error handling for rcl_deinitialize_node()</span></div></div><!-- fragment --><hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>Yes </td></tr>
<tr>
<td>Thread-Safe </td><td>No </td></tr>
<tr>
<td>Uses Atomics </td><td>No </td></tr>
<tr>
<td>Lock-Free </td><td>Yes </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">publisher</td><td>preallocated publisher structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>valid rcl node handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_support</td><td>type support object for the topic's type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">topic_name</td><td>the name of the topic to publish on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>publisher options, including quality of service settings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RCL_RET_OK</code> if the publisher was initialized successfully, or </dd>
<dd>
<code>RCL_RET_NODE_INVALID</code> if the node is invalid, or </dd>
<dd>
<code>RCL_RET_ALREADY_INIT</code> if the publisher is already initialized, or </dd>
<dd>
<code>RCL_RET_INVALID_ARGUMENT</code> if any arguments are invalid, or </dd>
<dd>
<code>RCL_RET_BAD_ALLOC</code> if allocating memory fails, or </dd>
<dd>
<code>RCL_RET_TOPIC_NAME_INVALID</code> if the given topic name is invalid, or </dd>
<dd>
<code>RCL_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a class="anchor" id="a4994e28119c12621e77a979f2d99fc8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> rcl_publisher_fini </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__publisher__t.html">rcl_publisher_t</a> *&#160;</td>
          <td class="paramname"><em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrcl__node__t.html">rcl_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a <a class="el" href="structrcl__publisher__t.html" title="Structure which encapsulates a ROS Publisher. ">rcl_publisher_t</a>. </p>
<p>After calling, the node will no longer be advertising that it is publishing on this topic (assuming this is the only publisher on this topic).</p>
<p>After calling, calls to rcl_publish will fail when using this publisher. However, the given node handle is still valid.</p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>Yes </td></tr>
<tr>
<td>Thread-Safe </td><td>No </td></tr>
<tr>
<td>Uses Atomics </td><td>No </td></tr>
<tr>
<td>Lock-Free </td><td>Yes </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">publisher</td><td>handle to the publisher to be finalized </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>handle to the node used to create the publisher </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RCL_RET_OK</code> if publisher was finalized successfully, or </dd>
<dd>
<code>RCL_RET_INVALID_ARGUMENT</code> if any arguments are invalid, or </dd>
<dd>
<code>RCL_RET_PUBLISHER_INVALID</code> if the publisher is invalid, or </dd>
<dd>
<code>RCL_RET_NODE_INVALID</code> if the node is invalid, or </dd>
<dd>
<code>RCL_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a class="anchor" id="a6b820b9ca1a63f4843d08db058825e0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrcl__publisher__options__t.html">rcl_publisher_options_t</a> rcl_publisher_get_default_options </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the default publisher options in a <a class="el" href="structrcl__publisher__options__t.html" title="Options available for a rcl publisher. ">rcl_publisher_options_t</a>. </p>
<p>The defaults are:</p>
<ul>
<li>qos = rmw_qos_profile_default</li>
<li>allocator = <a class="el" href="allocator_8h.html#a2546f065f55387ed642d455a55ba7602">rcl_get_default_allocator()</a> </li>
</ul>

</div>
</div>
<a class="anchor" id="a082c7e5c9e8d8db2e857cc38f74b2580"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> rcl_publish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrcl__publisher__t.html">rcl_publisher_t</a> *&#160;</td>
          <td class="paramname"><em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ros_message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Publish a ROS message on a topic using a publisher. </p>
<p>It is the job of the caller to ensure that the type of the ros_message parameter and the type associate with the publisher (via the type support) match. Passing a different type to publish produces undefined behavior and cannot be checked by this function and therefore no deliberate error will occur.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>TODO(wjwwood): The blocking behavior of publish is a still a point of dispute. This section should be updated once the behavior is clearly defined. See: <a href="https://github.com/ros2/ros2/issues/255">https://github.com/ros2/ros2/issues/255</a></dd></dl>
<p>Calling <a class="el" href="publisher_8h.html#a082c7e5c9e8d8db2e857cc38f74b2580" title="Publish a ROS message on a topic using a publisher. ">rcl_publish()</a> is a potentially blocking call. When called <a class="el" href="publisher_8h.html#a082c7e5c9e8d8db2e857cc38f74b2580" title="Publish a ROS message on a topic using a publisher. ">rcl_publish()</a> will immediately do any publishing related work, including, but not limited to, converting the message into a different type, serializing the message, collecting publish statistics, etc. The last thing it will do is call the underlying middleware's publish function which may or may not block based on the quality of service settings given via the publisher options in <a class="el" href="publisher_8h.html#a0f09bd85795259f6c96f38c875d19d13" title="Initialize a rcl publisher. ">rcl_publisher_init()</a>. For example, if the reliability is set to reliable, then a publish may block until space in the publish queue is available, but if the reliability is set to best effort then it should not block.</p>
<p>The ROS message given by the <code>ros_message</code> void pointer is always owned by the calling code, but should remain constant during publish.</p>
<p>This function is thread safe so long as access to both the publisher and the <code>ros_message</code> is synchronized. That means that calling <a class="el" href="publisher_8h.html#a082c7e5c9e8d8db2e857cc38f74b2580" title="Publish a ROS message on a topic using a publisher. ">rcl_publish()</a> from multiple threads is allowed, but calling <a class="el" href="publisher_8h.html#a082c7e5c9e8d8db2e857cc38f74b2580" title="Publish a ROS message on a topic using a publisher. ">rcl_publish()</a> at the same time as non-thread safe publisher functions is not, e.g. calling <a class="el" href="publisher_8h.html#a082c7e5c9e8d8db2e857cc38f74b2580" title="Publish a ROS message on a topic using a publisher. ">rcl_publish()</a> and <a class="el" href="publisher_8h.html#a4994e28119c12621e77a979f2d99fc8f" title="Finalize a rcl_publisher_t. ">rcl_publisher_fini()</a> concurrently is not allowed. Before calling <a class="el" href="publisher_8h.html#a082c7e5c9e8d8db2e857cc38f74b2580" title="Publish a ROS message on a topic using a publisher. ">rcl_publish()</a> the message can change and after calling <a class="el" href="publisher_8h.html#a082c7e5c9e8d8db2e857cc38f74b2580" title="Publish a ROS message on a topic using a publisher. ">rcl_publish()</a> the message can change, but it cannot be changed during the publish call. The same <code>ros_message</code>, however, can be passed to multiple calls of <a class="el" href="publisher_8h.html#a082c7e5c9e8d8db2e857cc38f74b2580" title="Publish a ROS message on a topic using a publisher. ">rcl_publish()</a> simultaneously, even if the publishers differ. The <code>ros_message</code> is unmodified by <a class="el" href="publisher_8h.html#a082c7e5c9e8d8db2e857cc38f74b2580" title="Publish a ROS message on a topic using a publisher. ">rcl_publish()</a>.</p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>No </td></tr>
<tr>
<td>Thread-Safe </td><td>Yes [1] </td></tr>
<tr>
<td>Uses Atomics </td><td>No </td></tr>
<tr>
<td>Lock-Free </td><td>Yes </td></tr>
</table>
<p><em>[1] for unique pairs of publishers and messages, see above for more</em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">publisher</td><td>handle to the publisher which will do the publishing </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ros_message</td><td>type-erased pointer to the ROS message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RCL_RET_OK</code> if the message was published successfully, or </dd>
<dd>
<code>RCL_RET_INVALID_ARGUMENT</code> if any arguments are invalid, or </dd>
<dd>
<code>RCL_RET_PUBLISHER_INVALID</code> if the publisher is invalid, or </dd>
<dd>
<code>RCL_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a class="anchor" id="a8f3037a9f1df9de8b1339a5c0bebb40d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> rcl_publish_serialized_message </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrcl__publisher__t.html">rcl_publisher_t</a> *&#160;</td>
          <td class="paramname"><em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#aacac4adc45d07815b73188eafd77d705">rcl_serialized_message_t</a> *&#160;</td>
          <td class="paramname"><em>serialized_message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Publish a serialized message on a topic using a publisher. </p>
<p>It is the job of the caller to ensure that the type of the serialized message parameter and the type associate with the publisher (via the type support) match. Even though this call to publish takes an already serialized serialized message, the publisher has to register its type as a ROS known message type. Passing a serialized message from a different type leads to undefined behavior on the subscriber side. The publish call might be able to send any abitrary serialized message, it is however not garantueed that the subscriber side successfully deserializes this byte stream.</p>
<p>Apart from this, the <code>publish_serialized</code> function has the same behavior as <code>rcl_publish</code> expect that no serialization step is done.</p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>No </td></tr>
<tr>
<td>Thread-Safe </td><td>Yes [1] </td></tr>
<tr>
<td>Uses Atomics </td><td>No </td></tr>
<tr>
<td>Lock-Free </td><td>Yes </td></tr>
</table>
<p><em>[1] for unique pairs of publishers and messages, see above for more</em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">publisher</td><td>handle to the publisher which will do the publishing </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">serialized_message</td><td>pointer to the already serialized message in raw form </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RCL_RET_OK</code> if the message was published successfully, or </dd>
<dd>
<code>RCL_RET_INVALID_ARGUMENT</code> if any arguments are invalid, or </dd>
<dd>
<code>RCL_RET_PUBLISHER_INVALID</code> if the publisher is invalid, or </dd>
<dd>
<code>RCL_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a class="anchor" id="ab3171eb977050c07da7c5a700f2a3e03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rcl_publisher_get_topic_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrcl__publisher__t.html">rcl_publisher_t</a> *&#160;</td>
          <td class="paramname"><em>publisher</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the topic name for the publisher. </p>
<p>This function returns the publisher's internal topic name string. This function can fail, and therefore return <code>NULL</code>, if the:</p><ul>
<li>publisher is <code>NULL</code></li>
<li>publisher is invalid (never called init, called fini, or invalid node)</li>
</ul>
<p>The returned string is only valid as long as the <a class="el" href="structrcl__publisher__t.html" title="Structure which encapsulates a ROS Publisher. ">rcl_publisher_t</a> is valid. The value of the string may change if the topic name changes, and therefore copying the string is recommended if this is a concern.</p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>No </td></tr>
<tr>
<td>Thread-Safe </td><td>No </td></tr>
<tr>
<td>Uses Atomics </td><td>No </td></tr>
<tr>
<td>Lock-Free </td><td>Yes </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">publisher</td><td>pointer to the publisher </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>name string if successful, otherwise <code>NULL</code> </dd></dl>

</div>
</div>
<a class="anchor" id="ab019e5586f55cac908bd800458d60e96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structrcl__publisher__options__t.html">rcl_publisher_options_t</a>* rcl_publisher_get_options </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrcl__publisher__t.html">rcl_publisher_t</a> *&#160;</td>
          <td class="paramname"><em>publisher</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the rcl publisher options. </p>
<p>This function returns the publisher's internal options struct. This function can fail, and therefore return <code>NULL</code>, if the:</p><ul>
<li>publisher is <code>NULL</code></li>
<li>publisher is invalid (never called init, called fini, or invalid node)</li>
</ul>
<p>The returned struct is only valid as long as the <a class="el" href="structrcl__publisher__t.html" title="Structure which encapsulates a ROS Publisher. ">rcl_publisher_t</a> is valid. The values in the struct may change if the options of the publisher change, and therefore copying the struct is recommended if this is a concern.</p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>No </td></tr>
<tr>
<td>Thread-Safe </td><td>No </td></tr>
<tr>
<td>Uses Atomics </td><td>No </td></tr>
<tr>
<td>Lock-Free </td><td>Yes </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">publisher</td><td>pointer to the publisher </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>options struct if successful, otherwise <code>NULL</code> </dd></dl>

</div>
</div>
<a class="anchor" id="ae708956b59c0d1efcb7149d8afb93456"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/home/steven/osrf/crystal-release/ros2_doc_ws/doxygen_tag_files/rmw.tag:http://docs.ros2.org/crystal/api/rmw/" href="http://docs.ros2.org/crystal/api/rmw/structrmw__publisher__t.html">rmw_publisher_t</a>* rcl_publisher_get_rmw_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrcl__publisher__t.html">rcl_publisher_t</a> *&#160;</td>
          <td class="paramname"><em>publisher</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the rmw publisher handle. </p>
<p>The handle returned is a pointer to the internally held rmw handle. This function can fail, and therefore return <code>NULL</code>, if the:</p><ul>
<li>publisher is <code>NULL</code></li>
<li>publisher is invalid (never called init, called fini, or invalid node)</li>
</ul>
<p>The returned handle is made invalid if the publisher is finalized or if <a class="el" href="init_8h.html#a87e421f97cf55ea30804874d7b62b751" title="Shutdown a given rcl context. ">rcl_shutdown()</a> is called. The returned handle is not guaranteed to be valid for the life time of the publisher as it may be finalized and recreated itself. Therefore it is recommended to get the handle from the publisher using this function each time it is needed and avoid use of the handle concurrently with functions that might change it.</p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>No </td></tr>
<tr>
<td>Thread-Safe </td><td>No </td></tr>
<tr>
<td>Uses Atomics </td><td>No </td></tr>
<tr>
<td>Lock-Free </td><td>Yes </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">publisher</td><td>pointer to the rcl publisher </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rmw publisher handle if successful, otherwise <code>NULL</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a03d2e627ed95373ad81f626c8bf9eab3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrcl__context__t.html">rcl_context_t</a>* rcl_publisher_get_context </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrcl__publisher__t.html">rcl_publisher_t</a> *&#160;</td>
          <td class="paramname"><em>publisher</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the context associated with this publisher. </p>
<p>This function can fail, and therefore return <code>NULL</code>, if the:</p><ul>
<li>publisher is <code>NULL</code></li>
<li>publisher is invalid (never called init, called fini, etc.)</li>
</ul>
<p>The returned context is made invalid if the publisher is finalized or if <a class="el" href="init_8h.html#a87e421f97cf55ea30804874d7b62b751" title="Shutdown a given rcl context. ">rcl_shutdown()</a> is called. Therefore it is recommended to get the handle from the publisher using this function each time it is needed and avoid use of the handle concurrently with functions that might change it.</p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>No </td></tr>
<tr>
<td>Thread-Safe </td><td>No </td></tr>
<tr>
<td>Uses Atomics </td><td>No </td></tr>
<tr>
<td>Lock-Free </td><td>Yes </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">publisher</td><td>pointer to the rcl publisher </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>context if successful, otherwise <code>NULL</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a74ce5ce9e6594057161583d5973eca2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rcl_publisher_is_valid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrcl__publisher__t.html">rcl_publisher_t</a> *&#160;</td>
          <td class="paramname"><em>publisher</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the publisher is valid, otherwise false. </p>
<p>The bool returned is <code>false</code> if <code>publisher</code> is invalid. The bool returned is <code>true</code> otherwise. In the case where <code>false</code> is to be returned, an error message is set. This function cannot fail.</p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>No </td></tr>
<tr>
<td>Thread-Safe </td><td>No </td></tr>
<tr>
<td>Uses Atomics </td><td>No </td></tr>
<tr>
<td>Lock-Free </td><td>Yes </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">publisher</td><td>pointer to the rcl publisher </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>publisher</code> is valid, otherwise <code>false</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a1fc30de5630a5e1de46d53bab73e8e16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rcl_publisher_is_valid_except_context </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrcl__publisher__t.html">rcl_publisher_t</a> *&#160;</td>
          <td class="paramname"><em>publisher</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the publisher is valid except the context, otherwise false. </p>
<p>This is used in clean up functions that need to access the publisher, but do not need use any functions with the context.</p>
<p>It is identical to rcl_publisher_is_valid except it ignores the state of the context associated with the publisher. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="publisher_8h.html#a74ce5ce9e6594057161583d5973eca2f" title="Return true if the publisher is valid, otherwise false. ">rcl_publisher_is_valid()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8b19f74be7312ce986fa3a1d2fa734a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/home/steven/osrf/crystal-release/ros2_doc_ws/doxygen_tag_files/rmw.tag:http://docs.ros2.org/crystal/api/rmw/" href="http://docs.ros2.org/crystal/api/rmw/ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rcl_publisher_get_subscription_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrcl__publisher__t.html">rcl_publisher_t</a> *&#160;</td>
          <td class="paramname"><em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>subscription_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of subscriptions matched to a publisher. </p>
<p>Used to get the internal count of subscriptions matched to a publisher.</p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>No </td></tr>
<tr>
<td>Thread-Safe </td><td>Yes </td></tr>
<tr>
<td>Uses Atomics </td><td>Maybe [1] </td></tr>
<tr>
<td>Lock-Free </td><td>Maybe [1] </td></tr>
</table>
<p><em>[1] only if the underlying rmw doesn't make use of this feature </em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">publisher</td><td>pointer to the rcl publisher </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">subscription_count</td><td>number of matched subscriptions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RCL_RET_OK</code> if the count was retrieved, or </dd>
<dd>
<code>RCL_RET_INVALID_ARGUMENT</code> if any arguments are invalid, or </dd>
<dd>
<code>RCL_RET_SUBSCRIPTION_INVALID</code> if the subscription is invalid, or </dd>
<dd>
<code>RCL_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
