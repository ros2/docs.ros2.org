<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rcl: include/rcl/wait.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rcl
   &#160;<span id="projectnumber">master</span>
   </div>
   <div id="projectbrief">C API providing common ROS client library functionality.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_283a3917c54ce6b1b3757c2d5b61678e.html">rcl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">wait.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &quot;<a class="el" href="client_8h_source.html">rcl/client.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="guard__condition_8h_source.html">rcl/guard_condition.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="macros_8h_source.html">rcl/macros.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="service_8h_source.html">rcl/service.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="subscription_8h_source.html">rcl/subscription.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="timer_8h_source.html">rcl/timer.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="types_8h_source.html">rcl/types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="visibility__control_8h_source.html">rcl/visibility_control.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for wait.h:</div>
<div class="dyncontent">
<div class="center"><img src="wait_8h__incl.png" border="0" usemap="#include_2rcl_2wait_8h" alt=""/></div>
<map name="include_2rcl_2wait_8h" id="include_2rcl_2wait_8h">
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="wait_8h__dep__incl.png" border="0" usemap="#include_2rcl_2wait_8hdep" alt=""/></div>
<map name="include_2rcl_2wait_8hdep" id="include_2rcl_2wait_8hdep">
</map>
</div>
</div>
<p><a href="wait_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrcl__wait__set__t.html">rcl_wait_set_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for subscription's, guard condition's, etc to be waited on.  <a href="structrcl__wait__set__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aab0067a065def35dfb3c85fd89dc50f1"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structrcl__wait__set__t.html">rcl_wait_set_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wait_8h.html#aab0067a065def35dfb3c85fd89dc50f1">rcl_wait_set_t</a></td></tr>
<tr class="memdesc:aab0067a065def35dfb3c85fd89dc50f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for subscription's, guard condition's, etc to be waited on.  <a href="#aab0067a065def35dfb3c85fd89dc50f1">More...</a><br /></td></tr>
<tr class="separator:aab0067a065def35dfb3c85fd89dc50f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab6463602996a20c928b1980222499ffb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrcl__wait__set__t.html">rcl_wait_set_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wait_8h.html#ab6463602996a20c928b1980222499ffb">rcl_get_zero_initialized_wait_set</a> (void)</td></tr>
<tr class="memdesc:ab6463602996a20c928b1980222499ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="structrcl__wait__set__t.html" title="Container for subscription&#39;s, guard condition&#39;s, etc to be waited on. ">rcl_wait_set_t</a> struct with members set to <code>NULL</code>.  <a href="#ab6463602996a20c928b1980222499ffb">More...</a><br /></td></tr>
<tr class="separator:ab6463602996a20c928b1980222499ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51cf85900a17ddec4fee8b92f96c9a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wait_8h.html#af51cf85900a17ddec4fee8b92f96c9a0">rcl_wait_set_init</a> (<a class="el" href="structrcl__wait__set__t.html">rcl_wait_set_t</a> *wait_set, size_t number_of_subscriptions, size_t number_of_guard_conditions, size_t number_of_timers, size_t number_of_clients, size_t number_of_services, <a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a> allocator)</td></tr>
<tr class="memdesc:af51cf85900a17ddec4fee8b92f96c9a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a rcl wait set with space for items to be waited on.  <a href="#af51cf85900a17ddec4fee8b92f96c9a0">More...</a><br /></td></tr>
<tr class="separator:af51cf85900a17ddec4fee8b92f96c9a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b71f790a6cc23c1a7174b35e70fc8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wait_8h.html#a16b71f790a6cc23c1a7174b35e70fc8e">rcl_wait_set_fini</a> (<a class="el" href="structrcl__wait__set__t.html">rcl_wait_set_t</a> *wait_set)</td></tr>
<tr class="memdesc:a16b71f790a6cc23c1a7174b35e70fc8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a rcl wait set.  <a href="#a16b71f790a6cc23c1a7174b35e70fc8e">More...</a><br /></td></tr>
<tr class="separator:a16b71f790a6cc23c1a7174b35e70fc8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4862187d323d417a69d89e9dd3404436"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wait_8h.html#a4862187d323d417a69d89e9dd3404436">rcl_wait_set_get_allocator</a> (const <a class="el" href="structrcl__wait__set__t.html">rcl_wait_set_t</a> *wait_set, <a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a> *allocator)</td></tr>
<tr class="memdesc:a4862187d323d417a69d89e9dd3404436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the wait set's allocator.  <a href="#a4862187d323d417a69d89e9dd3404436">More...</a><br /></td></tr>
<tr class="separator:a4862187d323d417a69d89e9dd3404436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb5479a7a9ab03d85336df81dfd0cb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wait_8h.html#a2eb5479a7a9ab03d85336df81dfd0cb8">rcl_wait_set_add_subscription</a> (<a class="el" href="structrcl__wait__set__t.html">rcl_wait_set_t</a> *wait_set, const <a class="el" href="structrcl__subscription__t.html">rcl_subscription_t</a> *subscription, size_t *index)</td></tr>
<tr class="memdesc:a2eb5479a7a9ab03d85336df81dfd0cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a pointer to the given subscription in the next empty spot in the set.  <a href="#a2eb5479a7a9ab03d85336df81dfd0cb8">More...</a><br /></td></tr>
<tr class="separator:a2eb5479a7a9ab03d85336df81dfd0cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8907c647b4dc5f3924205e64adb3fae4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wait_8h.html#a8907c647b4dc5f3924205e64adb3fae4">rcl_wait_set_clear</a> (<a class="el" href="structrcl__wait__set__t.html">rcl_wait_set_t</a> *wait_set)</td></tr>
<tr class="memdesc:a8907c647b4dc5f3924205e64adb3fae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove (sets to <code>NULL</code>) all entities in the wait set.  <a href="#a8907c647b4dc5f3924205e64adb3fae4">More...</a><br /></td></tr>
<tr class="separator:a8907c647b4dc5f3924205e64adb3fae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4970ea7e29fdef26802194a22d23896"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wait_8h.html#aa4970ea7e29fdef26802194a22d23896">rcl_wait_set_resize</a> (<a class="el" href="structrcl__wait__set__t.html">rcl_wait_set_t</a> *wait_set, size_t subscriptions_size, size_t guard_conditions_size, size_t timers_size, size_t clients_size, size_t services_size)</td></tr>
<tr class="memdesc:aa4970ea7e29fdef26802194a22d23896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocate space for entities in the wait set.  <a href="#aa4970ea7e29fdef26802194a22d23896">More...</a><br /></td></tr>
<tr class="separator:aa4970ea7e29fdef26802194a22d23896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1355ec090f0b2c8b6e3f0f51f639c77d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wait_8h.html#a1355ec090f0b2c8b6e3f0f51f639c77d">rcl_wait_set_add_guard_condition</a> (<a class="el" href="structrcl__wait__set__t.html">rcl_wait_set_t</a> *wait_set, const <a class="el" href="structrcl__guard__condition__t.html">rcl_guard_condition_t</a> *guard_condition, size_t *index)</td></tr>
<tr class="memdesc:a1355ec090f0b2c8b6e3f0f51f639c77d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a pointer to the guard condition in the next empty spot in the set.  <a href="#a1355ec090f0b2c8b6e3f0f51f639c77d">More...</a><br /></td></tr>
<tr class="separator:a1355ec090f0b2c8b6e3f0f51f639c77d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab763c5a40ef78377a86b99e0eca96198"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wait_8h.html#ab763c5a40ef78377a86b99e0eca96198">rcl_wait_set_add_timer</a> (<a class="el" href="structrcl__wait__set__t.html">rcl_wait_set_t</a> *wait_set, const <a class="el" href="structrcl__timer__t.html">rcl_timer_t</a> *timer, size_t *index)</td></tr>
<tr class="memdesc:ab763c5a40ef78377a86b99e0eca96198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a pointer to the timer in the next empty spot in the set.  <a href="#ab763c5a40ef78377a86b99e0eca96198">More...</a><br /></td></tr>
<tr class="separator:ab763c5a40ef78377a86b99e0eca96198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f11bfe937b2b3423faff792f21bdee3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wait_8h.html#a3f11bfe937b2b3423faff792f21bdee3">rcl_wait_set_add_client</a> (<a class="el" href="structrcl__wait__set__t.html">rcl_wait_set_t</a> *wait_set, const <a class="el" href="structrcl__client__t.html">rcl_client_t</a> *client, size_t *index)</td></tr>
<tr class="memdesc:a3f11bfe937b2b3423faff792f21bdee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a pointer to the client in the next empty spot in the set.  <a href="#a3f11bfe937b2b3423faff792f21bdee3">More...</a><br /></td></tr>
<tr class="separator:a3f11bfe937b2b3423faff792f21bdee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8da373a9474c32b102190495906abf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wait_8h.html#a2d8da373a9474c32b102190495906abf">rcl_wait_set_add_service</a> (<a class="el" href="structrcl__wait__set__t.html">rcl_wait_set_t</a> *wait_set, const <a class="el" href="structrcl__service__t.html">rcl_service_t</a> *service, size_t *index)</td></tr>
<tr class="memdesc:a2d8da373a9474c32b102190495906abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a pointer to the service in the next empty spot in the set.  <a href="#a2d8da373a9474c32b102190495906abf">More...</a><br /></td></tr>
<tr class="separator:a2d8da373a9474c32b102190495906abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a732278988c802fe2c9d8ec24752f9dd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wait_8h.html#a732278988c802fe2c9d8ec24752f9dd9">rcl_wait</a> (<a class="el" href="structrcl__wait__set__t.html">rcl_wait_set_t</a> *wait_set, int64_t timeout)</td></tr>
<tr class="memdesc:a732278988c802fe2c9d8ec24752f9dd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block until the wait set is ready or until the timeout has been exceeded.  <a href="#a732278988c802fe2c9d8ec24752f9dd9">More...</a><br /></td></tr>
<tr class="separator:a732278988c802fe2c9d8ec24752f9dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="aab0067a065def35dfb3c85fd89dc50f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab0067a065def35dfb3c85fd89dc50f1">&#9670;&nbsp;</a></span>rcl_wait_set_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structrcl__wait__set__t.html">rcl_wait_set_t</a>  <a class="el" href="structrcl__wait__set__t.html">rcl_wait_set_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Container for subscription's, guard condition's, etc to be waited on. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab6463602996a20c928b1980222499ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6463602996a20c928b1980222499ffb">&#9670;&nbsp;</a></span>rcl_get_zero_initialized_wait_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrcl__wait__set__t.html">rcl_wait_set_t</a> rcl_get_zero_initialized_wait_set </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <a class="el" href="structrcl__wait__set__t.html" title="Container for subscription&#39;s, guard condition&#39;s, etc to be waited on. ">rcl_wait_set_t</a> struct with members set to <code>NULL</code>. </p>

</div>
</div>
<a id="af51cf85900a17ddec4fee8b92f96c9a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af51cf85900a17ddec4fee8b92f96c9a0">&#9670;&nbsp;</a></span>rcl_wait_set_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> rcl_wait_set_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__wait__set__t.html">rcl_wait_set_t</a> *&#160;</td>
          <td class="paramname"><em>wait_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_subscriptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_guard_conditions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_timers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_clients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_services</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a>&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a rcl wait set with space for items to be waited on. </p>
<p>This function allocates space for the subscriptions and other wait-able entities that can be stored in the wait set. It also sets the allocator to the given allocator and initializes the pruned member to be false.</p>
<p>The wait_set struct should be allocated and initialized to <code>NULL</code>. If the wait_set is allocated but the memory is uninitialized the behavior is undefined. Calling this function on a wait set that has already been initialized will result in an error. A wait set can be reinitialized if <a class="el" href="wait_8h.html#a16b71f790a6cc23c1a7174b35e70fc8e" title="Finalize a rcl wait set. ">rcl_wait_set_fini()</a> was called on it.</p>
<p>To use the default allocator use <a class="el" href="allocator_8h.html#a2546f065f55387ed642d455a55ba7602">rcl_get_default_allocator()</a>.</p>
<p>Expected usage:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="wait_8h.html">rcl/wait.h</a>&gt;</span></div><div class="line"></div><div class="line"><a class="code" href="structrcl__wait__set__t.html">rcl_wait_set_t</a> wait_set = <a class="code" href="wait_8h.html#ab6463602996a20c928b1980222499ffb">rcl_get_zero_initialized_wait_set</a>();</div><div class="line"><a class="code" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> ret =</div><div class="line">  <a class="code" href="wait_8h.html#af51cf85900a17ddec4fee8b92f96c9a0">rcl_wait_set_init</a>(&amp;wait_set, 42, 42, 42, 42, 42, <a class="code" href="allocator_8h.html#a2546f065f55387ed642d455a55ba7602">rcl_get_default_allocator</a>());</div><div class="line"><span class="comment">// ... error handling, then use it, then call the matching fini:</span></div><div class="line">ret = <a class="code" href="wait_8h.html#a16b71f790a6cc23c1a7174b35e70fc8e">rcl_wait_set_fini</a>(&amp;wait_set);</div><div class="line"><span class="comment">// ... error handling</span></div></div><!-- fragment --><hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>Yes </td></tr>
<tr>
<td>Thread-Safe </td><td>No </td></tr>
<tr>
<td>Uses Atomics </td><td>No </td></tr>
<tr>
<td>Lock-Free </td><td>Yes </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">wait_set</td><td>the wait set struct to be initialized </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">number_of_subscriptions</td><td>non-zero size of the subscriptions set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">number_of_guard_conditions</td><td>non-zero size of the guard conditions set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">number_of_timers</td><td>non-zero size of the timers set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">number_of_clients</td><td>non-zero size of the clients set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">number_of_services</td><td>non-zero size of the services set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>the allocator to use when allocating space in the sets </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RCL_RET_OK</code> if the wait set is initialized successfully, or </dd>
<dd>
<code>RCL_RET_ALREADY_INIT</code> if the wait set is not zero initialized, or </dd>
<dd>
<code>RCL_RET_INVALID_ARGUMENT</code> if any arguments are invalid, or </dd>
<dd>
<code>RCL_RET_BAD_ALLOC</code> if allocating memory failed, or </dd>
<dd>
<code>RCL_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a id="a16b71f790a6cc23c1a7174b35e70fc8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b71f790a6cc23c1a7174b35e70fc8e">&#9670;&nbsp;</a></span>rcl_wait_set_fini()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> rcl_wait_set_fini </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__wait__set__t.html">rcl_wait_set_t</a> *&#160;</td>
          <td class="paramname"><em>wait_set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a rcl wait set. </p>
<p>Deallocates any memory in the wait set that was allocated in <a class="el" href="wait_8h.html#af51cf85900a17ddec4fee8b92f96c9a0" title="Initialize a rcl wait set with space for items to be waited on. ">rcl_wait_set_init()</a> using the allocator given in the initialization.</p>
<p>Calling this function on a zero initialized wait set will do nothing and return RCL_RET_OK. Calling this function on uninitialized memory results in undefined behavior. After calling this function the wait set will once again be zero initialized and so calling this function or <a class="el" href="wait_8h.html#af51cf85900a17ddec4fee8b92f96c9a0" title="Initialize a rcl wait set with space for items to be waited on. ">rcl_wait_set_init()</a> immediately after will succeed.</p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>Yes </td></tr>
<tr>
<td>Thread-Safe </td><td>No </td></tr>
<tr>
<td>Uses Atomics </td><td>No </td></tr>
<tr>
<td>Lock-Free </td><td>Yes </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">wait_set</td><td>the wait set struct to be finalized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RCL_RET_OK</code> if the finalization was successful, or </dd>
<dd>
<code>RCL_RET_INVALID_ARGUMENT</code> if any arguments are invalid, or </dd>
<dd>
<code>RCL_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a id="a4862187d323d417a69d89e9dd3404436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4862187d323d417a69d89e9dd3404436">&#9670;&nbsp;</a></span>rcl_wait_set_get_allocator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> rcl_wait_set_get_allocator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrcl__wait__set__t.html">rcl_wait_set_t</a> *&#160;</td>
          <td class="paramname"><em>wait_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the wait set's allocator. </p>
<p>The allocator must be an allocated rcl_allocator_t struct, as the result is copied into this variable.</p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>Yes </td></tr>
<tr>
<td>Thread-Safe </td><td>No </td></tr>
<tr>
<td>Uses Atomics </td><td>No </td></tr>
<tr>
<td>Lock-Free </td><td>Yes </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wait_set</td><td>the handle to the wait set </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">allocator</td><td>the rcl_allocator_t struct to which the result is copied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RCL_RET_OK</code> if the allocator was successfully retrieved, or </dd>
<dd>
<code>RCL_RET_INVALID_ARGUMENT</code> if any arguments are invalid, or </dd>
<dd>
<code>RCL_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a id="a2eb5479a7a9ab03d85336df81dfd0cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb5479a7a9ab03d85336df81dfd0cb8">&#9670;&nbsp;</a></span>rcl_wait_set_add_subscription()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> rcl_wait_set_add_subscription </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__wait__set__t.html">rcl_wait_set_t</a> *&#160;</td>
          <td class="paramname"><em>wait_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrcl__subscription__t.html">rcl_subscription_t</a> *&#160;</td>
          <td class="paramname"><em>subscription</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store a pointer to the given subscription in the next empty spot in the set. </p>
<p>This function does not guarantee that the subscription is not already in the wait set.</p>
<p>Also add the rmw representation to the underlying rmw array and increment the rmw array count.</p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>Yes </td></tr>
<tr>
<td>Thread-Safe </td><td>No </td></tr>
<tr>
<td>Uses Atomics </td><td>No </td></tr>
<tr>
<td>Lock-Free </td><td>Yes </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">wait_set</td><td>struct in which the subscription is to be stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subscription</td><td>the subscription to be added to the wait set </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">index</td><td>the index of the added subscription in the storage container. This parameter is optional and can be set to <code>NULL</code> to be ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RCL_RET_OK</code> if added successfully, or </dd>
<dd>
<code>RCL_RET_INVALID_ARGUMENT</code> if any arguments are invalid, or </dd>
<dd>
<code>RCL_RET_WAIT_SET_INVALID</code> if the wait set is zero initialized, or </dd>
<dd>
<code>RCL_RET_WAIT_SET_FULL</code> if the subscription set is full, or </dd>
<dd>
<code>RCL_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a id="a8907c647b4dc5f3924205e64adb3fae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8907c647b4dc5f3924205e64adb3fae4">&#9670;&nbsp;</a></span>rcl_wait_set_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> rcl_wait_set_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__wait__set__t.html">rcl_wait_set_t</a> *&#160;</td>
          <td class="paramname"><em>wait_set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove (sets to <code>NULL</code>) all entities in the wait set. </p>
<p>This function should be used after passing using rcl_wait, but before adding new entities to the set. Sets all of the entries in the underlying rmw array to <code>NULL</code>, and sets the count in the rmw array to <code>0</code>.</p>
<p>Calling this on an uninitialized (zero initialized) wait set will fail.</p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>No </td></tr>
<tr>
<td>Thread-Safe </td><td>No </td></tr>
<tr>
<td>Uses Atomics </td><td>No </td></tr>
<tr>
<td>Lock-Free </td><td>Yes </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">wait_set</td><td>struct to have its entities cleared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RCL_RET_OK</code> if cleared successfully, or </dd>
<dd>
<code>RCL_RET_INVALID_ARGUMENT</code> if any arguments are invalid, or </dd>
<dd>
<code>RCL_RET_WAIT_SET_INVALID</code> if the wait set is zero initialized, or </dd>
<dd>
<code>RCL_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a id="aa4970ea7e29fdef26802194a22d23896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4970ea7e29fdef26802194a22d23896">&#9670;&nbsp;</a></span>rcl_wait_set_resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> rcl_wait_set_resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__wait__set__t.html">rcl_wait_set_t</a> *&#160;</td>
          <td class="paramname"><em>wait_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>subscriptions_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>guard_conditions_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>timers_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>clients_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>services_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reallocate space for entities in the wait set. </p>
<p>This function will deallocate and reallocate the memory for all entity sets.</p>
<p>A size of 0 will just deallocate the memory and assign <code>NULL</code> to the array.</p>
<p>Allocation and deallocation is done with the allocator given during the wait set's initialization.</p>
<p>After calling this function all values in the set will be set to <code>NULL</code>, effectively the same as calling <a class="el" href="wait_8h.html#a8907c647b4dc5f3924205e64adb3fae4" title="Remove (sets to NULL) all entities in the wait set. ">rcl_wait_set_clear()</a>. Similarly, the underlying rmw representation is reallocated and reset: all entries are set to <code>NULL</code> and the count is set to zero.</p>
<p>If the requested size matches the current size, no allocation will be done.</p>
<p>This can be called on an uninitialized (zero initialized) wait set.</p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>Yes </td></tr>
<tr>
<td>Thread-Safe </td><td>No </td></tr>
<tr>
<td>Uses Atomics </td><td>No </td></tr>
<tr>
<td>Lock-Free </td><td>Yes </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">wait_set</td><td>struct to be resized </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subscriptions_size</td><td>a size for the new subscriptions set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">guard_conditions_size</td><td>a size for the new guard conditions set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timers_size</td><td>a size for the new timers set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clients_size</td><td>a size for the new clients set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">services_size</td><td>a size for the new services set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RCL_RET_OK</code> if resized successfully, or </dd>
<dd>
<code>RCL_RET_INVALID_ARGUMENT</code> if any arguments are invalid, or </dd>
<dd>
<code>RCL_RET_BAD_ALLOC</code> if allocating memory failed, or </dd>
<dd>
<code>RCL_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a id="a1355ec090f0b2c8b6e3f0f51f639c77d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1355ec090f0b2c8b6e3f0f51f639c77d">&#9670;&nbsp;</a></span>rcl_wait_set_add_guard_condition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> rcl_wait_set_add_guard_condition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__wait__set__t.html">rcl_wait_set_t</a> *&#160;</td>
          <td class="paramname"><em>wait_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrcl__guard__condition__t.html">rcl_guard_condition_t</a> *&#160;</td>
          <td class="paramname"><em>guard_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store a pointer to the guard condition in the next empty spot in the set. </p>
<p>This function behaves exactly the same as for subscriptions. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="wait_8h.html#a2eb5479a7a9ab03d85336df81dfd0cb8" title="Store a pointer to the given subscription in the next empty spot in the set. ">rcl_wait_set_add_subscription</a> </dd></dl>

</div>
</div>
<a id="ab763c5a40ef78377a86b99e0eca96198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab763c5a40ef78377a86b99e0eca96198">&#9670;&nbsp;</a></span>rcl_wait_set_add_timer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> rcl_wait_set_add_timer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__wait__set__t.html">rcl_wait_set_t</a> *&#160;</td>
          <td class="paramname"><em>wait_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrcl__timer__t.html">rcl_timer_t</a> *&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store a pointer to the timer in the next empty spot in the set. </p>
<p>This function behaves exactly the same as for subscriptions. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="wait_8h.html#a2eb5479a7a9ab03d85336df81dfd0cb8" title="Store a pointer to the given subscription in the next empty spot in the set. ">rcl_wait_set_add_subscription</a> </dd></dl>

</div>
</div>
<a id="a3f11bfe937b2b3423faff792f21bdee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f11bfe937b2b3423faff792f21bdee3">&#9670;&nbsp;</a></span>rcl_wait_set_add_client()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> rcl_wait_set_add_client </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__wait__set__t.html">rcl_wait_set_t</a> *&#160;</td>
          <td class="paramname"><em>wait_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrcl__client__t.html">rcl_client_t</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store a pointer to the client in the next empty spot in the set. </p>
<p>This function behaves exactly the same as for subscriptions. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="wait_8h.html#a2eb5479a7a9ab03d85336df81dfd0cb8" title="Store a pointer to the given subscription in the next empty spot in the set. ">rcl_wait_set_add_subscription</a> </dd></dl>

</div>
</div>
<a id="a2d8da373a9474c32b102190495906abf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d8da373a9474c32b102190495906abf">&#9670;&nbsp;</a></span>rcl_wait_set_add_service()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> rcl_wait_set_add_service </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__wait__set__t.html">rcl_wait_set_t</a> *&#160;</td>
          <td class="paramname"><em>wait_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrcl__service__t.html">rcl_service_t</a> *&#160;</td>
          <td class="paramname"><em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store a pointer to the service in the next empty spot in the set. </p>
<p>This function behaves exactly the same as for subscriptions. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="wait_8h.html#a2eb5479a7a9ab03d85336df81dfd0cb8" title="Store a pointer to the given subscription in the next empty spot in the set. ">rcl_wait_set_add_subscription</a> </dd></dl>

</div>
</div>
<a id="a732278988c802fe2c9d8ec24752f9dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a732278988c802fe2c9d8ec24752f9dd9">&#9670;&nbsp;</a></span>rcl_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> rcl_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__wait__set__t.html">rcl_wait_set_t</a> *&#160;</td>
          <td class="paramname"><em>wait_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block until the wait set is ready or until the timeout has been exceeded. </p>
<p>This function will collect the items in the <a class="el" href="structrcl__wait__set__t.html" title="Container for subscription&#39;s, guard condition&#39;s, etc to be waited on. ">rcl_wait_set_t</a> and pass them to the underlying rmw_wait function.</p>
<p>The items in the wait set will be either left untouched or set to <code>NULL</code> after this function returns. Items that are not <code>NULL</code> are ready, where ready means different things based on the type of the item. For subscriptions this means there may be messages that can be taken, or perhaps that the state of the subscriptions has changed, in which case rcl_take may succeed but return with taken == false. For guard conditions this means the guard condition was triggered.</p>
<p>Expected usage:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="rcl_8h.html">rcl/rcl.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// rcl_init() called successfully before here...</span></div><div class="line"><a class="code" href="structrcl__node__t.html">rcl_node_t</a> node;  <span class="comment">// initialize this, see rcl_node_init()</span></div><div class="line"><a class="code" href="structrcl__subscription__t.html">rcl_subscription_t</a> sub1;  <span class="comment">// initialize this, see rcl_subscription_init()</span></div><div class="line"><a class="code" href="structrcl__subscription__t.html">rcl_subscription_t</a> sub2;  <span class="comment">// initialize this, see rcl_subscription_init()</span></div><div class="line"><a class="code" href="structrcl__guard__condition__t.html">rcl_guard_condition_t</a> gc1;  <span class="comment">// initialize this, see rcl_guard_condition_init()</span></div><div class="line"><a class="code" href="structrcl__wait__set__t.html">rcl_wait_set_t</a> wait_set = <a class="code" href="wait_8h.html#ab6463602996a20c928b1980222499ffb">rcl_get_zero_initialized_wait_set</a>();</div><div class="line"><a class="code" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> ret = <a class="code" href="wait_8h.html#af51cf85900a17ddec4fee8b92f96c9a0">rcl_wait_set_init</a>(&amp;wait_set, 2, 1, 0, 0, 0, <a class="code" href="allocator_8h.html#a2546f065f55387ed642d455a55ba7602">rcl_get_default_allocator</a>());</div><div class="line"><span class="comment">// ... error handling</span></div><div class="line"><span class="keywordflow">do</span> {</div><div class="line">  ret = <a class="code" href="wait_8h.html#a8907c647b4dc5f3924205e64adb3fae4">rcl_wait_set_clear</a>(&amp;wait_set);</div><div class="line">  <span class="comment">// ... error handling</span></div><div class="line">  ret = <a class="code" href="wait_8h.html#a2eb5479a7a9ab03d85336df81dfd0cb8">rcl_wait_set_add_subscription</a>(&amp;wait_set, &amp;sub1);</div><div class="line">  <span class="comment">// ... error handling</span></div><div class="line">  ret = <a class="code" href="wait_8h.html#a2eb5479a7a9ab03d85336df81dfd0cb8">rcl_wait_set_add_subscription</a>(&amp;wait_set, &amp;sub2);</div><div class="line">  <span class="comment">// ... error handling</span></div><div class="line">  ret = <a class="code" href="wait_8h.html#a1355ec090f0b2c8b6e3f0f51f639c77d">rcl_wait_set_add_guard_condition</a>(&amp;wait_set, &amp;gc1);</div><div class="line">  <span class="comment">// ... error handling</span></div><div class="line">  ret = <a class="code" href="wait_8h.html#a732278988c802fe2c9d8ec24752f9dd9">rcl_wait</a>(&amp;wait_set, <a class="code" href="time_8h.html#a2b6c1f35e2df71ebccae0921ffae7e6b">RCL_MS_TO_NS</a>(1000));  <span class="comment">// 1000ms == 1s, passed as ns</span></div><div class="line">  <span class="keywordflow">if</span> (ret == <a class="code" href="types_8h.html#af49afc7a61fba7389d122554bfc5993d">RCL_RET_TIMEOUT</a>) {</div><div class="line">    <span class="keywordflow">continue</span>;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; wait_set.<a class="code" href="structrcl__wait__set__t.html#a45890fdd82faa73fab68f6fab35973e5">size_of_subscriptions</a>; ++i) {</div><div class="line">    <span class="keywordflow">if</span> (wait_set.<a class="code" href="structrcl__wait__set__t.html#af99a127424297896d6f260471d5515b7">subscriptions</a>[i]) {</div><div class="line">      <span class="comment">// The subscription is ready...</span></div><div class="line">    }</div><div class="line">  }</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; wait_set.<a class="code" href="structrcl__wait__set__t.html#a605132a5d6060a5df9f25571db2ff5b7">size_of_guard_conditions</a>; ++i) {</div><div class="line">    <span class="keywordflow">if</span> (wait_set.<a class="code" href="structrcl__wait__set__t.html#a5ffd23a51b8fa43d947bcc70253c9dbd">guard_conditions</a>[i]) {</div><div class="line">      <span class="comment">// The subscription is ready...</span></div><div class="line">    }</div><div class="line">  }</div><div class="line">} <span class="keywordflow">while</span>(check_some_condition());</div><div class="line"><span class="comment">// ... fini node, and subscriptions and guard conditions...</span></div><div class="line">ret = <a class="code" href="wait_8h.html#a16b71f790a6cc23c1a7174b35e70fc8e">rcl_wait_set_fini</a>(&amp;wait_set);</div><div class="line"><span class="comment">// ... error handling</span></div></div><!-- fragment --><p>The wait set struct must be allocated, initialized, and should have been cleared and then filled with items, e.g. subscriptions and guard conditions. Passing a wait set with no wait-able items in it will fail. <code>NULL</code> items in the sets are ignored, e.g. it is valid to have as input:</p><ul>
<li><code>subscriptions[0]</code> = valid pointer</li>
<li><code>subscriptions[1]</code> = <code>NULL</code></li>
<li><code>subscriptions[2]</code> = valid pointer</li>
<li><code>size_of_subscriptions</code> = 3 Passing an uninitialized (zero initialized) wait set struct will fail. Passing a wait set struct with uninitialized memory is undefined behavior.</li>
</ul>
<p>The unit of timeout is nanoseconds. If the timeout is negative then this function will block indefinitely until something in the wait set is valid or it is interrupted. If the timeout is 0 then this function will be non-blocking; checking what's ready now, but not waiting if nothing is ready yet. If the timeout is greater than 0 then this function will return after that period of time has elapsed or the wait set becomes ready, which ever comes first. Passing a timeout struct with uninitialized memory is undefined behavior.</p>
<p>This function is thread-safe for unique wait sets with unique contents. This function cannot operate on the same wait set in multiple threads, and the wait sets may not share content. For example, calling <a class="el" href="wait_8h.html#a732278988c802fe2c9d8ec24752f9dd9" title="Block until the wait set is ready or until the timeout has been exceeded. ">rcl_wait()</a> in two threads on two different wait sets that both contain a single, shared guard condition is undefined behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">wait_set</td><td>the set of things to be waited on and to be pruned if not ready </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>the duration to wait for the wait set to be ready, in nanoseconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RCL_RET_OK</code> something in the wait set became ready, or </dd>
<dd>
<code>RCL_RET_INVALID_ARGUMENT</code> if any arguments are invalid, or </dd>
<dd>
<code>RCL_RET_WAIT_SET_INVALID</code> if the wait set is zero initialized, or </dd>
<dd>
<code>RCL_RET_WAIT_SET_EMPTY</code> if the wait set contains no items, or </dd>
<dd>
<code>RCL_RET_TIMEOUT</code> if the timeout expired before something was ready, or </dd>
<dd>
<code>RCL_RET_ERROR</code> an unspecified error occur. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
