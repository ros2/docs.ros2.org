<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rcl: src/rcl/arguments.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rcl
   &#160;<span id="projectnumber">master</span>
   </div>
   <div id="projectbrief">C API providing common ROS client library functionality.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_8d2ff9a475ce94ede13c8bc9f5da84d1.html">rcl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">arguments.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="arguments_8h_source.html">rcl/arguments.h</a>&quot;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &quot;./arguments_impl.h&quot;</code><br />
<code>#include &quot;./remap_impl.h&quot;</code><br />
<code>#include &quot;<a class="el" href="error__handling_8h_source.html">rcl/error_handling.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lexer__lookahead_8h_source.html">rcl/lexer_lookahead.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="validate__topic__name_8h_source.html">rcl/validate_topic_name.h</a>&quot;</code><br />
<code>#include &quot;<a class="elRef" doxygen="/home/developer/workspaces/docs_crystal/doxygen_tag_files/rcutils.tag:http://docs.ros2.org/crystal/api/rcutils/" href="http://docs.ros2.org/crystal/api/rcutils/allocator_8h.html">rcutils/allocator.h</a>&quot;</code><br />
<code>#include &quot;<a class="elRef" doxygen="/home/developer/workspaces/docs_crystal/doxygen_tag_files/rcutils.tag:http://docs.ros2.org/crystal/api/rcutils/" href="http://docs.ros2.org/crystal/api/rcutils/error__handling_8h.html">rcutils/error_handling.h</a>&quot;</code><br />
<code>#include &quot;<a class="elRef" doxygen="/home/developer/workspaces/docs_crystal/doxygen_tag_files/rcutils.tag:http://docs.ros2.org/crystal/api/rcutils/" href="http://docs.ros2.org/crystal/api/rcutils/format__string_8h.html">rcutils/format_string.h</a>&quot;</code><br />
<code>#include &quot;<a class="elRef" doxygen="/home/developer/workspaces/docs_crystal/doxygen_tag_files/rcutils.tag:http://docs.ros2.org/crystal/api/rcutils/" href="http://docs.ros2.org/crystal/api/rcutils/logging_8h.html">rcutils/logging.h</a>&quot;</code><br />
<code>#include &quot;rcutils/logging_macros.h&quot;</code><br />
<code>#include &quot;<a class="elRef" doxygen="/home/developer/workspaces/docs_crystal/doxygen_tag_files/rcutils.tag:http://docs.ros2.org/crystal/api/rcutils/" href="http://docs.ros2.org/crystal/api/rcutils/strdup_8h.html">rcutils/strdup.h</a>&quot;</code><br />
<code>#include &quot;<a class="elRef" doxygen="/home/developer/workspaces/docs_crystal/doxygen_tag_files/rmw.tag:http://docs.ros2.org/crystal/api/rmw/" href="http://docs.ros2.org/crystal/api/rmw/validate__namespace_8h.html">rmw/validate_namespace.h</a>&quot;</code><br />
<code>#include &quot;<a class="elRef" doxygen="/home/developer/workspaces/docs_crystal/doxygen_tag_files/rmw.tag:http://docs.ros2.org/crystal/api/rmw/" href="http://docs.ros2.org/crystal/api/rmw/validate__node__name_8h.html">rmw/validate_node_name.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for arguments.c:</div>
<div class="dyncontent">
<div class="center"><img src="arguments_8c__incl.png" border="0" usemap="#src_2rcl_2arguments_8c" alt=""/></div>
<map name="src_2rcl_2arguments_8c" id="src_2rcl_2arguments_8c">
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2ada6c2d3316bfb19fe47a801d67f241"><td class="memItemLeft" align="right" valign="top"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#a2ada6c2d3316bfb19fe47a801d67f241">_rcl_parse_remap_rule</a> (const char *arg, <a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a> allocator, rcl_remap_t *output_rule)</td></tr>
<tr class="memdesc:a2ada6c2d3316bfb19fe47a801d67f241"><td class="mdescLeft">&#160;</td><td class="mdescRight">// Internal Doxygen documentation  <a href="#a2ada6c2d3316bfb19fe47a801d67f241">More...</a><br /></td></tr>
<tr class="separator:a2ada6c2d3316bfb19fe47a801d67f241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8faf3de98626c3b2785e111da89252b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#a8faf3de98626c3b2785e111da89252b3">_rcl_parse_param_file_rule</a> (const char *arg, <a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a> allocator, char **param_file)</td></tr>
<tr class="memdesc:a8faf3de98626c3b2785e111da89252b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an argument that may or may not be a parameter file rule.  <a href="#a8faf3de98626c3b2785e111da89252b3">More...</a><br /></td></tr>
<tr class="separator:a8faf3de98626c3b2785e111da89252b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7a9bc87595ebc889aa78fd83fe61d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#a8d7a9bc87595ebc889aa78fd83fe61d5">rcl_arguments_get_param_files</a> (const <a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> *arguments, <a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a> allocator, char ***parameter_files)</td></tr>
<tr class="memdesc:a8d7a9bc87595ebc889aa78fd83fe61d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of yaml parameter file paths specified on the command line.  <a href="#a8d7a9bc87595ebc889aa78fd83fe61d5">More...</a><br /></td></tr>
<tr class="separator:a8d7a9bc87595ebc889aa78fd83fe61d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68964d428b8c7e280cf82461c6ebe78"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#ad68964d428b8c7e280cf82461c6ebe78">rcl_arguments_get_param_files_count</a> (const <a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> *args)</td></tr>
<tr class="memdesc:ad68964d428b8c7e280cf82461c6ebe78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of parameter yaml files given in the arguments.  <a href="#ad68964d428b8c7e280cf82461c6ebe78">More...</a><br /></td></tr>
<tr class="separator:ad68964d428b8c7e280cf82461c6ebe78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c8de226f6305b62702ff6142ab809c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#a69c8de226f6305b62702ff6142ab809c">_rcl_parse_log_level_rule</a> (const char *arg, <a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a> allocator, int *log_level)</td></tr>
<tr class="memdesc:a69c8de226f6305b62702ff6142ab809c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an argument that may or may not be a log level rule.  <a href="#a69c8de226f6305b62702ff6142ab809c">More...</a><br /></td></tr>
<tr class="separator:a69c8de226f6305b62702ff6142ab809c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64bc48ad928b30bcf9a648377e5389b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#ab64bc48ad928b30bcf9a648377e5389b">_rcl_parse_external_log_config_file</a> (const char *arg, <a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a> allocator, char **log_config_file)</td></tr>
<tr class="memdesc:ab64bc48ad928b30bcf9a648377e5389b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an argument that may or may not be a log file rule.  <a href="#ab64bc48ad928b30bcf9a648377e5389b">More...</a><br /></td></tr>
<tr class="separator:ab64bc48ad928b30bcf9a648377e5389b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e87903fe684a615ed78ab81a8521894"><td class="memItemLeft" align="right" valign="top"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#a3e87903fe684a615ed78ab81a8521894">_rcl_parse_bool_arg</a> (const char *arg, const char *key, bool *value)</td></tr>
<tr class="memdesc:a3e87903fe684a615ed78ab81a8521894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a bool argument that may or may not be for the provided key rule.  <a href="#a3e87903fe684a615ed78ab81a8521894">More...</a><br /></td></tr>
<tr class="separator:a3e87903fe684a615ed78ab81a8521894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa092e096d14c3f664b2f01251e4c216f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#aa092e096d14c3f664b2f01251e4c216f">_atob</a> (const char *str, bool *val)</td></tr>
<tr class="memdesc:aa092e096d14c3f664b2f01251e4c216f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a null terminated string to a boolean value.  <a href="#aa092e096d14c3f664b2f01251e4c216f">More...</a><br /></td></tr>
<tr class="separator:aa092e096d14c3f664b2f01251e4c216f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac115fc88cd80fb7832d4df9f8c634f72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#ac115fc88cd80fb7832d4df9f8c634f72">rcl_parse_arguments</a> (int argc, const char *const argv[], <a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a> allocator, <a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> *args_output)</td></tr>
<tr class="memdesc:ac115fc88cd80fb7832d4df9f8c634f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse command line arguments into a structure usable by code.  <a href="#ac115fc88cd80fb7832d4df9f8c634f72">More...</a><br /></td></tr>
<tr class="separator:ac115fc88cd80fb7832d4df9f8c634f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3651d7428c5c2789d27872155023ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#acc3651d7428c5c2789d27872155023ce">rcl_arguments_get_count_unparsed</a> (const <a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> *args)</td></tr>
<tr class="memdesc:acc3651d7428c5c2789d27872155023ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of arguments that were not successfully parsed.  <a href="#acc3651d7428c5c2789d27872155023ce">More...</a><br /></td></tr>
<tr class="separator:acc3651d7428c5c2789d27872155023ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6722d8fc966d9cc3ddcb60fe32c44a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#ade6722d8fc966d9cc3ddcb60fe32c44a">rcl_arguments_get_unparsed</a> (const <a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> *args, <a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a> allocator, int **output_unparsed_indices)</td></tr>
<tr class="memdesc:ade6722d8fc966d9cc3ddcb60fe32c44a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of indexes that weren't successfully parsed.  <a href="#ade6722d8fc966d9cc3ddcb60fe32c44a">More...</a><br /></td></tr>
<tr class="separator:ade6722d8fc966d9cc3ddcb60fe32c44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147323ec6ccf940e3a2caf953ec7d3e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#a147323ec6ccf940e3a2caf953ec7d3e7">rcl_get_zero_initialized_arguments</a> (void)</td></tr>
<tr class="memdesc:a147323ec6ccf940e3a2caf953ec7d3e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="structrcl__node__t.html" title="Structure which encapsulates a ROS Node. ">rcl_node_t</a> struct with members initialized to <code>NULL</code>.  <a href="#a147323ec6ccf940e3a2caf953ec7d3e7">More...</a><br /></td></tr>
<tr class="separator:a147323ec6ccf940e3a2caf953ec7d3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7f3b5096ff92e8a4877cca33387673"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#aaa7f3b5096ff92e8a4877cca33387673">rcl_remove_ros_arguments</a> (char const *const argv[], const <a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> *args, <a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a> allocator, int *nonros_argc, const char **nonros_argv[])</td></tr>
<tr class="memdesc:aaa7f3b5096ff92e8a4877cca33387673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of arguments with ROS-specific arguments removed.  <a href="#aaa7f3b5096ff92e8a4877cca33387673">More...</a><br /></td></tr>
<tr class="separator:aaa7f3b5096ff92e8a4877cca33387673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe1f021f617406a45877c9d6dbc011d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#aafe1f021f617406a45877c9d6dbc011d">rcl_arguments_copy</a> (const <a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> *args, <a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> *args_out)</td></tr>
<tr class="memdesc:aafe1f021f617406a45877c9d6dbc011d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy one arguments structure into another.  <a href="#aafe1f021f617406a45877c9d6dbc011d">More...</a><br /></td></tr>
<tr class="separator:aafe1f021f617406a45877c9d6dbc011d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5287e61a227409a81add4eabbbcd4ff1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#a5287e61a227409a81add4eabbbcd4ff1">rcl_arguments_fini</a> (<a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> *args)</td></tr>
<tr class="memdesc:a5287e61a227409a81add4eabbbcd4ff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reclaim resources held inside <a class="el" href="structrcl__arguments__t.html" title="Hold output of parsing command line arguments. ">rcl_arguments_t</a> structure.  <a href="#a5287e61a227409a81add4eabbbcd4ff1">More...</a><br /></td></tr>
<tr class="separator:a5287e61a227409a81add4eabbbcd4ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194f350512bf33c4c50ea8ef4b2042de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#a194f350512bf33c4c50ea8ef4b2042de">_rcl_parse_remap_fully_qualified_namespace</a> (<a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *lex_lookahead)</td></tr>
<tr class="memdesc:a194f350512bf33c4c50ea8ef4b2042de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a fully qualified namespace for a namespace replacement rule (ex: <code>/foo/bar</code>)  <a href="#a194f350512bf33c4c50ea8ef4b2042de">More...</a><br /></td></tr>
<tr class="separator:a194f350512bf33c4c50ea8ef4b2042de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f0628d1aef04967e99b7c388950e6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#aa5f0628d1aef04967e99b7c388950e6a">_rcl_parse_remap_replacement_token</a> (<a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *lex_lookahead)</td></tr>
<tr class="memdesc:aa5f0628d1aef04967e99b7c388950e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse either a token or a backreference (ex: <code>bar</code>, or <code>\7</code>).  <a href="#aa5f0628d1aef04967e99b7c388950e6a">More...</a><br /></td></tr>
<tr class="separator:aa5f0628d1aef04967e99b7c388950e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8621594577254059073bbfdb96247f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#a2c8621594577254059073bbfdb96247f">_rcl_parse_remap_replacement_name</a> (<a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *lex_lookahead, rcl_remap_t *rule)</td></tr>
<tr class="memdesc:a2c8621594577254059073bbfdb96247f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the replacement side of a name remapping rule (ex: <code>bar/\1/foo</code>).  <a href="#a2c8621594577254059073bbfdb96247f">More...</a><br /></td></tr>
<tr class="separator:a2c8621594577254059073bbfdb96247f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e202fcbfe908d03573e38977deb3ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#a94e202fcbfe908d03573e38977deb3ec">_rcl_parse_remap_match_token</a> (<a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *lex_lookahead)</td></tr>
<tr class="memdesc:a94e202fcbfe908d03573e38977deb3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse either a token or a wildcard (ex: <code>foobar</code>, or <code>*</code>, or <code>**</code>).  <a href="#a94e202fcbfe908d03573e38977deb3ec">More...</a><br /></td></tr>
<tr class="separator:a94e202fcbfe908d03573e38977deb3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32357cb16077b5effa7a1baafb1e53a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#af32357cb16077b5effa7a1baafb1e53a">_rcl_parse_remap_match_name</a> (<a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *lex_lookahead, rcl_remap_t *rule)</td></tr>
<tr class="memdesc:af32357cb16077b5effa7a1baafb1e53a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the match side of a name remapping rule (ex: <code>rostopic://foo</code>)  <a href="#af32357cb16077b5effa7a1baafb1e53a">More...</a><br /></td></tr>
<tr class="separator:af32357cb16077b5effa7a1baafb1e53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cba41a4a9625dd75a6921785b9a97a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#a7cba41a4a9625dd75a6921785b9a97a8">_rcl_parse_remap_name_remap</a> (<a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *lex_lookahead, rcl_remap_t *rule)</td></tr>
<tr class="memdesc:a7cba41a4a9625dd75a6921785b9a97a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a name remapping rule (ex: <code>rostopic:///foo:=bar</code>).  <a href="#a7cba41a4a9625dd75a6921785b9a97a8">More...</a><br /></td></tr>
<tr class="separator:a7cba41a4a9625dd75a6921785b9a97a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64639d0b56f962914258b056c59520a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#a64639d0b56f962914258b056c59520a0">_rcl_parse_remap_namespace_replacement</a> (<a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *lex_lookahead, rcl_remap_t *rule)</td></tr>
<tr class="memdesc:a64639d0b56f962914258b056c59520a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a namespace replacement rule (ex: <code>__ns:=/new/ns</code>).  <a href="#a64639d0b56f962914258b056c59520a0">More...</a><br /></td></tr>
<tr class="separator:a64639d0b56f962914258b056c59520a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6173a24bd0cee1b62b53454fdd493c25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#a6173a24bd0cee1b62b53454fdd493c25">_rcl_parse_remap_nodename_replacement</a> (<a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *lex_lookahead, rcl_remap_t *rule)</td></tr>
<tr class="memdesc:a6173a24bd0cee1b62b53454fdd493c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a nodename replacement rule (ex: <code>__node:=new_name</code>).  <a href="#a6173a24bd0cee1b62b53454fdd493c25">More...</a><br /></td></tr>
<tr class="separator:a6173a24bd0cee1b62b53454fdd493c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19de406c16827c823c9a8ff7c663995"><td class="memItemLeft" align="right" valign="top"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#aa19de406c16827c823c9a8ff7c663995">_rcl_parse_remap_nodename_prefix</a> (<a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *lex_lookahead, rcl_remap_t *rule)</td></tr>
<tr class="memdesc:aa19de406c16827c823c9a8ff7c663995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a nodename prefix including trailing colon (ex: <code>node_name:</code>).  <a href="#aa19de406c16827c823c9a8ff7c663995">More...</a><br /></td></tr>
<tr class="separator:aa19de406c16827c823c9a8ff7c663995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84f05e93246459c68d6b3486a804cdf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#ac84f05e93246459c68d6b3486a804cdf">_rcl_parse_remap_begin_remap_rule</a> (<a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *lex_lookahead, rcl_remap_t *rule)</td></tr>
<tr class="memdesc:ac84f05e93246459c68d6b3486a804cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start recursive descent parsing of a remap rule.  <a href="#ac84f05e93246459c68d6b3486a804cdf">More...</a><br /></td></tr>
<tr class="separator:ac84f05e93246459c68d6b3486a804cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a2ada6c2d3316bfb19fe47a801d67f241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ada6c2d3316bfb19fe47a801d67f241">&#9670;&nbsp;</a></span>_rcl_parse_remap_rule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> _rcl_parse_remap_rule </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rcl_remap_t *&#160;</td>
          <td class="paramname"><em>output_rule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>// Internal Doxygen documentation </p>
<p>Parse an argument that may or may not be a remap rule. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>the argument to parse </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>an allocator to use </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">output_rule</td><td>input a zero intialized rule, output a fully initialized one </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RCL_RET_OK if a valid rule was parsed, or </dd>
<dd>
RCL_RET_INVALID_REMAP_RULE if the argument is not a valid rule, or </dd>
<dd>
RCL_RET_BAD_ALLOC if an allocation failed, or </dd>
<dd>
RLC_RET_ERROR if an unspecified error occurred. </dd></dl>

</div>
</div>
<a id="a8faf3de98626c3b2785e111da89252b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8faf3de98626c3b2785e111da89252b3">&#9670;&nbsp;</a></span>_rcl_parse_param_file_rule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> _rcl_parse_param_file_rule </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>param_file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an argument that may or may not be a parameter file rule. </p>
<p>The syntax of the file name is not validated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>the argument to parse </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>an allocator to use </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">param_file</td><td>string that could be a parameter file name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RCL_RET_OK if the rule was parsed correctly, or </dd>
<dd>
RCL_RET_INVALID_PARAM_RULE if the argument is not a valid rule, or </dd>
<dd>
RCL_RET_BAD_ALLOC if an allocation failed, or </dd>
<dd>
RLC_RET_ERROR if an unspecified error occurred. </dd></dl>

</div>
</div>
<a id="a8d7a9bc87595ebc889aa78fd83fe61d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d7a9bc87595ebc889aa78fd83fe61d5">&#9670;&nbsp;</a></span>rcl_arguments_get_param_files()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> rcl_arguments_get_param_files </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> *&#160;</td>
          <td class="paramname"><em>arguments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char ***&#160;</td>
          <td class="paramname"><em>parameter_files</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a list of yaml parameter file paths specified on the command line. </p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>Yes </td></tr>
<tr>
<td>Thread-Safe </td><td>No </td></tr>
<tr>
<td>Uses Atomics </td><td>No </td></tr>
<tr>
<td>Lock-Free </td><td>Yes </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arguments</td><td>An arguments structure that has been parsed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>A valid allocator. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">parameter_files</td><td>An allocated array of paramter file names. This array must be deallocated by the caller using the given allocator. The output is NULL if there were no paramter files. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RCL_RET_OK</code> if everything goes correctly, or </dd>
<dd>
<code>RCL_RET_INVALID_ARGUMENT</code> if any function arguments are invalid, or </dd>
<dd>
<code>RCL_RET_BAD_ALLOC</code> if allocating memory failed, or </dd>
<dd>
<code>RCL_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a id="ad68964d428b8c7e280cf82461c6ebe78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad68964d428b8c7e280cf82461c6ebe78">&#9670;&nbsp;</a></span>rcl_arguments_get_param_files_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rcl_arguments_get_param_files_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> *&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of parameter yaml files given in the arguments. </p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>No </td></tr>
<tr>
<td>Thread-Safe </td><td>No </td></tr>
<tr>
<td>Uses Atomics </td><td>No </td></tr>
<tr>
<td>Lock-Free </td><td>Yes </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>An arguments structure that has been parsed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of yaml files, or </dd>
<dd>
-1 if args is <code>NULL</code> or zero initialized. </dd></dl>

</div>
</div>
<a id="a69c8de226f6305b62702ff6142ab809c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69c8de226f6305b62702ff6142ab809c">&#9670;&nbsp;</a></span>_rcl_parse_log_level_rule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> _rcl_parse_log_level_rule </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>log_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an argument that may or may not be a log level rule. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>the argument to parse </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>an allocator to use </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log_level</td><td>parsed log level represented by <code>RCUTILS_LOG_SEVERITY</code> enum </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RCL_RET_OK if a valid log level was parsed, or </dd>
<dd>
RCL_RET_INVALID_LOG_LEVEL_RULE if the argument is not a valid rule, or </dd>
<dd>
RCL_RET_BAD_ALLOC if an allocation failed, or </dd>
<dd>
RLC_RET_ERROR if an unspecified error occurred. </dd></dl>

</div>
</div>
<a id="ab64bc48ad928b30bcf9a648377e5389b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab64bc48ad928b30bcf9a648377e5389b">&#9670;&nbsp;</a></span>_rcl_parse_external_log_config_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> _rcl_parse_external_log_config_file </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>log_config_file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an argument that may or may not be a log file rule. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>the argument to parse </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>an allocator to use </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log_config_file</td><td>parsed log configuration file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RCL_RET_OK if a valid log config file was parsed, or </dd>
<dd>
RCL_RET_BAD_ALLOC if an allocation failed, or </dd>
<dd>
RLC_RET_ERROR if an unspecified error occurred. </dd></dl>

</div>
</div>
<a id="a3e87903fe684a615ed78ab81a8521894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e87903fe684a615ed78ab81a8521894">&#9670;&nbsp;</a></span>_rcl_parse_bool_arg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> _rcl_parse_bool_arg </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a bool argument that may or may not be for the provided key rule. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>the argument to parse </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>the key for the argument to parse. Should be a null terminated string </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">value</td><td>parsed boolean value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RCL_RET_OK if the bool argument was parsed successfully, or </dd>
<dd>
RLC_RET_ERROR if an unspecified error occurred. </dd></dl>

</div>
</div>
<a id="aa092e096d14c3f664b2f01251e4c216f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa092e096d14c3f664b2f01251e4c216f">&#9670;&nbsp;</a></span>_atob()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> _atob </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a null terminated string to a boolean value. </p>
<p>The case sensitive values: "T", "t", "True", "true", "Y", "y", "Yes", "yes", and "1" will all map to true. The case sensitive values: "F", "f", "False", "false", "N", "n", "No", "no", and "0" will all map to false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>a null terminated string to be parsed into a boolean </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">val</td><td>the boolean value parsed from the string. Left unchanged if string cannot be parsed to a valid bool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RCL_RET_OK if a valid boolean parsed, or </dd>
<dd>
RLC_RET_ERROR if an unspecified error occurred. </dd></dl>

</div>
</div>
<a id="ac115fc88cd80fb7832d4df9f8c634f72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac115fc88cd80fb7832d4df9f8c634f72">&#9670;&nbsp;</a></span>rcl_parse_arguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> rcl_parse_arguments </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>argv</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> *&#160;</td>
          <td class="paramname"><em>args_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse command line arguments into a structure usable by code. </p>
<p>If an argument does not appear to be a valid ROS argument then it is skipped and parsing continues with the next argument in <code>argv</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="arguments_8h.html#a147323ec6ccf940e3a2caf953ec7d3e7" title="Return a rcl_node_t struct with members initialized to NULL. ">rcl_get_zero_initialized_arguments()</a> </dd>
<dd>
<a class="el" href="arguments_8h.html#acc3651d7428c5c2789d27872155023ce" title="Return the number of arguments that were not successfully parsed. ">rcl_arguments_get_count_unparsed()</a> </dd>
<dd>
<a class="el" href="arguments_8h.html#ade6722d8fc966d9cc3ddcb60fe32c44a" title="Return a list of indexes that weren&#39;t successfully parsed. ">rcl_arguments_get_unparsed()</a></dd></dl>
<p>Successfully parsed remap rules are stored in the order they were given in <code>argv</code>. If given arguments <code>{"__ns:=/foo", "__ns:=/bar"}</code> then the namespace used by nodes in this process will be <code>/foo</code> and not <code>/bar</code>.</p>
<p>The default log level will be parsed as <code>__log_level:=level</code>, where <code>level</code> is a name representing one of the log levels in the <code>RCUTILS_LOG_SEVERITY</code> enum, e.g. <code>info</code>, <code>debug</code>, <code>warn</code>, not case sensitive. If multiple of these rules are found, the last one parsed will be used.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="remap_8h.html#aeb75c73d609d17b1707e62c829483410" title="Remap a topic name based on given rules. ">rcl_remap_topic_name()</a> </dd>
<dd>
<a class="el" href="remap_8h.html#a0885a965511719f43a84dd3e4f19e0c5" title="Remap a service name based on given rules. ">rcl_remap_service_name()</a> </dd>
<dd>
<a class="el" href="remap_8h.html#ae44fa92a03acb1cc1c65bd1a6bdaac8d" title="Remap a node name based on given rules. ">rcl_remap_node_name()</a> </dd>
<dd>
<a class="el" href="remap_8h.html#aa066c5f410799104c35cb91d355f548e" title="Remap a namespace based on given rules. ">rcl_remap_node_namespace()</a></dd></dl>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>Yes </td></tr>
<tr>
<td>Thread-Safe </td><td>Yes </td></tr>
<tr>
<td>Uses Atomics </td><td>No </td></tr>
<tr>
<td>Lock-Free </td><td>Yes </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">argc</td><td>The number of arguments in argv. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argv</td><td>The values of the arguments. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>A valid allocator. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">args_output</td><td>A structure that will contain the result of parsing. Must be zero initialized before use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RCL_RET_OK</code> if the arguments were parsed successfully, or </dd>
<dd>
<code>RCL_RET_INVALID_ARGUMENT</code> if any function arguments are invalid, or </dd>
<dd>
<code>RCL_RET_BAD_ALLOC</code> if allocating memory failed, or </dd>
<dd>
<code>RCL_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a id="acc3651d7428c5c2789d27872155023ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc3651d7428c5c2789d27872155023ce">&#9670;&nbsp;</a></span>rcl_arguments_get_count_unparsed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rcl_arguments_get_count_unparsed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> *&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of arguments that were not successfully parsed. </p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>No </td></tr>
<tr>
<td>Thread-Safe </td><td>Yes </td></tr>
<tr>
<td>Uses Atomics </td><td>No </td></tr>
<tr>
<td>Lock-Free </td><td>Yes </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>An arguments structure that has been parsed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of unparsed arguments, or </dd>
<dd>
-1 if args is <code>NULL</code> or zero initialized. </dd></dl>

</div>
</div>
<a id="ade6722d8fc966d9cc3ddcb60fe32c44a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade6722d8fc966d9cc3ddcb60fe32c44a">&#9670;&nbsp;</a></span>rcl_arguments_get_unparsed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> rcl_arguments_get_unparsed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>output_unparsed_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a list of indexes that weren't successfully parsed. </p>
<p>Some arguments may not have been successfully parsed, or were not intended as ROS arguments. This function populates an array of indexes to these arguments in the original argv array. Since the first argument is always assumed to be a process name, the list will always contain the index 0.</p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>Yes </td></tr>
<tr>
<td>Thread-Safe </td><td>Yes </td></tr>
<tr>
<td>Uses Atomics </td><td>No </td></tr>
<tr>
<td>Lock-Free </td><td>Yes </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>An arguments structure that has been parsed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>A valid allocator. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_unparsed_indices</td><td>An allocated array of indices into the original argv array. This array must be deallocated by the caller using the given allocator. If there are no unparsed args then the output will be set to NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RCL_RET_OK</code> if everything goes correctly, or </dd>
<dd>
<code>RCL_RET_INVALID_ARGUMENT</code> if any function arguments are invalid, or </dd>
<dd>
<code>RCL_RET_BAD_ALLOC</code> if allocating memory failed, or </dd>
<dd>
<code>RCL_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a id="a147323ec6ccf940e3a2caf953ec7d3e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a147323ec6ccf940e3a2caf953ec7d3e7">&#9670;&nbsp;</a></span>rcl_get_zero_initialized_arguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> rcl_get_zero_initialized_arguments </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <a class="el" href="structrcl__node__t.html" title="Structure which encapsulates a ROS Node. ">rcl_node_t</a> struct with members initialized to <code>NULL</code>. </p>

</div>
</div>
<a id="aaa7f3b5096ff92e8a4877cca33387673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa7f3b5096ff92e8a4877cca33387673">&#9670;&nbsp;</a></span>rcl_remove_ros_arguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> rcl_remove_ros_arguments </td>
          <td>(</td>
          <td class="paramtype">char const *const&#160;</td>
          <td class="paramname"><em>argv</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nonros_argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>nonros_argv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a list of arguments with ROS-specific arguments removed. </p>
<p>Some arguments may not have been intended as ROS arguments. This function populates an array of the aruments in a new argv array. Since the first argument is always assumed to be a process name, the list will always contain the first value from the argument vector.</p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>Yes </td></tr>
<tr>
<td>Thread-Safe </td><td>Yes </td></tr>
<tr>
<td>Uses Atomics </td><td>No </td></tr>
<tr>
<td>Lock-Free </td><td>Yes </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">argv</td><td>The argument vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>An arguments structure that has been parsed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>A valid allocator. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nonros_argc</td><td>The count of arguments that aren't ROS-specific </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nonros_argv</td><td>An allocated array of arguments that aren't ROS-specific This array must be deallocated by the caller using the given allocator. If there are no non-ROS args, then the output will be set to NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RCL_RET_OK</code> if everything goes correctly, or </dd>
<dd>
<code>RCL_RET_INVALID_ARGUMENT</code> if any function arguments are invalid, or </dd>
<dd>
<code>RCL_RET_BAD_ALLOC</code> if allocating memory failed, or </dd>
<dd>
<code>RCL_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a id="aafe1f021f617406a45877c9d6dbc011d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafe1f021f617406a45877c9d6dbc011d">&#9670;&nbsp;</a></span>rcl_arguments_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> rcl_arguments_copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> *&#160;</td>
          <td class="paramname"><em>args_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy one arguments structure into another. </p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>Yes </td></tr>
<tr>
<td>Thread-Safe </td><td>No </td></tr>
<tr>
<td>Uses Atomics </td><td>No </td></tr>
<tr>
<td>Lock-Free </td><td>Yes </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>The structure to be copied. Its allocator is used to copy memory into the new structure. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">args_out</td><td>A zero-initialized arguments structure to be copied into. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RCL_RET_OK</code> if the structure was copied successfully, or </dd>
<dd>
<code>RCL_RET_INVALID_ARGUMENT</code> if any function arguments are invalid, or </dd>
<dd>
<code>RCL_RET_BAD_ALLOC</code> if allocating memory failed, or </dd>
<dd>
<code>RCL_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a id="a5287e61a227409a81add4eabbbcd4ff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5287e61a227409a81add4eabbbcd4ff1">&#9670;&nbsp;</a></span>rcl_arguments_fini()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> rcl_arguments_fini </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> *&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reclaim resources held inside <a class="el" href="structrcl__arguments__t.html" title="Hold output of parsing command line arguments. ">rcl_arguments_t</a> structure. </p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>No </td></tr>
<tr>
<td>Thread-Safe </td><td>Yes </td></tr>
<tr>
<td>Uses Atomics </td><td>No </td></tr>
<tr>
<td>Lock-Free </td><td>Yes </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>The structure to be deallocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RCL_RET_OK</code> if the memory was successfully freed, or </dd>
<dd>
<code>RCL_RET_INVALID_ARGUMENT</code> if any function arguments are invalid, or </dd>
<dd>
<code>RCL_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a id="a194f350512bf33c4c50ea8ef4b2042de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a194f350512bf33c4c50ea8ef4b2042de">&#9670;&nbsp;</a></span>_rcl_parse_remap_fully_qualified_namespace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> _rcl_parse_remap_fully_qualified_namespace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *&#160;</td>
          <td class="paramname"><em>lex_lookahead</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a fully qualified namespace for a namespace replacement rule (ex: <code>/foo/bar</code>) </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="arguments_8c.html#ac84f05e93246459c68d6b3486a804cdf" title="Start recursive descent parsing of a remap rule. ">_rcl_parse_remap_begin_remap_rule()</a> </dd></dl>

</div>
</div>
<a id="aa5f0628d1aef04967e99b7c388950e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5f0628d1aef04967e99b7c388950e6a">&#9670;&nbsp;</a></span>_rcl_parse_remap_replacement_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> _rcl_parse_remap_replacement_token </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *&#160;</td>
          <td class="paramname"><em>lex_lookahead</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse either a token or a backreference (ex: <code>bar</code>, or <code>\7</code>). </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="arguments_8c.html#ac84f05e93246459c68d6b3486a804cdf" title="Start recursive descent parsing of a remap rule. ">_rcl_parse_remap_begin_remap_rule()</a> </dd></dl>

</div>
</div>
<a id="a2c8621594577254059073bbfdb96247f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c8621594577254059073bbfdb96247f">&#9670;&nbsp;</a></span>_rcl_parse_remap_replacement_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> _rcl_parse_remap_replacement_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *&#160;</td>
          <td class="paramname"><em>lex_lookahead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rcl_remap_t *&#160;</td>
          <td class="paramname"><em>rule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the replacement side of a name remapping rule (ex: <code>bar/\1/foo</code>). </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="arguments_8c.html#ac84f05e93246459c68d6b3486a804cdf" title="Start recursive descent parsing of a remap rule. ">_rcl_parse_remap_begin_remap_rule()</a> </dd></dl>

</div>
</div>
<a id="a94e202fcbfe908d03573e38977deb3ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94e202fcbfe908d03573e38977deb3ec">&#9670;&nbsp;</a></span>_rcl_parse_remap_match_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> _rcl_parse_remap_match_token </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *&#160;</td>
          <td class="paramname"><em>lex_lookahead</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse either a token or a wildcard (ex: <code>foobar</code>, or <code>*</code>, or <code>**</code>). </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="arguments_8c.html#ac84f05e93246459c68d6b3486a804cdf" title="Start recursive descent parsing of a remap rule. ">_rcl_parse_remap_begin_remap_rule()</a> </dd></dl>

</div>
</div>
<a id="af32357cb16077b5effa7a1baafb1e53a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af32357cb16077b5effa7a1baafb1e53a">&#9670;&nbsp;</a></span>_rcl_parse_remap_match_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> _rcl_parse_remap_match_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *&#160;</td>
          <td class="paramname"><em>lex_lookahead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rcl_remap_t *&#160;</td>
          <td class="paramname"><em>rule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the match side of a name remapping rule (ex: <code>rostopic://foo</code>) </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="arguments_8c.html#ac84f05e93246459c68d6b3486a804cdf" title="Start recursive descent parsing of a remap rule. ">_rcl_parse_remap_begin_remap_rule()</a> </dd></dl>

</div>
</div>
<a id="a7cba41a4a9625dd75a6921785b9a97a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cba41a4a9625dd75a6921785b9a97a8">&#9670;&nbsp;</a></span>_rcl_parse_remap_name_remap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> _rcl_parse_remap_name_remap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *&#160;</td>
          <td class="paramname"><em>lex_lookahead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rcl_remap_t *&#160;</td>
          <td class="paramname"><em>rule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a name remapping rule (ex: <code>rostopic:///foo:=bar</code>). </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="arguments_8c.html#ac84f05e93246459c68d6b3486a804cdf" title="Start recursive descent parsing of a remap rule. ">_rcl_parse_remap_begin_remap_rule()</a> </dd></dl>

</div>
</div>
<a id="a64639d0b56f962914258b056c59520a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64639d0b56f962914258b056c59520a0">&#9670;&nbsp;</a></span>_rcl_parse_remap_namespace_replacement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> _rcl_parse_remap_namespace_replacement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *&#160;</td>
          <td class="paramname"><em>lex_lookahead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rcl_remap_t *&#160;</td>
          <td class="paramname"><em>rule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a namespace replacement rule (ex: <code>__ns:=/new/ns</code>). </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="arguments_8c.html#ac84f05e93246459c68d6b3486a804cdf" title="Start recursive descent parsing of a remap rule. ">_rcl_parse_remap_begin_remap_rule()</a> </dd></dl>

</div>
</div>
<a id="a6173a24bd0cee1b62b53454fdd493c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6173a24bd0cee1b62b53454fdd493c25">&#9670;&nbsp;</a></span>_rcl_parse_remap_nodename_replacement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> _rcl_parse_remap_nodename_replacement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *&#160;</td>
          <td class="paramname"><em>lex_lookahead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rcl_remap_t *&#160;</td>
          <td class="paramname"><em>rule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a nodename replacement rule (ex: <code>__node:=new_name</code>). </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="arguments_8c.html#ac84f05e93246459c68d6b3486a804cdf" title="Start recursive descent parsing of a remap rule. ">_rcl_parse_remap_begin_remap_rule()</a> </dd></dl>

</div>
</div>
<a id="aa19de406c16827c823c9a8ff7c663995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa19de406c16827c823c9a8ff7c663995">&#9670;&nbsp;</a></span>_rcl_parse_remap_nodename_prefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> _rcl_parse_remap_nodename_prefix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *&#160;</td>
          <td class="paramname"><em>lex_lookahead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rcl_remap_t *&#160;</td>
          <td class="paramname"><em>rule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a nodename prefix including trailing colon (ex: <code>node_name:</code>). </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="arguments_8c.html#ac84f05e93246459c68d6b3486a804cdf" title="Start recursive descent parsing of a remap rule. ">_rcl_parse_remap_begin_remap_rule()</a> </dd></dl>

</div>
</div>
<a id="ac84f05e93246459c68d6b3486a804cdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84f05e93246459c68d6b3486a804cdf">&#9670;&nbsp;</a></span>_rcl_parse_remap_begin_remap_rule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> _rcl_parse_remap_begin_remap_rule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *&#160;</td>
          <td class="paramname"><em>lex_lookahead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rcl_remap_t *&#160;</td>
          <td class="paramname"><em>rule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start recursive descent parsing of a remap rule. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lex_lookahead</td><td>a lookahead(2) buffer for the parser to use. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rule</td><td>input a zero intialized rule, output a fully initialized one. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RCL_RET_OK if a valid rule was parsed, or </dd>
<dd>
RCL_RET_INVALID_REMAP_RULE if the argument is not a valid rule, or </dd>
<dd>
RCL_RET_BAD_ALLOC if an allocation failed, or </dd>
<dd>
RLC_RET_ERROR if an unspecified error occurred. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
