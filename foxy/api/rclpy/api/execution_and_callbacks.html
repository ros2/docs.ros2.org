
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <title>Execution and Callbacks &#8212; rclpy 0.6.1 documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Utilities" href="utilities.html" />
    <link rel="prev" title="Context" href="context.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="execution-and-callbacks">
<h1>Execution and Callbacks<a class="headerlink" href="#execution-and-callbacks" title="Permalink to this headline">¶</a></h1>
<p>There are two components that control the execution of callbacks: <strong>executors</strong> and <strong>callback groups</strong>.</p>
<p>Executors are responsible for the actual execution of callbacks and should extend the <a class="reference internal" href="#rclpy.executors.Executor" title="rclpy.executors.Executor"><code class="xref py py-class docutils literal notranslate"><span class="pre">Executor</span></code></a> class.</p>
<p>Callback groups are used to enforce concurrency rules for callbacks and should extend the <a class="reference internal" href="#rclpy.callback_groups.CallbackGroup" title="rclpy.callback_groups.CallbackGroup"><code class="xref py py-class docutils literal notranslate"><span class="pre">CallbackGroup</span></code></a> class.</p>
<div class="section" id="module-rclpy.executors">
<span id="executors"></span><h2>Executors<a class="headerlink" href="#module-rclpy.executors" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="rclpy.executors.Executor">
<em class="property">class </em><code class="sig-prename descclassname">rclpy.executors.</code><code class="sig-name descname">Executor</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rclpy.executors.Executor" title="Permalink to this definition">¶</a></dt>
<dd><p>The base class for an executor.</p>
<p>An executor controls the threading model used to process callbacks. Callbacks are units of work
like subscription callbacks, timer callbacks, service calls, and received client responses. An
executor controls which threads callbacks get executed in.</p>
<p>A custom executor must define <a class="reference internal" href="#rclpy.executors.Executor.spin_once" title="rclpy.executors.Executor.spin_once"><code class="xref py py-meth docutils literal notranslate"><span class="pre">spin_once()</span></code></a>.
If the executor has any cleanup then it should also define <a class="reference internal" href="#rclpy.executors.Executor.shutdown" title="rclpy.executors.Executor.shutdown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">shutdown()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>context</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<a class="reference internal" href="context.html#rclpy.context.Context" title="rclpy.context.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a>]) – The context to be associated with, or <code class="docutils literal notranslate"><span class="pre">None</span></code> for the default global context.</p>
</dd>
</dl>
<dl class="py method">
<dt id="rclpy.executors.Executor.add_node">
<code class="sig-name descname">add_node</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">node</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rclpy.executors.Executor.add_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a node whose callbacks should be managed by this executor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node</strong> (<a class="reference internal" href="node.html#rclpy.node.Node" title="rclpy.node.Node"><em>Node</em></a>) – The node to add to the executor.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if the node was added, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="rclpy.executors.Executor.can_execute">
<code class="sig-name descname">can_execute</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">entity</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rclpy.executors.Executor.can_execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if a callback for an entity can be executed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>entity</strong> (<em>~WaitableEntityType</em>) – Subscription, Timer, Guard condition, etc</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if the entity callback can be executed, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="rclpy.executors.Executor.context">
<em class="property">property </em><code class="sig-name descname">context</code><a class="headerlink" href="#rclpy.executors.Executor.context" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the context associated with the executor.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="context.html#rclpy.context.Context" title="rclpy.context.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="rclpy.executors.Executor.create_task">
<code class="sig-name descname">create_task</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">callback</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rclpy.executors.Executor.create_task" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a callback or coroutine to be executed during <a class="reference internal" href="#rclpy.executors.Executor.spin" title="rclpy.executors.Executor.spin"><code class="xref py py-meth docutils literal notranslate"><span class="pre">spin()</span></code></a> and return a Future.</p>
<p>Arguments to this function are passed to the callback.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>callback</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Coroutine</span></code>]) – A callback to be run in the executor.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="rclpy.executors.Executor.get_nodes">
<code class="sig-name descname">get_nodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rclpy.executors.Executor.get_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nodes that have been added to this executor.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ForwardRef</span></code>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="rclpy.executors.Executor.remove_node">
<code class="sig-name descname">remove_node</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">node</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rclpy.executors.Executor.remove_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop managing this node’s callbacks.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node</strong> (<a class="reference internal" href="node.html#rclpy.node.Node" title="rclpy.node.Node"><em>Node</em></a>) – The node to remove from the executor.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="rclpy.executors.Executor.shutdown">
<code class="sig-name descname">shutdown</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">timeout_sec</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rclpy.executors.Executor.shutdown" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop executing callbacks and wait for their completion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>timeout_sec</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – Seconds to wait. Block forever if <code class="docutils literal notranslate"><span class="pre">None</span></code> or negative.
Don’t wait if 0.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if all outstanding callbacks finished executing, or <code class="docutils literal notranslate"><span class="pre">False</span></code> if the
timeot expires before all outstanding work is done.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="rclpy.executors.Executor.spin">
<code class="sig-name descname">spin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rclpy.executors.Executor.spin" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute callbacks until shutdown.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="rclpy.executors.Executor.spin_once">
<code class="sig-name descname">spin_once</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">timeout_sec</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rclpy.executors.Executor.spin_once" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for and execute a single callback.</p>
<p>A custom executor should use <a class="reference internal" href="#rclpy.executors.Executor.wait_for_ready_callbacks" title="rclpy.executors.Executor.wait_for_ready_callbacks"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait_for_ready_callbacks()</span></code></a> to get work.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>timeout_sec</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – Seconds to wait. Block forever if <code class="docutils literal notranslate"><span class="pre">None</span></code> or negative.
Don’t wait if 0.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="rclpy.executors.Executor.spin_until_future_complete">
<code class="sig-name descname">spin_until_future_complete</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">future</span></em>, <em class="sig-param"><span class="n">timeout_sec</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rclpy.executors.Executor.spin_until_future_complete" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute callbacks until a given future is done or a timeout occurs.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="rclpy.executors.Executor.wait_for_ready_callbacks">
<code class="sig-name descname">wait_for_ready_callbacks</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rclpy.executors.Executor.wait_for_ready_callbacks" title="Permalink to this definition">¶</a></dt>
<dd><p>Return callbacks that are ready to be executed.</p>
<p>The arguments to this function are passed to the internal method
<a class="reference internal" href="#rclpy.executors.Executor._wait_for_ready_callbacks" title="rclpy.executors.Executor._wait_for_ready_callbacks"><code class="xref py py-meth docutils literal notranslate"><span class="pre">_wait_for_ready_callbacks()</span></code></a> to get a generator for ready callbacks:</p>
<dl class="py method">
<dt id="rclpy.executors.Executor._wait_for_ready_callbacks">
<code class="sig-name descname">_wait_for_ready_callbacks</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">timeout_sec</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">nodes</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rclpy.executors.Executor._wait_for_ready_callbacks" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield callbacks that are ready to be executed.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><a class="reference internal" href="#rclpy.executors.TimeoutException" title="rclpy.executors.TimeoutException"><strong>TimeoutException</strong></a> – on timeout.</p></li>
<li><p><a class="reference internal" href="#rclpy.executors.ShutdownException" title="rclpy.executors.ShutdownException"><strong>ShutdownException</strong></a> – on if executor was shut down.</p></li>
</ul>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>timeout_sec</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Seconds to wait. Block forever if <code class="docutils literal notranslate"><span class="pre">None</span></code> or negative.
Don’t wait if 0.</p></li>
<li><p><strong>nodes</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ForwardRef</span></code>]) – A list of nodes to wait on. Wait on all nodes if <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
</ul>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code>[<code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code>, ~WaitableEntityType, <code class="xref py py-class docutils literal notranslate"><span class="pre">ForwardRef</span></code>], <code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">None</span></code>]</p>
</dd>
</dl>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code>, ~WaitableEntityType, <code class="xref py py-class docutils literal notranslate"><span class="pre">ForwardRef</span></code>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="rclpy.executors.Executor.wake">
<code class="sig-name descname">wake</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rclpy.executors.Executor.wake" title="Permalink to this definition">¶</a></dt>
<dd><p>Wake the executor because something changed.</p>
<p>This is used to tell the executor when entities are created or destroyed.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py exception">
<dt id="rclpy.executors.ExternalShutdownException">
<em class="property">exception </em><code class="sig-prename descclassname">rclpy.executors.</code><code class="sig-name descname">ExternalShutdownException</code><a class="headerlink" href="#rclpy.executors.ExternalShutdownException" title="Permalink to this definition">¶</a></dt>
<dd><p>Context has been shutdown.</p>
</dd></dl>

<dl class="py class">
<dt id="rclpy.executors.MultiThreadedExecutor">
<em class="property">class </em><code class="sig-prename descclassname">rclpy.executors.</code><code class="sig-name descname">MultiThreadedExecutor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">num_threads</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rclpy.executors.MultiThreadedExecutor" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs callbacks in a pool of threads.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_threads</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]) – number of worker threads in the pool. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, the number of threads
will use <code class="xref py py-func docutils literal notranslate"><span class="pre">multiprocessing.cpu_count()</span></code>. If that’s not implemented the number of threads
defaults to 1.</p></li>
<li><p><strong>context</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<a class="reference internal" href="context.html#rclpy.context.Context" title="rclpy.context.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a>]) – The context associated with the executor.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="rclpy.executors.MultiThreadedExecutor.spin_once">
<code class="sig-name descname">spin_once</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">timeout_sec</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rclpy.executors.MultiThreadedExecutor.spin_once" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for and execute a single callback.</p>
<p>A custom executor should use <code class="xref py py-meth docutils literal notranslate"><span class="pre">wait_for_ready_callbacks()</span></code> to get work.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>timeout_sec</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – Seconds to wait. Block forever if <code class="docutils literal notranslate"><span class="pre">None</span></code> or negative.
Don’t wait if 0.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py exception">
<dt id="rclpy.executors.ShutdownException">
<em class="property">exception </em><code class="sig-prename descclassname">rclpy.executors.</code><code class="sig-name descname">ShutdownException</code><a class="headerlink" href="#rclpy.executors.ShutdownException" title="Permalink to this definition">¶</a></dt>
<dd><p>Signal that executor was shut down.</p>
</dd></dl>

<dl class="py class">
<dt id="rclpy.executors.SingleThreadedExecutor">
<em class="property">class </em><code class="sig-prename descclassname">rclpy.executors.</code><code class="sig-name descname">SingleThreadedExecutor</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rclpy.executors.SingleThreadedExecutor" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs callbacks in the thread that calls <a class="reference internal" href="#rclpy.executors.Executor.spin" title="rclpy.executors.Executor.spin"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Executor.spin()</span></code></a>.</p>
<dl class="py method">
<dt id="rclpy.executors.SingleThreadedExecutor.spin_once">
<code class="sig-name descname">spin_once</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">timeout_sec</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rclpy.executors.SingleThreadedExecutor.spin_once" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for and execute a single callback.</p>
<p>A custom executor should use <code class="xref py py-meth docutils literal notranslate"><span class="pre">wait_for_ready_callbacks()</span></code> to get work.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>timeout_sec</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – Seconds to wait. Block forever if <code class="docutils literal notranslate"><span class="pre">None</span></code> or negative.
Don’t wait if 0.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py exception">
<dt id="rclpy.executors.TimeoutException">
<em class="property">exception </em><code class="sig-prename descclassname">rclpy.executors.</code><code class="sig-name descname">TimeoutException</code><a class="headerlink" href="#rclpy.executors.TimeoutException" title="Permalink to this definition">¶</a></dt>
<dd><p>Signal that a timeout occurred.</p>
</dd></dl>

<dl class="py function">
<dt id="rclpy.executors.await_or_execute">
<em class="property">async </em><code class="sig-prename descclassname">rclpy.executors.</code><code class="sig-name descname">await_or_execute</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">callback</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rclpy.executors.await_or_execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Await a callback if it is a coroutine, else execute it.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-rclpy.callback_groups">
<span id="callback-groups"></span><h2>Callback Groups<a class="headerlink" href="#module-rclpy.callback_groups" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="rclpy.callback_groups.CallbackGroup">
<em class="property">class </em><code class="sig-prename descclassname">rclpy.callback_groups.</code><code class="sig-name descname">CallbackGroup</code><a class="headerlink" href="#rclpy.callback_groups.CallbackGroup" title="Permalink to this definition">¶</a></dt>
<dd><p>The base class for a callback group.</p>
<p>A callback group controls when callbacks are allowed to be executed.</p>
<p>This class should not be instantiated.
Instead, classes should extend it and implement <a class="reference internal" href="#rclpy.callback_groups.CallbackGroup.can_execute" title="rclpy.callback_groups.CallbackGroup.can_execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">can_execute()</span></code></a>,
<a class="reference internal" href="#rclpy.callback_groups.CallbackGroup.beginning_execution" title="rclpy.callback_groups.CallbackGroup.beginning_execution"><code class="xref py py-meth docutils literal notranslate"><span class="pre">beginning_execution()</span></code></a>, and <a class="reference internal" href="#rclpy.callback_groups.CallbackGroup.ending_execution" title="rclpy.callback_groups.CallbackGroup.ending_execution"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ending_execution()</span></code></a>.</p>
<dl class="py method">
<dt id="rclpy.callback_groups.CallbackGroup.add_entity">
<code class="sig-name descname">add_entity</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">entity</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rclpy.callback_groups.CallbackGroup.add_entity" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an entity to the callback group.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>entity</strong> – a subscription, timer, client, service, or waitable instance.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="rclpy.callback_groups.CallbackGroup.beginning_execution">
<code class="sig-name descname">beginning_execution</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">entity</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rclpy.callback_groups.CallbackGroup.beginning_execution" title="Permalink to this definition">¶</a></dt>
<dd><p>Get permission for the callback from the group to begin executing an entity.</p>
<p>If this returns <code class="docutils literal notranslate"><span class="pre">True</span></code> then <a class="reference internal" href="#rclpy.callback_groups.CallbackGroup.ending_execution" title="rclpy.callback_groups.CallbackGroup.ending_execution"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CallbackGroup.ending_execution()</span></code></a> must be called after
the callback has been executed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>entity</strong> – a subscription, timer, client, service, or waitable instance.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if the callback can be executed, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="rclpy.callback_groups.CallbackGroup.can_execute">
<code class="sig-name descname">can_execute</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">entity</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rclpy.callback_groups.CallbackGroup.can_execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if an entity can be executed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>entity</strong> – a subscription, timer, client, service, or waitable instance.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if the entity can be executed, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="rclpy.callback_groups.CallbackGroup.ending_execution">
<code class="sig-name descname">ending_execution</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">entity</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rclpy.callback_groups.CallbackGroup.ending_execution" title="Permalink to this definition">¶</a></dt>
<dd><p>Notify group that a callback has finished executing.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>entity</strong> – a subscription, timer, client, service, or waitable instance.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="rclpy.callback_groups.CallbackGroup.has_entity">
<code class="sig-name descname">has_entity</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">entity</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rclpy.callback_groups.CallbackGroup.has_entity" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if an entity has been added to this group.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>entity</strong> – a subscription, timer, client, service, or waitable instance.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="rclpy.callback_groups.MutuallyExclusiveCallbackGroup">
<em class="property">class </em><code class="sig-prename descclassname">rclpy.callback_groups.</code><code class="sig-name descname">MutuallyExclusiveCallbackGroup</code><a class="headerlink" href="#rclpy.callback_groups.MutuallyExclusiveCallbackGroup" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow only one callback to be executing at a time.</p>
<dl class="py method">
<dt id="rclpy.callback_groups.MutuallyExclusiveCallbackGroup.beginning_execution">
<code class="sig-name descname">beginning_execution</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">entity</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rclpy.callback_groups.MutuallyExclusiveCallbackGroup.beginning_execution" title="Permalink to this definition">¶</a></dt>
<dd><p>Get permission for the callback from the group to begin executing an entity.</p>
<p>If this returns <code class="docutils literal notranslate"><span class="pre">True</span></code> then <a class="reference internal" href="#rclpy.callback_groups.CallbackGroup.ending_execution" title="rclpy.callback_groups.CallbackGroup.ending_execution"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CallbackGroup.ending_execution()</span></code></a> must be called after
the callback has been executed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>entity</strong> – a subscription, timer, client, service, or waitable instance.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if the callback can be executed, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="rclpy.callback_groups.MutuallyExclusiveCallbackGroup.can_execute">
<code class="sig-name descname">can_execute</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">entity</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rclpy.callback_groups.MutuallyExclusiveCallbackGroup.can_execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if an entity can be executed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>entity</strong> – a subscription, timer, client, service, or waitable instance.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if the entity can be executed, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="rclpy.callback_groups.MutuallyExclusiveCallbackGroup.ending_execution">
<code class="sig-name descname">ending_execution</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">entity</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rclpy.callback_groups.MutuallyExclusiveCallbackGroup.ending_execution" title="Permalink to this definition">¶</a></dt>
<dd><p>Notify group that a callback has finished executing.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>entity</strong> – a subscription, timer, client, service, or waitable instance.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="rclpy.callback_groups.ReentrantCallbackGroup">
<em class="property">class </em><code class="sig-prename descclassname">rclpy.callback_groups.</code><code class="sig-name descname">ReentrantCallbackGroup</code><a class="headerlink" href="#rclpy.callback_groups.ReentrantCallbackGroup" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow callbacks to be executed in parallel without restriction.</p>
<dl class="py method">
<dt id="rclpy.callback_groups.ReentrantCallbackGroup.beginning_execution">
<code class="sig-name descname">beginning_execution</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">entity</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rclpy.callback_groups.ReentrantCallbackGroup.beginning_execution" title="Permalink to this definition">¶</a></dt>
<dd><p>Get permission for the callback from the group to begin executing an entity.</p>
<p>If this returns <code class="docutils literal notranslate"><span class="pre">True</span></code> then <a class="reference internal" href="#rclpy.callback_groups.CallbackGroup.ending_execution" title="rclpy.callback_groups.CallbackGroup.ending_execution"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CallbackGroup.ending_execution()</span></code></a> must be called after
the callback has been executed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>entity</strong> – a subscription, timer, client, service, or waitable instance.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if the callback can be executed, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="rclpy.callback_groups.ReentrantCallbackGroup.can_execute">
<code class="sig-name descname">can_execute</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">entity</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rclpy.callback_groups.ReentrantCallbackGroup.can_execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if an entity can be executed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>entity</strong> – a subscription, timer, client, service, or waitable instance.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if the entity can be executed, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="rclpy.callback_groups.ReentrantCallbackGroup.ending_execution">
<code class="sig-name descname">ending_execution</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">entity</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rclpy.callback_groups.ReentrantCallbackGroup.ending_execution" title="Permalink to this definition">¶</a></dt>
<dd><p>Notify group that a callback has finished executing.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>entity</strong> – a subscription, timer, client, service, or waitable instance.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">rclpy</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../about.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples.html">Examples</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../api.html">API</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="init_shutdown.html">Initialization, Shutdown, and Spinning</a></li>
<li class="toctree-l2"><a class="reference internal" href="node.html">Node</a></li>
<li class="toctree-l2"><a class="reference internal" href="topics.html">Topics</a></li>
<li class="toctree-l2"><a class="reference internal" href="services.html">Services</a></li>
<li class="toctree-l2"><a class="reference internal" href="actions.html">Actions</a></li>
<li class="toctree-l2"><a class="reference internal" href="timers.html">Timer</a></li>
<li class="toctree-l2"><a class="reference internal" href="parameters.html">Parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="logging.html">Logging</a></li>
<li class="toctree-l2"><a class="reference internal" href="context.html">Context</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Execution and Callbacks</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-rclpy.executors">Executors</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-rclpy.callback_groups">Callback Groups</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="utilities.html">Utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="qos.html">Quality of Service</a></li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="../api.html">API</a><ul>
      <li>Previous: <a href="context.html" title="previous chapter">Context</a></li>
      <li>Next: <a href="utilities.html" title="next chapter">Utilities</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2016-2019, Open Source Robotics Foundation, Inc..
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.0.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/api/execution_and_callbacks.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>