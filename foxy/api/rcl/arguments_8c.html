<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rcl: src/rcl/arguments.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rcl
   &#160;<span id="projectnumber">master</span>
   </div>
   <div id="projectbrief">C API providing common ROS client library functionality.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_8d2ff9a475ce94ede13c8bc9f5da84d1.html">rcl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">arguments.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="arguments_8h_source.html">rcl/arguments.h</a>&quot;</code><br />
<code>#include &lt;assert.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &quot;./arguments_impl.h&quot;</code><br />
<code>#include &quot;./remap_impl.h&quot;</code><br />
<code>#include &quot;<a class="el" href="error__handling_8h_source.html">rcl/error_handling.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lexer__lookahead_8h_source.html">rcl/lexer_lookahead.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="validate__topic__name_8h_source.html">rcl/validate_topic_name.h</a>&quot;</code><br />
<code>#include &quot;rcl_yaml_param_parser/parser.h&quot;</code><br />
<code>#include &quot;<a class="elRef" href="http://docs.ros2.org/foxy/api/rcutils/allocator_8h.html">rcutils/allocator.h</a>&quot;</code><br />
<code>#include &quot;<a class="elRef" href="http://docs.ros2.org/foxy/api/rcutils/error__handling_8h.html">rcutils/error_handling.h</a>&quot;</code><br />
<code>#include &quot;<a class="elRef" href="http://docs.ros2.org/foxy/api/rcutils/format__string_8h.html">rcutils/format_string.h</a>&quot;</code><br />
<code>#include &quot;<a class="elRef" href="http://docs.ros2.org/foxy/api/rcutils/logging_8h.html">rcutils/logging.h</a>&quot;</code><br />
<code>#include &quot;<a class="elRef" href="http://docs.ros2.org/foxy/api/rcutils/logging__macros_8h.html">rcutils/logging_macros.h</a>&quot;</code><br />
<code>#include &quot;<a class="elRef" href="http://docs.ros2.org/foxy/api/rcutils/strdup_8h.html">rcutils/strdup.h</a>&quot;</code><br />
<code>#include &quot;<a class="elRef" href="http://docs.ros2.org/foxy/api/rmw/validate__namespace_8h.html">rmw/validate_namespace.h</a>&quot;</code><br />
<code>#include &quot;<a class="elRef" href="http://docs.ros2.org/foxy/api/rmw/validate__node__name_8h.html">rmw/validate_node_name.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for arguments.c:</div>
<div class="dyncontent">
<div class="center"><img src="arguments_8c__incl.png" border="0" usemap="#src_2rcl_2arguments_8c" alt=""/></div>
<map name="src_2rcl_2arguments_8c" id="src_2rcl_2arguments_8c">
<area shape="rect" title=" " alt="" coords="2442,5,2588,32"/>
<area shape="rect" href="arguments_8h.html" title=" " alt="" coords="1670,415,1794,442"/>
<area shape="rect" href="http://docs.ros2.org/foxy/api/rcutils/allocator_8h.html.html" title=" " alt="" coords="1566,960,1701,987"/>
<area shape="rect" title=" " alt="" coords="1870,497,2045,539"/>
<area shape="rect" title=" " alt="" coords="2552,95,2627,121"/>
<area shape="rect" title=" " alt="" coords="2652,95,2722,121"/>
<area shape="rect" title=" " alt="" coords="2746,95,2894,121"/>
<area shape="rect" title=" " alt="" coords="2918,95,3042,121"/>
<area shape="rect" title=" " alt="" coords="3067,80,3224,136"/>
<area shape="rect" title=" " alt="" coords="3249,95,3360,121"/>
<area shape="rect" title=" " alt="" coords="3384,95,3486,121"/>
<area shape="rect" title=" " alt="" coords="3511,95,3607,121"/>
<area shape="rect" title=" " alt="" coords="3631,95,3722,121"/>
<area shape="rect" title=" " alt="" coords="3746,95,3908,121"/>
<area shape="rect" title=" " alt="" coords="3932,95,4052,121"/>
<area shape="rect" href="error__handling_8h.html" title=" " alt="" coords="2076,333,2224,360"/>
<area shape="rect" href="http://docs.ros2.org/foxy/api/rcutils/error__handling_8h.html.html" title=" " alt="" coords="1921,811,2093,837"/>
<area shape="rect" href="lexer__lookahead_8h.html" title=" " alt="" coords="902,333,1064,360"/>
<area shape="rect" href="validate__topic__name_8h.html" title=" " alt="" coords="1102,408,1237,449"/>
<area shape="rect" title=" " alt="" coords="4077,87,4252,129"/>
<area shape="rect" href="http://docs.ros2.org/foxy/api/rcutils/format__string_8h.html.html" title=" " alt="" coords="2117,811,2284,837"/>
<area shape="rect" href="http://docs.ros2.org/foxy/api/rcutils/logging_8h.html.html" title=" " alt="" coords="1924,259,2050,285"/>
<area shape="rect" href="http://docs.ros2.org/foxy/api/rcutils/logging__macros_8h.html.html" title=" " alt="" coords="1588,95,1770,121"/>
<area shape="rect" href="http://docs.ros2.org/foxy/api/rcutils/strdup_8h.html.html" title=" " alt="" coords="2308,811,2426,837"/>
<area shape="rect" href="http://docs.ros2.org/foxy/api/rmw/validate__namespace_8h.html.html" title=" " alt="" coords="323,415,526,442"/>
<area shape="rect" href="http://docs.ros2.org/foxy/api/rmw/validate__node__name_8h.html.html" title=" " alt="" coords="46,415,248,442"/>
<area shape="rect" href="allocator_8h.html" title=" " alt="" coords="1529,885,1640,912"/>
<area shape="rect" href="macros_8h.html" title=" " alt="" coords="552,1042,678,1069"/>
<area shape="rect" href="visibility__control_8h.html" title=" " alt="" coords="1572,1035,1695,1076"/>
<area shape="rect" href="types_8h.html" title=" " alt="" coords="1059,505,1150,531"/>
<area shape="rect" href="http://docs.ros2.org/foxy/api/rmw/types_8h.html.html" title=" " alt="" coords="1053,587,1156,613"/>
<area shape="rect" href="init_8h.html" title=" " alt="" coords="998,661,1086,688"/>
<area shape="rect" href="init__options_8h.html" title=" " alt="" coords="993,811,1136,837"/>
<area shape="rect" href="context_8h.html" title=" " alt="" coords="904,736,1006,763"/>
<area shape="rect" href="http://docs.ros2.org/foxy/api/rmw/init_8h.html.html" title=" " alt="" coords="844,885,932,912"/>
<area shape="rect" title=" " alt="" coords="780,811,866,837"/>
<area shape="rect" title=" " alt="" coords="475,505,550,531"/>
<area shape="rect" href="lexer_8h.html" title=" " alt="" coords="940,415,1026,442"/>
<area shape="rect" href="time_8h.html" title=" " alt="" coords="1524,333,1632,360"/>
<area shape="rect" href="http://docs.ros2.org/foxy/api/rcutils/time_8h.html.html" title=" " alt="" coords="1476,415,1584,442"/>
<area shape="rect" href="logging_8h.html" title=" " alt="" coords="1642,184,1769,211"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ae66ac20275619eb092ea60de69422a53"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#ae66ac20275619eb092ea60de69422a53">RCL_ENABLE_FLAG_PREFIX</a>&#160;&#160;&#160;&quot;--enable-&quot;</td></tr>
<tr class="separator:ae66ac20275619eb092ea60de69422a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27234043cdfcb678d8372608cbf318c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#ac27234043cdfcb678d8372608cbf318c">RCL_DISABLE_FLAG_PREFIX</a>&#160;&#160;&#160;&quot;--disable-&quot;</td></tr>
<tr class="separator:ac27234043cdfcb678d8372608cbf318c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2ada6c2d3316bfb19fe47a801d67f241"><td class="memItemLeft" align="right" valign="top"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#a2ada6c2d3316bfb19fe47a801d67f241">_rcl_parse_remap_rule</a> (const char *arg, <a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a> allocator, <a class="el" href="structrcl__remap__t.html">rcl_remap_t</a> *output_rule)</td></tr>
<tr class="memdesc:a2ada6c2d3316bfb19fe47a801d67f241"><td class="mdescLeft">&#160;</td><td class="mdescRight">// Internal Doxygen documentation  <a href="arguments_8c.html#a2ada6c2d3316bfb19fe47a801d67f241">More...</a><br /></td></tr>
<tr class="separator:a2ada6c2d3316bfb19fe47a801d67f241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7374c744686cf1284c33f05e8d4c2e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#af7374c744686cf1284c33f05e8d4c2e0">_rcl_parse_param_rule</a> (const char *arg, rcl_params_t *params)</td></tr>
<tr class="memdesc:af7374c744686cf1284c33f05e8d4c2e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an argument that may or may not be a param rule.  <a href="arguments_8c.html#af7374c744686cf1284c33f05e8d4c2e0">More...</a><br /></td></tr>
<tr class="separator:af7374c744686cf1284c33f05e8d4c2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7a9bc87595ebc889aa78fd83fe61d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#a8d7a9bc87595ebc889aa78fd83fe61d5">rcl_arguments_get_param_files</a> (const <a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> *arguments, <a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a> allocator, char ***parameter_files)</td></tr>
<tr class="memdesc:a8d7a9bc87595ebc889aa78fd83fe61d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of yaml parameter file paths specified on the command line.  <a href="arguments_8c.html#a8d7a9bc87595ebc889aa78fd83fe61d5">More...</a><br /></td></tr>
<tr class="separator:a8d7a9bc87595ebc889aa78fd83fe61d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68964d428b8c7e280cf82461c6ebe78"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#ad68964d428b8c7e280cf82461c6ebe78">rcl_arguments_get_param_files_count</a> (const <a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> *args)</td></tr>
<tr class="memdesc:ad68964d428b8c7e280cf82461c6ebe78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of parameter yaml files given in the arguments.  <a href="arguments_8c.html#ad68964d428b8c7e280cf82461c6ebe78">More...</a><br /></td></tr>
<tr class="separator:ad68964d428b8c7e280cf82461c6ebe78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4804387f33af2ef348866083a74f960c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#a4804387f33af2ef348866083a74f960c">rcl_arguments_get_param_overrides</a> (const <a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> *arguments, rcl_params_t **parameter_overrides)</td></tr>
<tr class="memdesc:a4804387f33af2ef348866083a74f960c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return all parameter overrides parsed from the command line.  <a href="arguments_8c.html#a4804387f33af2ef348866083a74f960c">More...</a><br /></td></tr>
<tr class="separator:a4804387f33af2ef348866083a74f960c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327dcafa20045671bb385a41f235aeae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#a327dcafa20045671bb385a41f235aeae">_rcl_parse_log_level</a> (const char *arg, <a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a> allocator, int *log_level)</td></tr>
<tr class="memdesc:a327dcafa20045671bb385a41f235aeae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an argument that may or may not be a log level rule.  <a href="arguments_8c.html#a327dcafa20045671bb385a41f235aeae">More...</a><br /></td></tr>
<tr class="separator:a327dcafa20045671bb385a41f235aeae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64bc48ad928b30bcf9a648377e5389b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#ab64bc48ad928b30bcf9a648377e5389b">_rcl_parse_external_log_config_file</a> (const char *arg, <a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a> allocator, char **log_config_file)</td></tr>
<tr class="memdesc:ab64bc48ad928b30bcf9a648377e5389b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an argument that may or may not be a log configuration file.  <a href="arguments_8c.html#ab64bc48ad928b30bcf9a648377e5389b">More...</a><br /></td></tr>
<tr class="separator:ab64bc48ad928b30bcf9a648377e5389b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2174d3766a25bc9ce0d336be728151a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#a2174d3766a25bc9ce0d336be728151a8">_rcl_parse_param_file</a> (const char *arg, <a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a> allocator, rcl_params_t *params, char **param_file)</td></tr>
<tr class="memdesc:a2174d3766a25bc9ce0d336be728151a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an argument that may or may not be a parameter file.  <a href="arguments_8c.html#a2174d3766a25bc9ce0d336be728151a8">More...</a><br /></td></tr>
<tr class="separator:a2174d3766a25bc9ce0d336be728151a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02bd169f1fbd304e24bbb1b565fc98d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#a02bd169f1fbd304e24bbb1b565fc98d7">_rcl_parse_enclave</a> (const char *arg, <a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a> allocator, char **enclave)</td></tr>
<tr class="memdesc:a02bd169f1fbd304e24bbb1b565fc98d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an enclave argument.  <a href="arguments_8c.html#a02bd169f1fbd304e24bbb1b565fc98d7">More...</a><br /></td></tr>
<tr class="separator:a02bd169f1fbd304e24bbb1b565fc98d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab936bf1669344c410cc5de49e7ff3ba4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#ab936bf1669344c410cc5de49e7ff3ba4">_rcl_parse_disabling_flag</a> (const char *arg, const char *key, bool *value)</td></tr>
<tr class="memdesc:ab936bf1669344c410cc5de49e7ff3ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a bool argument that may or may not be for the provided key rule.  <a href="arguments_8c.html#ab936bf1669344c410cc5de49e7ff3ba4">More...</a><br /></td></tr>
<tr class="separator:ab936bf1669344c410cc5de49e7ff3ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299fe5fc1a0770c65d1ff6d314d5a80c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#a299fe5fc1a0770c65d1ff6d314d5a80c">_rcl_allocate_initialized_arguments_impl</a> (<a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> *args, <a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a> *allocator)</td></tr>
<tr class="memdesc:a299fe5fc1a0770c65d1ff6d314d5a80c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and zero initialize arguments impl and.  <a href="arguments_8c.html#a299fe5fc1a0770c65d1ff6d314d5a80c">More...</a><br /></td></tr>
<tr class="separator:a299fe5fc1a0770c65d1ff6d314d5a80c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac115fc88cd80fb7832d4df9f8c634f72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#ac115fc88cd80fb7832d4df9f8c634f72">rcl_parse_arguments</a> (int argc, const char *const argv[], <a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a> allocator, <a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> *args_output)</td></tr>
<tr class="memdesc:ac115fc88cd80fb7832d4df9f8c634f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse command line arguments into a structure usable by code.  <a href="arguments_8c.html#ac115fc88cd80fb7832d4df9f8c634f72">More...</a><br /></td></tr>
<tr class="separator:ac115fc88cd80fb7832d4df9f8c634f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3651d7428c5c2789d27872155023ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#acc3651d7428c5c2789d27872155023ce">rcl_arguments_get_count_unparsed</a> (const <a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> *args)</td></tr>
<tr class="memdesc:acc3651d7428c5c2789d27872155023ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of arguments that were not ROS specific arguments.  <a href="arguments_8c.html#acc3651d7428c5c2789d27872155023ce">More...</a><br /></td></tr>
<tr class="separator:acc3651d7428c5c2789d27872155023ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6722d8fc966d9cc3ddcb60fe32c44a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#ade6722d8fc966d9cc3ddcb60fe32c44a">rcl_arguments_get_unparsed</a> (const <a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> *args, <a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a> allocator, int **output_unparsed_indices)</td></tr>
<tr class="memdesc:ade6722d8fc966d9cc3ddcb60fe32c44a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of indices to non ROS specific arguments.  <a href="arguments_8c.html#ade6722d8fc966d9cc3ddcb60fe32c44a">More...</a><br /></td></tr>
<tr class="separator:ade6722d8fc966d9cc3ddcb60fe32c44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2cbe6126e7cdd24f1c86448370f1cea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#aa2cbe6126e7cdd24f1c86448370f1cea">rcl_arguments_get_count_unparsed_ros</a> (const <a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> *args)</td></tr>
<tr class="memdesc:aa2cbe6126e7cdd24f1c86448370f1cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of ROS specific arguments that were not successfully parsed.  <a href="arguments_8c.html#aa2cbe6126e7cdd24f1c86448370f1cea">More...</a><br /></td></tr>
<tr class="separator:aa2cbe6126e7cdd24f1c86448370f1cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25869df92ec7b344c1eb112b00d66be6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#a25869df92ec7b344c1eb112b00d66be6">rcl_arguments_get_unparsed_ros</a> (const <a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> *args, <a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a> allocator, int **output_unparsed_ros_indices)</td></tr>
<tr class="memdesc:a25869df92ec7b344c1eb112b00d66be6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of indices to unknown ROS specific arguments that were left unparsed.  <a href="arguments_8c.html#a25869df92ec7b344c1eb112b00d66be6">More...</a><br /></td></tr>
<tr class="separator:a25869df92ec7b344c1eb112b00d66be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147323ec6ccf940e3a2caf953ec7d3e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#a147323ec6ccf940e3a2caf953ec7d3e7">rcl_get_zero_initialized_arguments</a> (void)</td></tr>
<tr class="memdesc:a147323ec6ccf940e3a2caf953ec7d3e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="structrcl__arguments__t.html" title="Hold output of parsing command line arguments.">rcl_arguments_t</a> struct with members initialized to <code>NULL</code>.  <a href="arguments_8c.html#a147323ec6ccf940e3a2caf953ec7d3e7">More...</a><br /></td></tr>
<tr class="separator:a147323ec6ccf940e3a2caf953ec7d3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7f3b5096ff92e8a4877cca33387673"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#aaa7f3b5096ff92e8a4877cca33387673">rcl_remove_ros_arguments</a> (char const *const argv[], const <a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> *args, <a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a> allocator, int *nonros_argc, const char **nonros_argv[])</td></tr>
<tr class="memdesc:aaa7f3b5096ff92e8a4877cca33387673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of arguments with ROS-specific arguments removed.  <a href="arguments_8c.html#aaa7f3b5096ff92e8a4877cca33387673">More...</a><br /></td></tr>
<tr class="separator:aaa7f3b5096ff92e8a4877cca33387673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe1f021f617406a45877c9d6dbc011d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#aafe1f021f617406a45877c9d6dbc011d">rcl_arguments_copy</a> (const <a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> *args, <a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> *args_out)</td></tr>
<tr class="memdesc:aafe1f021f617406a45877c9d6dbc011d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy one arguments structure into another.  <a href="arguments_8c.html#aafe1f021f617406a45877c9d6dbc011d">More...</a><br /></td></tr>
<tr class="separator:aafe1f021f617406a45877c9d6dbc011d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5287e61a227409a81add4eabbbcd4ff1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#a5287e61a227409a81add4eabbbcd4ff1">rcl_arguments_fini</a> (<a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> *args)</td></tr>
<tr class="memdesc:a5287e61a227409a81add4eabbbcd4ff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reclaim resources held inside <a class="el" href="structrcl__arguments__t.html" title="Hold output of parsing command line arguments.">rcl_arguments_t</a> structure.  <a href="arguments_8c.html#a5287e61a227409a81add4eabbbcd4ff1">More...</a><br /></td></tr>
<tr class="separator:a5287e61a227409a81add4eabbbcd4ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194f350512bf33c4c50ea8ef4b2042de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#a194f350512bf33c4c50ea8ef4b2042de">_rcl_parse_remap_fully_qualified_namespace</a> (<a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *lex_lookahead)</td></tr>
<tr class="memdesc:a194f350512bf33c4c50ea8ef4b2042de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a fully qualified namespace for a namespace replacement rule (ex: <code>/foo/bar</code>)  <a href="arguments_8c.html#a194f350512bf33c4c50ea8ef4b2042de">More...</a><br /></td></tr>
<tr class="separator:a194f350512bf33c4c50ea8ef4b2042de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f0628d1aef04967e99b7c388950e6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#aa5f0628d1aef04967e99b7c388950e6a">_rcl_parse_remap_replacement_token</a> (<a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *lex_lookahead)</td></tr>
<tr class="memdesc:aa5f0628d1aef04967e99b7c388950e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse either a token or a backreference (ex: <code>bar</code>, or <code>\7</code>).  <a href="arguments_8c.html#aa5f0628d1aef04967e99b7c388950e6a">More...</a><br /></td></tr>
<tr class="separator:aa5f0628d1aef04967e99b7c388950e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8621594577254059073bbfdb96247f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#a2c8621594577254059073bbfdb96247f">_rcl_parse_remap_replacement_name</a> (<a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *lex_lookahead, <a class="el" href="structrcl__remap__t.html">rcl_remap_t</a> *rule)</td></tr>
<tr class="memdesc:a2c8621594577254059073bbfdb96247f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the replacement side of a name remapping rule (ex: <code>bar/\1/foo</code>).  <a href="arguments_8c.html#a2c8621594577254059073bbfdb96247f">More...</a><br /></td></tr>
<tr class="separator:a2c8621594577254059073bbfdb96247f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1d0a5a2dbe23bec30a14cc4b26e5ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#ace1d0a5a2dbe23bec30a14cc4b26e5ad">_rcl_parse_resource_match_token</a> (<a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *lex_lookahead)</td></tr>
<tr class="memdesc:ace1d0a5a2dbe23bec30a14cc4b26e5ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse either a resource name token or a wildcard (ex: <code>foobar</code>, or <code>*</code>, or <code>**</code>).  <a href="arguments_8c.html#ace1d0a5a2dbe23bec30a14cc4b26e5ad">More...</a><br /></td></tr>
<tr class="separator:ace1d0a5a2dbe23bec30a14cc4b26e5ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4e9f1618c3de0bd5fdae30ee317a49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#a5f4e9f1618c3de0bd5fdae30ee317a49">_rcl_parse_resource_match</a> (<a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *lex_lookahead, <a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a> allocator, char **resource_match)</td></tr>
<tr class="memdesc:a5f4e9f1618c3de0bd5fdae30ee317a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a resource name match side of a rule (ex: <code>rostopic://foo</code>)  <a href="arguments_8c.html#a5f4e9f1618c3de0bd5fdae30ee317a49">More...</a><br /></td></tr>
<tr class="separator:a5f4e9f1618c3de0bd5fdae30ee317a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bfbee067c244b357d6d3760642f2553"><td class="memItemLeft" align="right" valign="top"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#a8bfbee067c244b357d6d3760642f2553">_rcl_parse_param_name</a> (<a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *lex_lookahead, <a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a> allocator, char **param_name)</td></tr>
<tr class="memdesc:a8bfbee067c244b357d6d3760642f2553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a parameter name in a parameter override rule (ex: <code>foo.bar</code>)  <a href="arguments_8c.html#a8bfbee067c244b357d6d3760642f2553">More...</a><br /></td></tr>
<tr class="separator:a8bfbee067c244b357d6d3760642f2553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32357cb16077b5effa7a1baafb1e53a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#af32357cb16077b5effa7a1baafb1e53a">_rcl_parse_remap_match_name</a> (<a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *lex_lookahead, <a class="el" href="structrcl__remap__t.html">rcl_remap_t</a> *rule)</td></tr>
<tr class="memdesc:af32357cb16077b5effa7a1baafb1e53a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the match side of a name remapping rule (ex: <code>rostopic://foo</code>)  <a href="arguments_8c.html#af32357cb16077b5effa7a1baafb1e53a">More...</a><br /></td></tr>
<tr class="separator:af32357cb16077b5effa7a1baafb1e53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cba41a4a9625dd75a6921785b9a97a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#a7cba41a4a9625dd75a6921785b9a97a8">_rcl_parse_remap_name_remap</a> (<a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *lex_lookahead, <a class="el" href="structrcl__remap__t.html">rcl_remap_t</a> *rule)</td></tr>
<tr class="memdesc:a7cba41a4a9625dd75a6921785b9a97a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a name remapping rule (ex: <code>rostopic:///foo:=bar</code>).  <a href="arguments_8c.html#a7cba41a4a9625dd75a6921785b9a97a8">More...</a><br /></td></tr>
<tr class="separator:a7cba41a4a9625dd75a6921785b9a97a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64639d0b56f962914258b056c59520a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#a64639d0b56f962914258b056c59520a0">_rcl_parse_remap_namespace_replacement</a> (<a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *lex_lookahead, <a class="el" href="structrcl__remap__t.html">rcl_remap_t</a> *rule)</td></tr>
<tr class="memdesc:a64639d0b56f962914258b056c59520a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a namespace replacement rule (ex: <code>__ns:=/new/ns</code>).  <a href="arguments_8c.html#a64639d0b56f962914258b056c59520a0">More...</a><br /></td></tr>
<tr class="separator:a64639d0b56f962914258b056c59520a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6173a24bd0cee1b62b53454fdd493c25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#a6173a24bd0cee1b62b53454fdd493c25">_rcl_parse_remap_nodename_replacement</a> (<a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *lex_lookahead, <a class="el" href="structrcl__remap__t.html">rcl_remap_t</a> *rule)</td></tr>
<tr class="memdesc:a6173a24bd0cee1b62b53454fdd493c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a nodename replacement rule (ex: <code>__node:=new_name</code> or <code>__name:=new_name</code>).  <a href="arguments_8c.html#a6173a24bd0cee1b62b53454fdd493c25">More...</a><br /></td></tr>
<tr class="separator:a6173a24bd0cee1b62b53454fdd493c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6201f40b21bbf2c8a3b6daf5123cd826"><td class="memItemLeft" align="right" valign="top"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#a6201f40b21bbf2c8a3b6daf5123cd826">_rcl_parse_nodename_prefix</a> (<a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *lex_lookahead, <a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a> allocator, char **node_name)</td></tr>
<tr class="memdesc:a6201f40b21bbf2c8a3b6daf5123cd826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a nodename prefix including trailing colon (ex: <code>node_name:</code>).  <a href="arguments_8c.html#a6201f40b21bbf2c8a3b6daf5123cd826">More...</a><br /></td></tr>
<tr class="separator:a6201f40b21bbf2c8a3b6daf5123cd826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19de406c16827c823c9a8ff7c663995"><td class="memItemLeft" align="right" valign="top"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#aa19de406c16827c823c9a8ff7c663995">_rcl_parse_remap_nodename_prefix</a> (<a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *lex_lookahead, <a class="el" href="structrcl__remap__t.html">rcl_remap_t</a> *rule)</td></tr>
<tr class="memdesc:aa19de406c16827c823c9a8ff7c663995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a nodename prefix for a remap rule.  <a href="arguments_8c.html#aa19de406c16827c823c9a8ff7c663995">More...</a><br /></td></tr>
<tr class="separator:aa19de406c16827c823c9a8ff7c663995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84f05e93246459c68d6b3486a804cdf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arguments_8c.html#ac84f05e93246459c68d6b3486a804cdf">_rcl_parse_remap_begin_remap_rule</a> (<a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *lex_lookahead, <a class="el" href="structrcl__remap__t.html">rcl_remap_t</a> *rule)</td></tr>
<tr class="memdesc:ac84f05e93246459c68d6b3486a804cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start recursive descent parsing of a remap rule.  <a href="arguments_8c.html#ac84f05e93246459c68d6b3486a804cdf">More...</a><br /></td></tr>
<tr class="separator:ac84f05e93246459c68d6b3486a804cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ae66ac20275619eb092ea60de69422a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae66ac20275619eb092ea60de69422a53">&#9670;&nbsp;</a></span>RCL_ENABLE_FLAG_PREFIX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RCL_ENABLE_FLAG_PREFIX&#160;&#160;&#160;&quot;--enable-&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac27234043cdfcb678d8372608cbf318c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac27234043cdfcb678d8372608cbf318c">&#9670;&nbsp;</a></span>RCL_DISABLE_FLAG_PREFIX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RCL_DISABLE_FLAG_PREFIX&#160;&#160;&#160;&quot;--disable-&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a2ada6c2d3316bfb19fe47a801d67f241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ada6c2d3316bfb19fe47a801d67f241">&#9670;&nbsp;</a></span>_rcl_parse_remap_rule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> _rcl_parse_remap_rule </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrcl__remap__t.html">rcl_remap_t</a> *&#160;</td>
          <td class="paramname"><em>output_rule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>// Internal Doxygen documentation </p>
<p>Parse an argument that may or may not be a remap rule. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>the argument to parse </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>an allocator to use </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">output_rule</td><td>input a zero intialized rule, output a fully initialized one </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RCL_RET_OK if a valid rule was parsed, or </dd>
<dd>
RCL_RET_INVALID_REMAP_RULE if the argument is not a valid rule, or </dd>
<dd>
RCL_RET_BAD_ALLOC if an allocation failed, or </dd>
<dd>
RLC_RET_ERROR if an unspecified error occurred. </dd></dl>

</div>
</div>
<a id="af7374c744686cf1284c33f05e8d4c2e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7374c744686cf1284c33f05e8d4c2e0">&#9670;&nbsp;</a></span>_rcl_parse_param_rule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> _rcl_parse_param_rule </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rcl_params_t *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an argument that may or may not be a param rule. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>the argument to parse </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">params</td><td>param overrides structure to populate. This structure must have been initialized by the caller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RCL_RET_OK if a valid rule was parsed, or </dd>
<dd>
RCL_RET_INVALID_ARGUMENT if an argument is invalid, or </dd>
<dd>
RCL_RET_INVALID_PARAM_RULE if the argument is not a valid rule, or </dd>
<dd>
RCL_RET_BAD_ALLOC if an allocation failed, or </dd>
<dd>
RLC_RET_ERROR if an unspecified error occurred. </dd></dl>

</div>
</div>
<a id="a8d7a9bc87595ebc889aa78fd83fe61d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d7a9bc87595ebc889aa78fd83fe61d5">&#9670;&nbsp;</a></span>rcl_arguments_get_param_files()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> rcl_arguments_get_param_files </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> *&#160;</td>
          <td class="paramname"><em>arguments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char ***&#160;</td>
          <td class="paramname"><em>parameter_files</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a list of yaml parameter file paths specified on the command line. </p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute </th><th class="markdownTableHeadNone">Adherence  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory </td><td class="markdownTableBodyNone">Yes  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe </td><td class="markdownTableBodyNone">No  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics </td><td class="markdownTableBodyNone">No  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free </td><td class="markdownTableBodyNone">Yes  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arguments</td><td>An arguments structure that has been parsed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>A valid allocator. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">parameter_files</td><td>An allocated array of paramter file names. This array must be deallocated by the caller using the given allocator. The output is NULL if there were no paramter files. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RCL_RET_OK</code> if everything goes correctly, or </dd>
<dd>
<code>RCL_RET_INVALID_ARGUMENT</code> if any function arguments are invalid, or </dd>
<dd>
<code>RCL_RET_BAD_ALLOC</code> if allocating memory failed, or </dd>
<dd>
<code>RCL_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a id="ad68964d428b8c7e280cf82461c6ebe78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad68964d428b8c7e280cf82461c6ebe78">&#9670;&nbsp;</a></span>rcl_arguments_get_param_files_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rcl_arguments_get_param_files_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> *&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of parameter yaml files given in the arguments. </p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute </th><th class="markdownTableHeadNone">Adherence  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory </td><td class="markdownTableBodyNone">No  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe </td><td class="markdownTableBodyNone">No  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics </td><td class="markdownTableBodyNone">No  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free </td><td class="markdownTableBodyNone">Yes  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>An arguments structure that has been parsed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of yaml files, or </dd>
<dd>
-1 if args is <code>NULL</code> or zero initialized. </dd></dl>

</div>
</div>
<a id="a4804387f33af2ef348866083a74f960c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4804387f33af2ef348866083a74f960c">&#9670;&nbsp;</a></span>rcl_arguments_get_param_overrides()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> rcl_arguments_get_param_overrides </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> *&#160;</td>
          <td class="paramname"><em>arguments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rcl_params_t **&#160;</td>
          <td class="paramname"><em>parameter_overrides</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return all parameter overrides parsed from the command line. </p>
<p>Parameter overrides are parsed directly from command line arguments and parameter files provided in the command line.</p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute </th><th class="markdownTableHeadNone">Adherence  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory </td><td class="markdownTableBodyNone">Yes  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe </td><td class="markdownTableBodyNone">No  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics </td><td class="markdownTableBodyNone">No  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free </td><td class="markdownTableBodyNone">Yes  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arguments</td><td>An arguments structure that has been parsed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">parameter_overrides</td><td>Parameter overrides as parsed from command line arguments. This structure must be finalized by the caller. The output is NULL if no parameter overrides were parsed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RCL_RET_OK</code> if everything goes correctly, or </dd>
<dd>
<code>RCL_RET_INVALID_ARGUMENT</code> if any function arguments are invalid, or </dd>
<dd>
<code>RCL_RET_BAD_ALLOC</code> if allocating memory failed, or </dd>
<dd>
<code>RCL_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a id="a327dcafa20045671bb385a41f235aeae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a327dcafa20045671bb385a41f235aeae">&#9670;&nbsp;</a></span>_rcl_parse_log_level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> _rcl_parse_log_level </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>log_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an argument that may or may not be a log level rule. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>the argument to parse </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>an allocator to use </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log_level</td><td>parsed log level represented by <code>RCUTILS_LOG_SEVERITY</code> enum </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RCL_RET_OK if a valid log level was parsed, or </dd>
<dd>
RCL_RET_INVALID_LOG_LEVEL if the argument is not a valid rule, or </dd>
<dd>
RCL_RET_BAD_ALLOC if an allocation failed, or </dd>
<dd>
RLC_RET_ERROR if an unspecified error occurred. </dd></dl>

</div>
</div>
<a id="ab64bc48ad928b30bcf9a648377e5389b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab64bc48ad928b30bcf9a648377e5389b">&#9670;&nbsp;</a></span>_rcl_parse_external_log_config_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> _rcl_parse_external_log_config_file </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>log_config_file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an argument that may or may not be a log configuration file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>the argument to parse </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>an allocator to use </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log_config_file</td><td>parsed log configuration file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RCL_RET_OK if a valid log config file was parsed, or </dd>
<dd>
RCL_RET_BAD_ALLOC if an allocation failed, or </dd>
<dd>
RLC_RET_ERROR if an unspecified error occurred. </dd></dl>

</div>
</div>
<a id="a2174d3766a25bc9ce0d336be728151a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2174d3766a25bc9ce0d336be728151a8">&#9670;&nbsp;</a></span>_rcl_parse_param_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> _rcl_parse_param_file </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rcl_params_t *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>param_file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an argument that may or may not be a parameter file. </p>
<p>The syntax of the file name is not validated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>the argument to parse </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>an allocator to use </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">param_file</td><td>string that could be a parameter file name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RCL_RET_OK if the rule was parsed correctly, or </dd>
<dd>
RCL_RET_BAD_ALLOC if an allocation failed, or </dd>
<dd>
RLC_RET_ERROR if an unspecified error occurred. </dd></dl>

</div>
</div>
<a id="a02bd169f1fbd304e24bbb1b565fc98d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02bd169f1fbd304e24bbb1b565fc98d7">&#9670;&nbsp;</a></span>_rcl_parse_enclave()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> _rcl_parse_enclave </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>enclave</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an enclave argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>the argument to parse </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>an allocator to use </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">enclave</td><td>parsed security enclave </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RCL_RET_OK if a valid security enclave was parsed, or </dd>
<dd>
RCL_RET_BAD_ALLOC if an allocation failed, or </dd>
<dd>
RLC_RET_ERROR if an unspecified error occurred. </dd></dl>

</div>
</div>
<a id="ab936bf1669344c410cc5de49e7ff3ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab936bf1669344c410cc5de49e7ff3ba4">&#9670;&nbsp;</a></span>_rcl_parse_disabling_flag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> _rcl_parse_disabling_flag </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a bool argument that may or may not be for the provided key rule. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>the argument to parse </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>the key for the argument to parse. Should be a null terminated string </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">value</td><td>parsed boolean value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RCL_RET_OK if the bool argument was parsed successfully, or </dd>
<dd>
RLC_RET_ERROR if an unspecified error occurred. </dd></dl>

</div>
</div>
<a id="a299fe5fc1a0770c65d1ff6d314d5a80c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a299fe5fc1a0770c65d1ff6d314d5a80c">&#9670;&nbsp;</a></span>_rcl_allocate_initialized_arguments_impl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> _rcl_allocate_initialized_arguments_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate and zero initialize arguments impl and. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">args</td><td>target arguments to set impl </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>an allocator to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RCL_RET_OK if a valid rule was parsed, or </dd>
<dd>
RCL_RET_BAD_ALLOC if an allocation failed </dd></dl>

</div>
</div>
<a id="ac115fc88cd80fb7832d4df9f8c634f72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac115fc88cd80fb7832d4df9f8c634f72">&#9670;&nbsp;</a></span>rcl_parse_arguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> rcl_parse_arguments </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>argv</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> *&#160;</td>
          <td class="paramname"><em>args_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse command line arguments into a structure usable by code. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="arguments_8h.html#a147323ec6ccf940e3a2caf953ec7d3e7" title="Return a rcl_arguments_t struct with members initialized to NULL.">rcl_get_zero_initialized_arguments()</a></dd></dl>
<p>ROS arguments are expected to be scoped by a leading <code>--ros-args</code> flag and a trailing double dash token <code>--</code> which may be elided if no non-ROS arguments follow after the last <code>--ros-args</code>.</p>
<p>Remap rule parsing is supported via <code>-r/--remap</code> flags e.g. <code>--remap from:=to</code> or <code>-r from:=to</code>. Successfully parsed remap rules are stored in the order they were given in <code>argv</code>. If given arguments <code>{"__ns:=/foo", "__ns:=/bar"}</code> then the namespace used by nodes in this process will be <code>/foo</code> and not <code>/bar</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="remap_8h.html#aeb75c73d609d17b1707e62c829483410" title="Remap a topic name based on given rules.">rcl_remap_topic_name()</a> </dd>
<dd>
<a class="el" href="remap_8h.html#a0885a965511719f43a84dd3e4f19e0c5" title="Remap a service name based on given rules.">rcl_remap_service_name()</a> </dd>
<dd>
<a class="el" href="remap_8h.html#ae44fa92a03acb1cc1c65bd1a6bdaac8d" title="Remap a node name based on given rules.">rcl_remap_node_name()</a> </dd>
<dd>
<a class="el" href="remap_8h.html#aa066c5f410799104c35cb91d355f548e" title="Remap a namespace based on given rules.">rcl_remap_node_namespace()</a></dd></dl>
<p>Parameter override rule parsing is supported via <code>-p/--param</code> flags e.g. <code>--param name:=value</code> or <code>-p name:=value</code>.</p>
<p>The default log level will be parsed as <code>--log-level level</code>, where <code>level</code> is a name representing one of the log levels in the <code>RCUTILS_LOG_SEVERITY</code> enum, e.g. <code>info</code>, <code>debug</code>, <code>warn</code>, not case sensitive. If multiple of these rules are found, the last one parsed will be used.</p>
<p>If an argument does not appear to be a valid ROS argument e.g. a <code>-r/--remap</code> flag followed by anything but a valid remap rule, parsing will fail immediately.</p>
<p>If an argument does not appear to be a known ROS argument, then it is skipped and left unparsed.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="arguments_8h.html#aa2cbe6126e7cdd24f1c86448370f1cea" title="Return the number of ROS specific arguments that were not successfully parsed.">rcl_arguments_get_count_unparsed_ros()</a> </dd>
<dd>
<a class="el" href="arguments_8h.html#a25869df92ec7b344c1eb112b00d66be6" title="Return a list of indices to unknown ROS specific arguments that were left unparsed.">rcl_arguments_get_unparsed_ros()</a></dd></dl>
<p>All arguments found outside a <code>--ros-args ... --</code> scope are skipped and left unparsed.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="arguments_8h.html#acc3651d7428c5c2789d27872155023ce" title="Return the number of arguments that were not ROS specific arguments.">rcl_arguments_get_count_unparsed()</a> </dd>
<dd>
<a class="el" href="arguments_8h.html#ade6722d8fc966d9cc3ddcb60fe32c44a" title="Return a list of indices to non ROS specific arguments.">rcl_arguments_get_unparsed()</a></dd></dl>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute </th><th class="markdownTableHeadNone">Adherence  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory </td><td class="markdownTableBodyNone">Yes  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe </td><td class="markdownTableBodyNone">Yes  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics </td><td class="markdownTableBodyNone">No  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free </td><td class="markdownTableBodyNone">Yes  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">argc</td><td>The number of arguments in argv. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argv</td><td>The values of the arguments. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>A valid allocator. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">args_output</td><td>A structure that will contain the result of parsing. Must be zero initialized before use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RCL_RET_OK</code> if the arguments were parsed successfully, or </dd>
<dd>
<code>RCL_RET_INVALID_ROS_ARGS</code> if an invalid ROS argument is found, or </dd>
<dd>
<code>RCL_RET_INVALID_ARGUMENT</code> if any function arguments are invalid, or </dd>
<dd>
<code>RCL_RET_BAD_ALLOC</code> if allocating memory failed, or </dd>
<dd>
<code>RCL_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a id="acc3651d7428c5c2789d27872155023ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc3651d7428c5c2789d27872155023ce">&#9670;&nbsp;</a></span>rcl_arguments_get_count_unparsed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rcl_arguments_get_count_unparsed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> *&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of arguments that were not ROS specific arguments. </p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute </th><th class="markdownTableHeadNone">Adherence  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory </td><td class="markdownTableBodyNone">No  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe </td><td class="markdownTableBodyNone">Yes  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics </td><td class="markdownTableBodyNone">No  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free </td><td class="markdownTableBodyNone">Yes  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>An arguments structure that has been parsed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of unparsed arguments, or </dd>
<dd>
-1 if args is <code>NULL</code> or zero initialized. </dd></dl>

</div>
</div>
<a id="ade6722d8fc966d9cc3ddcb60fe32c44a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade6722d8fc966d9cc3ddcb60fe32c44a">&#9670;&nbsp;</a></span>rcl_arguments_get_unparsed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> rcl_arguments_get_unparsed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>output_unparsed_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a list of indices to non ROS specific arguments. </p>
<p>Non ROS specific arguments may have been provided i.e. arguments outside a '&ndash;ros-args' scope. This function populates an array of indices to these arguments in the original argv array. Since the first argument is always assumed to be a process name, the list will always contain the index 0.</p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute </th><th class="markdownTableHeadNone">Adherence  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory </td><td class="markdownTableBodyNone">Yes  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe </td><td class="markdownTableBodyNone">Yes  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics </td><td class="markdownTableBodyNone">No  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free </td><td class="markdownTableBodyNone">Yes  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>An arguments structure that has been parsed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>A valid allocator. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_unparsed_indices</td><td>An allocated array of indices into the original argv array. This array must be deallocated by the caller using the given allocator. If there are no unparsed args then the output will be set to NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RCL_RET_OK</code> if everything goes correctly, or </dd>
<dd>
<code>RCL_RET_INVALID_ARGUMENT</code> if any function arguments are invalid, or </dd>
<dd>
<code>RCL_RET_BAD_ALLOC</code> if allocating memory failed, or </dd>
<dd>
<code>RCL_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a id="aa2cbe6126e7cdd24f1c86448370f1cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2cbe6126e7cdd24f1c86448370f1cea">&#9670;&nbsp;</a></span>rcl_arguments_get_count_unparsed_ros()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rcl_arguments_get_count_unparsed_ros </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> *&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of ROS specific arguments that were not successfully parsed. </p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute </th><th class="markdownTableHeadNone">Adherence  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory </td><td class="markdownTableBodyNone">No  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe </td><td class="markdownTableBodyNone">Yes  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics </td><td class="markdownTableBodyNone">No  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free </td><td class="markdownTableBodyNone">Yes  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>An arguments structure that has been parsed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of unparsed ROS specific arguments, or </dd>
<dd>
-1 if args is <code>NULL</code> or zero initialized. </dd></dl>

</div>
</div>
<a id="a25869df92ec7b344c1eb112b00d66be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25869df92ec7b344c1eb112b00d66be6">&#9670;&nbsp;</a></span>rcl_arguments_get_unparsed_ros()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> rcl_arguments_get_unparsed_ros </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>output_unparsed_ros_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a list of indices to unknown ROS specific arguments that were left unparsed. </p>
<p>Some ROS specific arguments may not have been recognized, or were not intended to be parsed by rcl. This function populates an array of indices to these arguments in the original argv array.</p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute </th><th class="markdownTableHeadNone">Adherence  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory </td><td class="markdownTableBodyNone">Yes  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe </td><td class="markdownTableBodyNone">Yes  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics </td><td class="markdownTableBodyNone">No  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free </td><td class="markdownTableBodyNone">Yes  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>An arguments structure that has been parsed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>A valid allocator. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_unparsed_indices</td><td>An allocated array of indices into the original argv array. This array must be deallocated by the caller using the given allocator. If there are no unparsed ROS specific arguments then the output will be set to NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RCL_RET_OK</code> if everything goes correctly, or </dd>
<dd>
<code>RCL_RET_INVALID_ARGUMENT</code> if any function arguments are invalid, or </dd>
<dd>
<code>RCL_RET_BAD_ALLOC</code> if allocating memory failed, or </dd>
<dd>
<code>RCL_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a id="a147323ec6ccf940e3a2caf953ec7d3e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a147323ec6ccf940e3a2caf953ec7d3e7">&#9670;&nbsp;</a></span>rcl_get_zero_initialized_arguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> rcl_get_zero_initialized_arguments </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <a class="el" href="structrcl__arguments__t.html" title="Hold output of parsing command line arguments.">rcl_arguments_t</a> struct with members initialized to <code>NULL</code>. </p>

</div>
</div>
<a id="aaa7f3b5096ff92e8a4877cca33387673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa7f3b5096ff92e8a4877cca33387673">&#9670;&nbsp;</a></span>rcl_remove_ros_arguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> rcl_remove_ros_arguments </td>
          <td>(</td>
          <td class="paramtype">char const *const&#160;</td>
          <td class="paramname"><em>argv</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nonros_argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>nonros_argv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a list of arguments with ROS-specific arguments removed. </p>
<p>Some arguments may not have been intended as ROS arguments. This function populates an array of the aruments in a new argv array. Since the first argument is always assumed to be a process name, the list will always contain the first value from the argument vector.</p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute </th><th class="markdownTableHeadNone">Adherence  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory </td><td class="markdownTableBodyNone">Yes  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe </td><td class="markdownTableBodyNone">Yes  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics </td><td class="markdownTableBodyNone">No  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free </td><td class="markdownTableBodyNone">Yes  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">argv</td><td>The argument vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>An arguments structure that has been parsed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>A valid allocator. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nonros_argc</td><td>The count of arguments that aren't ROS-specific </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nonros_argv</td><td>An allocated array of arguments that aren't ROS-specific This array must be deallocated by the caller using the given allocator. If there are no non-ROS args, then the output will be set to NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RCL_RET_OK</code> if everything goes correctly, or </dd>
<dd>
<code>RCL_RET_INVALID_ARGUMENT</code> if any function arguments are invalid, or </dd>
<dd>
<code>RCL_RET_BAD_ALLOC</code> if allocating memory failed, or </dd>
<dd>
<code>RCL_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a id="aafe1f021f617406a45877c9d6dbc011d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafe1f021f617406a45877c9d6dbc011d">&#9670;&nbsp;</a></span>rcl_arguments_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> rcl_arguments_copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> *&#160;</td>
          <td class="paramname"><em>args_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy one arguments structure into another. </p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute </th><th class="markdownTableHeadNone">Adherence  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory </td><td class="markdownTableBodyNone">Yes  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe </td><td class="markdownTableBodyNone">No  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics </td><td class="markdownTableBodyNone">No  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free </td><td class="markdownTableBodyNone">Yes  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>The structure to be copied. Its allocator is used to copy memory into the new structure. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">args_out</td><td>A zero-initialized arguments structure to be copied into. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RCL_RET_OK</code> if the structure was copied successfully, or </dd>
<dd>
<code>RCL_RET_INVALID_ARGUMENT</code> if any function arguments are invalid, or </dd>
<dd>
<code>RCL_RET_BAD_ALLOC</code> if allocating memory failed, or </dd>
<dd>
<code>RCL_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a id="a5287e61a227409a81add4eabbbcd4ff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5287e61a227409a81add4eabbbcd4ff1">&#9670;&nbsp;</a></span>rcl_arguments_fini()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> rcl_arguments_fini </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__arguments__t.html">rcl_arguments_t</a> *&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reclaim resources held inside <a class="el" href="structrcl__arguments__t.html" title="Hold output of parsing command line arguments.">rcl_arguments_t</a> structure. </p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute </th><th class="markdownTableHeadNone">Adherence  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory </td><td class="markdownTableBodyNone">No  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe </td><td class="markdownTableBodyNone">Yes  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics </td><td class="markdownTableBodyNone">No  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free </td><td class="markdownTableBodyNone">Yes  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>The structure to be deallocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RCL_RET_OK</code> if the memory was successfully freed, or </dd>
<dd>
<code>RCL_RET_INVALID_ARGUMENT</code> if any function arguments are invalid, or </dd>
<dd>
<code>RCL_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a id="a194f350512bf33c4c50ea8ef4b2042de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a194f350512bf33c4c50ea8ef4b2042de">&#9670;&nbsp;</a></span>_rcl_parse_remap_fully_qualified_namespace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> _rcl_parse_remap_fully_qualified_namespace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *&#160;</td>
          <td class="paramname"><em>lex_lookahead</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a fully qualified namespace for a namespace replacement rule (ex: <code>/foo/bar</code>) </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="arguments_8c.html#ac84f05e93246459c68d6b3486a804cdf" title="Start recursive descent parsing of a remap rule.">_rcl_parse_remap_begin_remap_rule()</a> </dd></dl>

</div>
</div>
<a id="aa5f0628d1aef04967e99b7c388950e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5f0628d1aef04967e99b7c388950e6a">&#9670;&nbsp;</a></span>_rcl_parse_remap_replacement_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> _rcl_parse_remap_replacement_token </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *&#160;</td>
          <td class="paramname"><em>lex_lookahead</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse either a token or a backreference (ex: <code>bar</code>, or <code>\7</code>). </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="arguments_8c.html#ac84f05e93246459c68d6b3486a804cdf" title="Start recursive descent parsing of a remap rule.">_rcl_parse_remap_begin_remap_rule()</a> </dd></dl>

</div>
</div>
<a id="a2c8621594577254059073bbfdb96247f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c8621594577254059073bbfdb96247f">&#9670;&nbsp;</a></span>_rcl_parse_remap_replacement_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> _rcl_parse_remap_replacement_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *&#160;</td>
          <td class="paramname"><em>lex_lookahead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrcl__remap__t.html">rcl_remap_t</a> *&#160;</td>
          <td class="paramname"><em>rule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the replacement side of a name remapping rule (ex: <code>bar/\1/foo</code>). </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="arguments_8c.html#ac84f05e93246459c68d6b3486a804cdf" title="Start recursive descent parsing of a remap rule.">_rcl_parse_remap_begin_remap_rule()</a> </dd></dl>

</div>
</div>
<a id="ace1d0a5a2dbe23bec30a14cc4b26e5ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace1d0a5a2dbe23bec30a14cc4b26e5ad">&#9670;&nbsp;</a></span>_rcl_parse_resource_match_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> _rcl_parse_resource_match_token </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *&#160;</td>
          <td class="paramname"><em>lex_lookahead</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse either a resource name token or a wildcard (ex: <code>foobar</code>, or <code>*</code>, or <code>**</code>). </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="arguments_8c.html#a5f4e9f1618c3de0bd5fdae30ee317a49" title="Parse a resource name match side of a rule (ex: rostopic://foo)">_rcl_parse_resource_match()</a> </dd></dl>

</div>
</div>
<a id="a5f4e9f1618c3de0bd5fdae30ee317a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f4e9f1618c3de0bd5fdae30ee317a49">&#9670;&nbsp;</a></span>_rcl_parse_resource_match()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> _rcl_parse_resource_match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *&#160;</td>
          <td class="paramname"><em>lex_lookahead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>resource_match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a resource name match side of a rule (ex: <code>rostopic://foo</code>) </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="arguments_8c.html#af32357cb16077b5effa7a1baafb1e53a" title="Parse the match side of a name remapping rule (ex: rostopic://foo)">_rcl_parse_remap_match_name()</a> </dd></dl>

</div>
</div>
<a id="a8bfbee067c244b357d6d3760642f2553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bfbee067c244b357d6d3760642f2553">&#9670;&nbsp;</a></span>_rcl_parse_param_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> _rcl_parse_param_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *&#160;</td>
          <td class="paramname"><em>lex_lookahead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>param_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a parameter name in a parameter override rule (ex: <code>foo.bar</code>) </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="arguments_8c.html#af7374c744686cf1284c33f05e8d4c2e0" title="Parse an argument that may or may not be a param rule.">_rcl_parse_param_rule()</a> </dd></dl>

</div>
</div>
<a id="af32357cb16077b5effa7a1baafb1e53a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af32357cb16077b5effa7a1baafb1e53a">&#9670;&nbsp;</a></span>_rcl_parse_remap_match_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> _rcl_parse_remap_match_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *&#160;</td>
          <td class="paramname"><em>lex_lookahead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrcl__remap__t.html">rcl_remap_t</a> *&#160;</td>
          <td class="paramname"><em>rule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the match side of a name remapping rule (ex: <code>rostopic://foo</code>) </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="arguments_8c.html#ac84f05e93246459c68d6b3486a804cdf" title="Start recursive descent parsing of a remap rule.">_rcl_parse_remap_begin_remap_rule()</a> </dd></dl>

</div>
</div>
<a id="a7cba41a4a9625dd75a6921785b9a97a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cba41a4a9625dd75a6921785b9a97a8">&#9670;&nbsp;</a></span>_rcl_parse_remap_name_remap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> _rcl_parse_remap_name_remap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *&#160;</td>
          <td class="paramname"><em>lex_lookahead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrcl__remap__t.html">rcl_remap_t</a> *&#160;</td>
          <td class="paramname"><em>rule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a name remapping rule (ex: <code>rostopic:///foo:=bar</code>). </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="arguments_8c.html#ac84f05e93246459c68d6b3486a804cdf" title="Start recursive descent parsing of a remap rule.">_rcl_parse_remap_begin_remap_rule()</a> </dd></dl>

</div>
</div>
<a id="a64639d0b56f962914258b056c59520a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64639d0b56f962914258b056c59520a0">&#9670;&nbsp;</a></span>_rcl_parse_remap_namespace_replacement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> _rcl_parse_remap_namespace_replacement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *&#160;</td>
          <td class="paramname"><em>lex_lookahead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrcl__remap__t.html">rcl_remap_t</a> *&#160;</td>
          <td class="paramname"><em>rule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a namespace replacement rule (ex: <code>__ns:=/new/ns</code>). </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="arguments_8c.html#ac84f05e93246459c68d6b3486a804cdf" title="Start recursive descent parsing of a remap rule.">_rcl_parse_remap_begin_remap_rule()</a> </dd></dl>

</div>
</div>
<a id="a6173a24bd0cee1b62b53454fdd493c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6173a24bd0cee1b62b53454fdd493c25">&#9670;&nbsp;</a></span>_rcl_parse_remap_nodename_replacement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> _rcl_parse_remap_nodename_replacement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *&#160;</td>
          <td class="paramname"><em>lex_lookahead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrcl__remap__t.html">rcl_remap_t</a> *&#160;</td>
          <td class="paramname"><em>rule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a nodename replacement rule (ex: <code>__node:=new_name</code> or <code>__name:=new_name</code>). </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="arguments_8c.html#ac84f05e93246459c68d6b3486a804cdf" title="Start recursive descent parsing of a remap rule.">_rcl_parse_remap_begin_remap_rule()</a> </dd></dl>

</div>
</div>
<a id="a6201f40b21bbf2c8a3b6daf5123cd826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6201f40b21bbf2c8a3b6daf5123cd826">&#9670;&nbsp;</a></span>_rcl_parse_nodename_prefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> _rcl_parse_nodename_prefix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *&#160;</td>
          <td class="paramname"><em>lex_lookahead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>node_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a nodename prefix including trailing colon (ex: <code>node_name:</code>). </p>

</div>
</div>
<a id="aa19de406c16827c823c9a8ff7c663995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa19de406c16827c823c9a8ff7c663995">&#9670;&nbsp;</a></span>_rcl_parse_remap_nodename_prefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> _rcl_parse_remap_nodename_prefix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *&#160;</td>
          <td class="paramname"><em>lex_lookahead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrcl__remap__t.html">rcl_remap_t</a> *&#160;</td>
          <td class="paramname"><em>rule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a nodename prefix for a remap rule. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="arguments_8c.html#a6201f40b21bbf2c8a3b6daf5123cd826" title="Parse a nodename prefix including trailing colon (ex: node_name:).">_rcl_parse_nodename_prefix()</a> </dd>
<dd>
<a class="el" href="arguments_8c.html#ac84f05e93246459c68d6b3486a804cdf" title="Start recursive descent parsing of a remap rule.">_rcl_parse_remap_begin_remap_rule()</a> </dd></dl>

</div>
</div>
<a id="ac84f05e93246459c68d6b3486a804cdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84f05e93246459c68d6b3486a804cdf">&#9670;&nbsp;</a></span>_rcl_parse_remap_begin_remap_rule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="visibility__control_8h.html#a0be867e3a0116c21da2bdad617b3628c">RCL_LOCAL</a> <a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> _rcl_parse_remap_begin_remap_rule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__lexer__lookahead2__t.html">rcl_lexer_lookahead2_t</a> *&#160;</td>
          <td class="paramname"><em>lex_lookahead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrcl__remap__t.html">rcl_remap_t</a> *&#160;</td>
          <td class="paramname"><em>rule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start recursive descent parsing of a remap rule. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lex_lookahead</td><td>a lookahead(2) buffer for the parser to use. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rule</td><td>input a zero intialized rule, output a fully initialized one. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RCL_RET_OK if a valid rule was parsed, or </dd>
<dd>
RCL_RET_INVALID_REMAP_RULE if the argument is not a valid rule, or </dd>
<dd>
RCL_RET_BAD_ALLOC if an allocation failed, or </dd>
<dd>
RLC_RET_ERROR if an unspecified error occurred. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
