<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>class_loader: class_loader::impl Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">class_loader
   &#160;<span id="projectnumber">master</span>
   </div>
   <div id="projectbrief">The class_loader package is a ROS-independent package for loading plugins  during runtime.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceclass__loader.html">class_loader</a></li><li class="navelem"><a class="el" href="namespaceclass__loader_1_1impl.html">impl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">class_loader::impl Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclass__loader_1_1impl_1_1AbstractMetaObject.html">AbstractMetaObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for factories where polymorphic type variable indicates base class for plugin interface.  <a href="classclass__loader_1_1impl_1_1AbstractMetaObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclass__loader_1_1impl_1_1AbstractMetaObjectBase.html">AbstractMetaObjectBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for MetaObjects that excludes a polymorphic type parameter. Subclasses are class templates though.  <a href="classclass__loader_1_1impl_1_1AbstractMetaObjectBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclass__loader_1_1impl_1_1MetaObject.html">MetaObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The actual factory.  <a href="classclass__loader_1_1impl_1_1MetaObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a7328617dde009449255ddb0b44edb815"><td class="memItemLeft" align="right" valign="top">typedef <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclass__loader_1_1impl.html#a7328617dde009449255ddb0b44edb815">LibraryPath</a></td></tr>
<tr class="separator:a7328617dde009449255ddb0b44edb815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96af38012f86e99c92eccb04b109ce2f"><td class="memItemLeft" align="right" valign="top">typedef <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclass__loader_1_1impl.html#a96af38012f86e99c92eccb04b109ce2f">ClassName</a></td></tr>
<tr class="separator:a96af38012f86e99c92eccb04b109ce2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105d0e92ba543a5c20d57757504df487"><td class="memItemLeft" align="right" valign="top">typedef <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclass__loader_1_1impl.html#a105d0e92ba543a5c20d57757504df487">BaseClassName</a></td></tr>
<tr class="separator:a105d0e92ba543a5c20d57757504df487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc173a86072f3fa3e5d08b5770669797"><td class="memItemLeft" align="right" valign="top">typedef <a class="elRef" href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a>&lt; <a class="el" href="namespaceclass__loader_1_1impl.html#a96af38012f86e99c92eccb04b109ce2f">ClassName</a>, <a class="el" href="classclass__loader_1_1impl_1_1AbstractMetaObjectBase.html">impl::AbstractMetaObjectBase</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclass__loader_1_1impl.html#afc173a86072f3fa3e5d08b5770669797">FactoryMap</a></td></tr>
<tr class="separator:afc173a86072f3fa3e5d08b5770669797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7afa94e8c25834e59acf083c28088ede"><td class="memItemLeft" align="right" valign="top">typedef <a class="elRef" href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a>&lt; <a class="el" href="namespaceclass__loader_1_1impl.html#a105d0e92ba543a5c20d57757504df487">BaseClassName</a>, <a class="el" href="namespaceclass__loader_1_1impl.html#afc173a86072f3fa3e5d08b5770669797">FactoryMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclass__loader_1_1impl.html#a7afa94e8c25834e59acf083c28088ede">BaseToFactoryMapMap</a></td></tr>
<tr class="separator:a7afa94e8c25834e59acf083c28088ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a6cbd24201c8b499b1d93f2671009e"><td class="memItemLeft" align="right" valign="top">typedef <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="namespaceclass__loader_1_1impl.html#a7328617dde009449255ddb0b44edb815">LibraryPath</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; rcpputils::SharedLibrary &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclass__loader_1_1impl.html#ac4a6cbd24201c8b499b1d93f2671009e">LibraryPair</a></td></tr>
<tr class="separator:ac4a6cbd24201c8b499b1d93f2671009e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d7ccf49e0603ddcd6bfbdfdc35cc4c"><td class="memItemLeft" align="right" valign="top">typedef <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="namespaceclass__loader_1_1impl.html#ac4a6cbd24201c8b499b1d93f2671009e">LibraryPair</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclass__loader_1_1impl.html#a06d7ccf49e0603ddcd6bfbdfdc35cc4c">LibraryVector</a></td></tr>
<tr class="separator:a06d7ccf49e0603ddcd6bfbdfdc35cc4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ddd9a3d4e9adcd29caf29a543b6b34"><td class="memItemLeft" align="right" valign="top">typedef <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classclass__loader_1_1impl_1_1AbstractMetaObjectBase.html">AbstractMetaObjectBase</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclass__loader_1_1impl.html#a63ddd9a3d4e9adcd29caf29a543b6b34">MetaObjectVector</a></td></tr>
<tr class="separator:a63ddd9a3d4e9adcd29caf29a543b6b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a080ab7b268d248563c4c0529d835ca51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclass__loader_1_1impl.html#a080ab7b268d248563c4c0529d835ca51">printDebugInfoToScreen</a> ()</td></tr>
<tr class="separator:a080ab7b268d248563c4c0529d835ca51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f080d328f070fe05598ab4fc0f76fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceclass__loader_1_1impl.html#a7afa94e8c25834e59acf083c28088ede">BaseToFactoryMapMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclass__loader_1_1impl.html#a84f080d328f070fe05598ab4fc0f76fe">getGlobalPluginBaseToFactoryMapMap</a> ()</td></tr>
<tr class="memdesc:a84f080d328f070fe05598ab4fc0f76fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a handle to a global data structure that holds a map of base class names (Base class describes plugin interface) to a FactoryMap which holds the factories for the various different concrete classes that can be instantiated. Note that the Base class is NOT THE LITERAL CLASSNAME, but rather the result of typeid(Base).name() which sometimes is the literal class name (as on Windows) but is often in mangled form (as on Linux).  <a href="namespaceclass__loader_1_1impl.html#a84f080d328f070fe05598ab4fc0f76fe">More...</a><br /></td></tr>
<tr class="separator:a84f080d328f070fe05598ab4fc0f76fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6122c8f9364a1237332ef2e4e77383"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceclass__loader_1_1impl.html#a06d7ccf49e0603ddcd6bfbdfdc35cc4c">LibraryVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclass__loader_1_1impl.html#abc6122c8f9364a1237332ef2e4e77383">getLoadedLibraryVector</a> ()</td></tr>
<tr class="memdesc:abc6122c8f9364a1237332ef2e4e77383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a handle to a list of open libraries in the form of LibraryPairs which encode the library path+name and the handle to the underlying shared library.  <a href="namespaceclass__loader_1_1impl.html#abc6122c8f9364a1237332ef2e4e77383">More...</a><br /></td></tr>
<tr class="separator:abc6122c8f9364a1237332ef2e4e77383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31028710d744f7653b2b617b8cfd4c07"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclass__loader_1_1impl.html#a31028710d744f7653b2b617b8cfd4c07">getCurrentlyLoadingLibraryName</a> ()</td></tr>
<tr class="memdesc:a31028710d744f7653b2b617b8cfd4c07"><td class="mdescLeft">&#160;</td><td class="mdescRight">When a library is being loaded, in order for factories to know which library they are being associated with, they use this function to query which library is being loaded.  <a href="namespaceclass__loader_1_1impl.html#a31028710d744f7653b2b617b8cfd4c07">More...</a><br /></td></tr>
<tr class="separator:a31028710d744f7653b2b617b8cfd4c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62601227903ac75bfda5a3c6052d88b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclass__loader_1_1impl.html#a62601227903ac75bfda5a3c6052d88b4">setCurrentlyLoadingLibraryName</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;library_name)</td></tr>
<tr class="memdesc:a62601227903ac75bfda5a3c6052d88b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">When a library is being loaded, in order for factories to know which library they are being associated with, this function is called to set the name of the library currently being loaded.  <a href="namespaceclass__loader_1_1impl.html#a62601227903ac75bfda5a3c6052d88b4">More...</a><br /></td></tr>
<tr class="separator:a62601227903ac75bfda5a3c6052d88b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34c1ab776cc37bc90b95e3d3c81e5e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclass__loader_1_1ClassLoader.html">ClassLoader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclass__loader_1_1impl.html#af34c1ab776cc37bc90b95e3d3c81e5e2">getCurrentlyActiveClassLoader</a> ()</td></tr>
<tr class="memdesc:af34c1ab776cc37bc90b95e3d3c81e5e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <a class="el" href="classclass__loader_1_1ClassLoader.html" title="This class allows loading and unloading of dynamically linked libraries which contain class definitio...">ClassLoader</a> currently in scope which used when a library is being loaded.  <a href="namespaceclass__loader_1_1impl.html#af34c1ab776cc37bc90b95e3d3c81e5e2">More...</a><br /></td></tr>
<tr class="separator:af34c1ab776cc37bc90b95e3d3c81e5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47895c05ab9430669905ae74f7a8957d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclass__loader_1_1impl.html#a47895c05ab9430669905ae74f7a8957d">setCurrentlyActiveClassLoader</a> (<a class="el" href="classclass__loader_1_1ClassLoader.html">ClassLoader</a> *loader)</td></tr>
<tr class="memdesc:a47895c05ab9430669905ae74f7a8957d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <a class="el" href="classclass__loader_1_1ClassLoader.html" title="This class allows loading and unloading of dynamically linked libraries which contain class definitio...">ClassLoader</a> currently in scope which used when a library is being loaded.  <a href="namespaceclass__loader_1_1impl.html#a47895c05ab9430669905ae74f7a8957d">More...</a><br /></td></tr>
<tr class="separator:a47895c05ab9430669905ae74f7a8957d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a2d4ea55307d1086b2c4907ab78586"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceclass__loader_1_1impl.html#afc173a86072f3fa3e5d08b5770669797">FactoryMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclass__loader_1_1impl.html#a80a2d4ea55307d1086b2c4907ab78586">getFactoryMapForBaseClass</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;typeid_base_class_name)</td></tr>
<tr class="memdesc:a80a2d4ea55307d1086b2c4907ab78586"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function extracts a reference to the FactoryMap for appropriate base class out of the global plugin base to factory map. This function should be used by functions in this namespace that need to access the various factories so as to make sure the right key is generated to index into the global map.  <a href="namespaceclass__loader_1_1impl.html#a80a2d4ea55307d1086b2c4907ab78586">More...</a><br /></td></tr>
<tr class="separator:a80a2d4ea55307d1086b2c4907ab78586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af37d61b31b7739503489b225fa26e0ea"><td class="memTemplParams" colspan="2">template&lt;typename Base &gt; </td></tr>
<tr class="memitem:af37d61b31b7739503489b225fa26e0ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceclass__loader_1_1impl.html#afc173a86072f3fa3e5d08b5770669797">FactoryMap</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclass__loader_1_1impl.html#af37d61b31b7739503489b225fa26e0ea">getFactoryMapForBaseClass</a> ()</td></tr>
<tr class="memdesc:af37d61b31b7739503489b225fa26e0ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above but uses a type parameter instead of string for more safety if info is available.  <a href="namespaceclass__loader_1_1impl.html#af37d61b31b7739503489b225fa26e0ea">More...</a><br /></td></tr>
<tr class="separator:af37d61b31b7739503489b225fa26e0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd01772d59337d05318c0f3d7ff515d"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/thread/recursive_mutex.html">std::recursive_mutex</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclass__loader_1_1impl.html#a1bd01772d59337d05318c0f3d7ff515d">getLoadedLibraryVectorMutex</a> ()</td></tr>
<tr class="memdesc:a1bd01772d59337d05318c0f3d7ff515d"><td class="mdescLeft">&#160;</td><td class="mdescRight">To provide thread safety, all exposed plugin functions can only be run serially by multiple threads.  <a href="namespaceclass__loader_1_1impl.html#a1bd01772d59337d05318c0f3d7ff515d">More...</a><br /></td></tr>
<tr class="separator:a1bd01772d59337d05318c0f3d7ff515d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d343d597e3269ef95723ec504287bd4"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/thread/recursive_mutex.html">std::recursive_mutex</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclass__loader_1_1impl.html#a8d343d597e3269ef95723ec504287bd4">getPluginBaseToFactoryMapMapMutex</a> ()</td></tr>
<tr class="separator:a8d343d597e3269ef95723ec504287bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9abd6534ecf24bfbc8ad5877f3422e46"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclass__loader_1_1impl.html#a9abd6534ecf24bfbc8ad5877f3422e46">hasANonPurePluginLibraryBeenOpened</a> ()</td></tr>
<tr class="memdesc:a9abd6534ecf24bfbc8ad5877f3422e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if a library containing more than just plugins has been opened by the running process.  <a href="namespaceclass__loader_1_1impl.html#a9abd6534ecf24bfbc8ad5877f3422e46">More...</a><br /></td></tr>
<tr class="separator:a9abd6534ecf24bfbc8ad5877f3422e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7913d109bae3bce71cb784d7e80d3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclass__loader_1_1impl.html#a2d7913d109bae3bce71cb784d7e80d3a">hasANonPurePluginLibraryBeenOpened</a> (bool hasIt)</td></tr>
<tr class="memdesc:a2d7913d109bae3bce71cb784d7e80d3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a flag indicating if a library containing more than just plugins has been opened by the running process.  <a href="namespaceclass__loader_1_1impl.html#a2d7913d109bae3bce71cb784d7e80d3a">More...</a><br /></td></tr>
<tr class="separator:a2d7913d109bae3bce71cb784d7e80d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081cdfb5c59f127182d43478a85a46c4"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename Base &gt; </td></tr>
<tr class="memitem:a081cdfb5c59f127182d43478a85a46c4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclass__loader_1_1impl.html#a081cdfb5c59f127182d43478a85a46c4">registerPlugin</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;class_name, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;base_class_name)</td></tr>
<tr class="memdesc:a081cdfb5c59f127182d43478a85a46c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called by the CLASS_LOADER_REGISTER_CLASS macro in plugin_register_macro.h to register factories. Classes that use that macro will cause this function to be invoked when the library is loaded. The function will create a <a class="el" href="classclass__loader_1_1impl_1_1MetaObject.html" title="The actual factory.">MetaObject</a> (i.e. factory) for the corresponding Derived class and insert it into the appropriate FactoryMap in the global Base-to-FactoryMap map. Note that the passed class_name is the literal class name and not the mangled version.  <a href="namespaceclass__loader_1_1impl.html#a081cdfb5c59f127182d43478a85a46c4">More...</a><br /></td></tr>
<tr class="separator:a081cdfb5c59f127182d43478a85a46c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa59dfb5259515603eb63b584d865d248"><td class="memTemplParams" colspan="2">template&lt;typename Base &gt; </td></tr>
<tr class="memitem:aa59dfb5259515603eb63b584d865d248"><td class="memTemplItemLeft" align="right" valign="top">Base *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclass__loader_1_1impl.html#aa59dfb5259515603eb63b584d865d248">createInstance</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;derived_class_name, <a class="el" href="classclass__loader_1_1ClassLoader.html">ClassLoader</a> *loader)</td></tr>
<tr class="memdesc:aa59dfb5259515603eb63b584d865d248"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creates an instance of a plugin class given the derived name of the class and returns a pointer of the Base class type.  <a href="namespaceclass__loader_1_1impl.html#aa59dfb5259515603eb63b584d865d248">More...</a><br /></td></tr>
<tr class="separator:aa59dfb5259515603eb63b584d865d248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e14331386ce2347a4f4496a7df135d3"><td class="memTemplParams" colspan="2">template&lt;typename Base &gt; </td></tr>
<tr class="memitem:a5e14331386ce2347a4f4496a7df135d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclass__loader_1_1impl.html#a5e14331386ce2347a4f4496a7df135d3">getAvailableClasses</a> (const <a class="el" href="classclass__loader_1_1ClassLoader.html">ClassLoader</a> *loader)</td></tr>
<tr class="memdesc:a5e14331386ce2347a4f4496a7df135d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns all the available <a class="el" href="namespaceclass__loader.html">class_loader</a> in the plugin system that are derived from Base and within scope of the passed <a class="el" href="classclass__loader_1_1ClassLoader.html" title="This class allows loading and unloading of dynamically linked libraries which contain class definitio...">ClassLoader</a>.  <a href="namespaceclass__loader_1_1impl.html#a5e14331386ce2347a4f4496a7df135d3">More...</a><br /></td></tr>
<tr class="separator:a5e14331386ce2347a4f4496a7df135d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c39dcaec786867f179a53609cff06f"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclass__loader_1_1impl.html#a15c39dcaec786867f179a53609cff06f">getAllLibrariesUsedByClassLoader</a> (const <a class="el" href="classclass__loader_1_1ClassLoader.html">ClassLoader</a> *loader)</td></tr>
<tr class="memdesc:a15c39dcaec786867f179a53609cff06f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the names of all libraries in use by a given class loader.  <a href="namespaceclass__loader_1_1impl.html#a15c39dcaec786867f179a53609cff06f">More...</a><br /></td></tr>
<tr class="separator:a15c39dcaec786867f179a53609cff06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf0dfa8641af7cc76a1aad8e636e7748"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclass__loader_1_1impl.html#abf0dfa8641af7cc76a1aad8e636e7748">isLibraryLoaded</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;library_path, const <a class="el" href="classclass__loader_1_1ClassLoader.html">ClassLoader</a> *loader)</td></tr>
<tr class="memdesc:abf0dfa8641af7cc76a1aad8e636e7748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if passed library loaded within scope of a <a class="el" href="classclass__loader_1_1ClassLoader.html" title="This class allows loading and unloading of dynamically linked libraries which contain class definitio...">ClassLoader</a>. The library maybe loaded in memory, but to the class loader it may not be.  <a href="namespaceclass__loader_1_1impl.html#abf0dfa8641af7cc76a1aad8e636e7748">More...</a><br /></td></tr>
<tr class="separator:abf0dfa8641af7cc76a1aad8e636e7748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d8acd5264e07bf52404a711ffba217"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclass__loader_1_1impl.html#a05d8acd5264e07bf52404a711ffba217">isLibraryLoadedByAnybody</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;library_path)</td></tr>
<tr class="memdesc:a05d8acd5264e07bf52404a711ffba217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if passed library has been loaded by ANY <a class="el" href="classclass__loader_1_1ClassLoader.html" title="This class allows loading and unloading of dynamically linked libraries which contain class definitio...">ClassLoader</a>.  <a href="namespaceclass__loader_1_1impl.html#a05d8acd5264e07bf52404a711ffba217">More...</a><br /></td></tr>
<tr class="separator:a05d8acd5264e07bf52404a711ffba217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a884a099078fb910ab57758d09101e6f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclass__loader_1_1impl.html#a884a099078fb910ab57758d09101e6f5">loadLibrary</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;library_path, <a class="el" href="classclass__loader_1_1ClassLoader.html">ClassLoader</a> *loader)</td></tr>
<tr class="memdesc:a884a099078fb910ab57758d09101e6f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a library into memory if it has not already been done so. Attempting to load an already loaded library has no effect.  <a href="namespaceclass__loader_1_1impl.html#a884a099078fb910ab57758d09101e6f5">More...</a><br /></td></tr>
<tr class="separator:a884a099078fb910ab57758d09101e6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b3be4a85df90458eff408a7a5dbfac7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclass__loader_1_1impl.html#a1b3be4a85df90458eff408a7a5dbfac7">unloadLibrary</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;library_path, <a class="el" href="classclass__loader_1_1ClassLoader.html">ClassLoader</a> *loader)</td></tr>
<tr class="memdesc:a1b3be4a85df90458eff408a7a5dbfac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unloads a library if it loaded in memory and cleans up its corresponding class factories. If it is not loaded, the function has no effect.  <a href="namespaceclass__loader_1_1impl.html#a1b3be4a85df90458eff408a7a5dbfac7">More...</a><br /></td></tr>
<tr class="separator:a1b3be4a85df90458eff408a7a5dbfac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a7328617dde009449255ddb0b44edb815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7328617dde009449255ddb0b44edb815">&#9670;&nbsp;</a></span>LibraryPath</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> <a class="el" href="namespaceclass__loader_1_1impl.html#a7328617dde009449255ddb0b44edb815">class_loader::impl::LibraryPath</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a96af38012f86e99c92eccb04b109ce2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96af38012f86e99c92eccb04b109ce2f">&#9670;&nbsp;</a></span>ClassName</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> <a class="el" href="namespaceclass__loader_1_1impl.html#a96af38012f86e99c92eccb04b109ce2f">class_loader::impl::ClassName</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a105d0e92ba543a5c20d57757504df487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105d0e92ba543a5c20d57757504df487">&#9670;&nbsp;</a></span>BaseClassName</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> <a class="el" href="namespaceclass__loader_1_1impl.html#a105d0e92ba543a5c20d57757504df487">class_loader::impl::BaseClassName</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afc173a86072f3fa3e5d08b5770669797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc173a86072f3fa3e5d08b5770669797">&#9670;&nbsp;</a></span>FactoryMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="elRef" href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a>&lt;<a class="el" href="namespaceclass__loader_1_1impl.html#a96af38012f86e99c92eccb04b109ce2f">ClassName</a>, <a class="el" href="classclass__loader_1_1impl_1_1AbstractMetaObjectBase.html">impl::AbstractMetaObjectBase</a> *&gt; <a class="el" href="namespaceclass__loader_1_1impl.html#afc173a86072f3fa3e5d08b5770669797">class_loader::impl::FactoryMap</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7afa94e8c25834e59acf083c28088ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7afa94e8c25834e59acf083c28088ede">&#9670;&nbsp;</a></span>BaseToFactoryMapMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="elRef" href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a>&lt;<a class="el" href="namespaceclass__loader_1_1impl.html#a105d0e92ba543a5c20d57757504df487">BaseClassName</a>, <a class="el" href="namespaceclass__loader_1_1impl.html#afc173a86072f3fa3e5d08b5770669797">FactoryMap</a>&gt; <a class="el" href="namespaceclass__loader_1_1impl.html#a7afa94e8c25834e59acf083c28088ede">class_loader::impl::BaseToFactoryMapMap</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac4a6cbd24201c8b499b1d93f2671009e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4a6cbd24201c8b499b1d93f2671009e">&#9670;&nbsp;</a></span>LibraryPair</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt;<a class="el" href="namespaceclass__loader_1_1impl.html#a7328617dde009449255ddb0b44edb815">LibraryPath</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt;rcpputils::SharedLibrary&gt; &gt; <a class="el" href="namespaceclass__loader_1_1impl.html#ac4a6cbd24201c8b499b1d93f2671009e">class_loader::impl::LibraryPair</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a06d7ccf49e0603ddcd6bfbdfdc35cc4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06d7ccf49e0603ddcd6bfbdfdc35cc4c">&#9670;&nbsp;</a></span>LibraryVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="el" href="namespaceclass__loader_1_1impl.html#ac4a6cbd24201c8b499b1d93f2671009e">LibraryPair</a>&gt; <a class="el" href="namespaceclass__loader_1_1impl.html#a06d7ccf49e0603ddcd6bfbdfdc35cc4c">class_loader::impl::LibraryVector</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a63ddd9a3d4e9adcd29caf29a543b6b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ddd9a3d4e9adcd29caf29a543b6b34">&#9670;&nbsp;</a></span>MetaObjectVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="el" href="classclass__loader_1_1impl_1_1AbstractMetaObjectBase.html">AbstractMetaObjectBase</a> *&gt; <a class="el" href="namespaceclass__loader_1_1impl.html#a63ddd9a3d4e9adcd29caf29a543b6b34">class_loader::impl::MetaObjectVector</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a080ab7b268d248563c4c0529d835ca51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a080ab7b268d248563c4c0529d835ca51">&#9670;&nbsp;</a></span>printDebugInfoToScreen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void class_loader::impl::printDebugInfoToScreen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a84f080d328f070fe05598ab4fc0f76fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84f080d328f070fe05598ab4fc0f76fe">&#9670;&nbsp;</a></span>getGlobalPluginBaseToFactoryMapMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceclass__loader_1_1impl.html#a7afa94e8c25834e59acf083c28088ede">BaseToFactoryMapMap</a>&amp; class_loader::impl::getGlobalPluginBaseToFactoryMapMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a handle to a global data structure that holds a map of base class names (Base class describes plugin interface) to a FactoryMap which holds the factories for the various different concrete classes that can be instantiated. Note that the Base class is NOT THE LITERAL CLASSNAME, but rather the result of typeid(Base).name() which sometimes is the literal class name (as on Windows) but is often in mangled form (as on Linux). </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the global base to factory map </dd></dl>

</div>
</div>
<a id="abc6122c8f9364a1237332ef2e4e77383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc6122c8f9364a1237332ef2e4e77383">&#9670;&nbsp;</a></span>getLoadedLibraryVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceclass__loader_1_1impl.html#a06d7ccf49e0603ddcd6bfbdfdc35cc4c">LibraryVector</a>&amp; class_loader::impl::getLoadedLibraryVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a handle to a list of open libraries in the form of LibraryPairs which encode the library path+name and the handle to the underlying shared library. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the global vector that tracks loaded libraries </dd></dl>

</div>
</div>
<a id="a31028710d744f7653b2b617b8cfd4c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31028710d744f7653b2b617b8cfd4c07">&#9670;&nbsp;</a></span>getCurrentlyLoadingLibraryName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> class_loader::impl::getCurrentlyLoadingLibraryName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When a library is being loaded, in order for factories to know which library they are being associated with, they use this function to query which library is being loaded. </p>
<dl class="section return"><dt>Returns</dt><dd>The currently set loading library name as a string </dd></dl>

</div>
</div>
<a id="a62601227903ac75bfda5a3c6052d88b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62601227903ac75bfda5a3c6052d88b4">&#9670;&nbsp;</a></span>setCurrentlyLoadingLibraryName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void class_loader::impl::setCurrentlyLoadingLibraryName </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>library_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When a library is being loaded, in order for factories to know which library they are being associated with, this function is called to set the name of the library currently being loaded. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">library_name</td><td>- The name of library that is being loaded currently </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af34c1ab776cc37bc90b95e3d3c81e5e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af34c1ab776cc37bc90b95e3d3c81e5e2">&#9670;&nbsp;</a></span>getCurrentlyActiveClassLoader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclass__loader_1_1ClassLoader.html">ClassLoader</a>* class_loader::impl::getCurrentlyActiveClassLoader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the <a class="el" href="classclass__loader_1_1ClassLoader.html" title="This class allows loading and unloading of dynamically linked libraries which contain class definitio...">ClassLoader</a> currently in scope which used when a library is being loaded. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the currently active <a class="el" href="classclass__loader_1_1ClassLoader.html" title="This class allows loading and unloading of dynamically linked libraries which contain class definitio...">ClassLoader</a>. </dd></dl>

</div>
</div>
<a id="a47895c05ab9430669905ae74f7a8957d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47895c05ab9430669905ae74f7a8957d">&#9670;&nbsp;</a></span>setCurrentlyActiveClassLoader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void class_loader::impl::setCurrentlyActiveClassLoader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclass__loader_1_1ClassLoader.html">ClassLoader</a> *&#160;</td>
          <td class="paramname"><em>loader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the <a class="el" href="classclass__loader_1_1ClassLoader.html" title="This class allows loading and unloading of dynamically linked libraries which contain class definitio...">ClassLoader</a> currently in scope which used when a library is being loaded. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loader</td><td>- pointer to the currently active <a class="el" href="classclass__loader_1_1ClassLoader.html" title="This class allows loading and unloading of dynamically linked libraries which contain class definitio...">ClassLoader</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80a2d4ea55307d1086b2c4907ab78586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80a2d4ea55307d1086b2c4907ab78586">&#9670;&nbsp;</a></span>getFactoryMapForBaseClass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceclass__loader_1_1impl.html#afc173a86072f3fa3e5d08b5770669797">FactoryMap</a>&amp; class_loader::impl::getFactoryMapForBaseClass </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>typeid_base_class_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function extracts a reference to the FactoryMap for appropriate base class out of the global plugin base to factory map. This function should be used by functions in this namespace that need to access the various factories so as to make sure the right key is generated to index into the global map. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the FactoryMap contained within the global Base-to-FactoryMap map. </dd></dl>

</div>
</div>
<a id="af37d61b31b7739503489b225fa26e0ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af37d61b31b7739503489b225fa26e0ea">&#9670;&nbsp;</a></span>getFactoryMapForBaseClass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceclass__loader_1_1impl.html#afc173a86072f3fa3e5d08b5770669797">FactoryMap</a>&amp; class_loader::impl::getFactoryMapForBaseClass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as above but uses a type parameter instead of string for more safety if info is available. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the FactoryMap contained within the global Base-to-FactoryMap map. </dd></dl>

</div>
</div>
<a id="a1bd01772d59337d05318c0f3d7ff515d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bd01772d59337d05318c0f3d7ff515d">&#9670;&nbsp;</a></span>getLoadedLibraryVectorMutex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/thread/recursive_mutex.html">std::recursive_mutex</a>&amp; class_loader::impl::getLoadedLibraryVectorMutex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To provide thread safety, all exposed plugin functions can only be run serially by multiple threads. </p>
<p>This is implemented by using critical sections enforced by a single mutex which is locked and released with the following two functions.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the global mutex </dd></dl>

</div>
</div>
<a id="a8d343d597e3269ef95723ec504287bd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d343d597e3269ef95723ec504287bd4">&#9670;&nbsp;</a></span>getPluginBaseToFactoryMapMapMutex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/thread/recursive_mutex.html">std::recursive_mutex</a>&amp; class_loader::impl::getPluginBaseToFactoryMapMapMutex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9abd6534ecf24bfbc8ad5877f3422e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9abd6534ecf24bfbc8ad5877f3422e46">&#9670;&nbsp;</a></span>hasANonPurePluginLibraryBeenOpened() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool class_loader::impl::hasANonPurePluginLibraryBeenOpened </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates if a library containing more than just plugins has been opened by the running process. </p>
<dl class="section return"><dt>Returns</dt><dd>True if a non-pure plugin library has been opened, otherwise false </dd></dl>

</div>
</div>
<a id="a2d7913d109bae3bce71cb784d7e80d3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d7913d109bae3bce71cb784d7e80d3a">&#9670;&nbsp;</a></span>hasANonPurePluginLibraryBeenOpened() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void class_loader::impl::hasANonPurePluginLibraryBeenOpened </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hasIt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a flag indicating if a library containing more than just plugins has been opened by the running process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hasIt</td><td>- The flag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a081cdfb5c59f127182d43478a85a46c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a081cdfb5c59f127182d43478a85a46c4">&#9670;&nbsp;</a></span>registerPlugin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename Base &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void class_loader::impl::registerPlugin </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>class_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>base_class_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called by the CLASS_LOADER_REGISTER_CLASS macro in plugin_register_macro.h to register factories. Classes that use that macro will cause this function to be invoked when the library is loaded. The function will create a <a class="el" href="classclass__loader_1_1impl_1_1MetaObject.html" title="The actual factory.">MetaObject</a> (i.e. factory) for the corresponding Derived class and insert it into the appropriate FactoryMap in the global Base-to-FactoryMap map. Note that the passed class_name is the literal class name and not the mangled version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Derived</td><td>- parameteric type indicating concrete type of plugin </td></tr>
    <tr><td class="paramname">Base</td><td>- parameteric type indicating base type of plugin </td></tr>
    <tr><td class="paramname">class_name</td><td>- the literal name of the class being registered (NOT MANGLED) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa59dfb5259515603eb63b584d865d248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa59dfb5259515603eb63b584d865d248">&#9670;&nbsp;</a></span>createInstance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Base* class_loader::impl::createInstance </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>derived_class_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclass__loader_1_1ClassLoader.html">ClassLoader</a> *&#160;</td>
          <td class="paramname"><em>loader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function creates an instance of a plugin class given the derived name of the class and returns a pointer of the Base class type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">derived_class_name</td><td>- The name of the derived class (unmangled) </td></tr>
    <tr><td class="paramname">loader</td><td>- The <a class="el" href="classclass__loader_1_1ClassLoader.html" title="This class allows loading and unloading of dynamically linked libraries which contain class definitio...">ClassLoader</a> whose scope we are within </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to newly created plugin, note caller is responsible for object destruction </dd></dl>

</div>
</div>
<a id="a5e14331386ce2347a4f4496a7df135d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e14331386ce2347a4f4496a7df135d3">&#9670;&nbsp;</a></span>getAvailableClasses()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&gt; class_loader::impl::getAvailableClasses </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclass__loader_1_1ClassLoader.html">ClassLoader</a> *&#160;</td>
          <td class="paramname"><em>loader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns all the available <a class="el" href="namespaceclass__loader.html">class_loader</a> in the plugin system that are derived from Base and within scope of the passed <a class="el" href="classclass__loader_1_1ClassLoader.html" title="This class allows loading and unloading of dynamically linked libraries which contain class definitio...">ClassLoader</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loader</td><td>- The pointer to the <a class="el" href="classclass__loader_1_1ClassLoader.html" title="This class allows loading and unloading of dynamically linked libraries which contain class definitio...">ClassLoader</a> whose scope we are within, </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of strings where each string is a plugin we can create </dd></dl>

</div>
</div>
<a id="a15c39dcaec786867f179a53609cff06f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15c39dcaec786867f179a53609cff06f">&#9670;&nbsp;</a></span>getAllLibrariesUsedByClassLoader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&gt; class_loader::impl::getAllLibrariesUsedByClassLoader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclass__loader_1_1ClassLoader.html">ClassLoader</a> *&#160;</td>
          <td class="paramname"><em>loader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the names of all libraries in use by a given class loader. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loader</td><td>- The <a class="el" href="classclass__loader_1_1ClassLoader.html" title="This class allows loading and unloading of dynamically linked libraries which contain class definitio...">ClassLoader</a> whose scope we are within </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of strings where each string is the path+name of each library that are within a <a class="el" href="classclass__loader_1_1ClassLoader.html" title="This class allows loading and unloading of dynamically linked libraries which contain class definitio...">ClassLoader</a>'s visible scope </dd></dl>

</div>
</div>
<a id="abf0dfa8641af7cc76a1aad8e636e7748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf0dfa8641af7cc76a1aad8e636e7748">&#9670;&nbsp;</a></span>isLibraryLoaded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool class_loader::impl::isLibraryLoaded </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>library_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclass__loader_1_1ClassLoader.html">ClassLoader</a> *&#160;</td>
          <td class="paramname"><em>loader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates if passed library loaded within scope of a <a class="el" href="classclass__loader_1_1ClassLoader.html" title="This class allows loading and unloading of dynamically linked libraries which contain class definitio...">ClassLoader</a>. The library maybe loaded in memory, but to the class loader it may not be. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">library_path</td><td>- The name of the library we wish to check is open </td></tr>
    <tr><td class="paramname">loader</td><td>- The pointer to the <a class="el" href="classclass__loader_1_1ClassLoader.html" title="This class allows loading and unloading of dynamically linked libraries which contain class definitio...">ClassLoader</a> whose scope we are within </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the library is loaded within loader's scope, else false </dd></dl>

</div>
</div>
<a id="a05d8acd5264e07bf52404a711ffba217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05d8acd5264e07bf52404a711ffba217">&#9670;&nbsp;</a></span>isLibraryLoadedByAnybody()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool class_loader::impl::isLibraryLoadedByAnybody </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>library_path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates if passed library has been loaded by ANY <a class="el" href="classclass__loader_1_1ClassLoader.html" title="This class allows loading and unloading of dynamically linked libraries which contain class definitio...">ClassLoader</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">library_path</td><td>- The name of the library we wish to check is open </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the library is loaded in memory, otherwise false </dd></dl>

</div>
</div>
<a id="a884a099078fb910ab57758d09101e6f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a884a099078fb910ab57758d09101e6f5">&#9670;&nbsp;</a></span>loadLibrary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void class_loader::impl::loadLibrary </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>library_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclass__loader_1_1ClassLoader.html">ClassLoader</a> *&#160;</td>
          <td class="paramname"><em>loader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a library into memory if it has not already been done so. Attempting to load an already loaded library has no effect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">library_path</td><td>- The name of the library to open </td></tr>
    <tr><td class="paramname">loader</td><td>- The pointer to the <a class="el" href="classclass__loader_1_1ClassLoader.html" title="This class allows loading and unloading of dynamically linked libraries which contain class definitio...">ClassLoader</a> whose scope we are within </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b3be4a85df90458eff408a7a5dbfac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b3be4a85df90458eff408a7a5dbfac7">&#9670;&nbsp;</a></span>unloadLibrary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void class_loader::impl::unloadLibrary </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>library_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclass__loader_1_1ClassLoader.html">ClassLoader</a> *&#160;</td>
          <td class="paramname"><em>loader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unloads a library if it loaded in memory and cleans up its corresponding class factories. If it is not loaded, the function has no effect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">library_path</td><td>- The name of the library to open </td></tr>
    <tr><td class="paramname">loader</td><td>- The pointer to the <a class="el" href="classclass__loader_1_1ClassLoader.html" title="This class allows loading and unloading of dynamically linked libraries which contain class definitio...">ClassLoader</a> whose scope we are within </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
