<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rclcpp: rclcpp::Executor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rclcpp
   &#160;<span id="projectnumber">master</span>
   </div>
   <div id="projectbrief">C++ ROS Client Library API</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacerclcpp.html">rclcpp</a></li><li class="navelem"><a class="el" href="classrclcpp_1_1Executor.html">Executor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classrclcpp_1_1Executor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rclcpp::Executor Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Coordinate the order and timing of available communication tasks.  
 <a href="classrclcpp_1_1Executor.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="executor_8hpp_source.html">executor.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for rclcpp::Executor:</div>
<div class="dyncontent">
<div class="center"><img src="classrclcpp_1_1Executor__inherit__graph.png" border="0" usemap="#rclcpp_1_1Executor_inherit__map" alt="Inheritance graph"/></div>
<map name="rclcpp_1_1Executor_inherit__map" id="rclcpp_1_1Executor_inherit__map">
<area shape="rect" title="Coordinate the order and timing of available communication tasks." alt="" coords="5,78,132,105"/>
<area shape="rect" href="classrclcpp_1_1executors_1_1MultiThreadedExecutor.html" title=" " alt="" coords="202,5,375,47"/>
<area shape="rect" href="classrclcpp_1_1executors_1_1SingleThreadedExecutor.html" title="Single&#45;threaded executor implementation." alt="" coords="199,71,379,112"/>
<area shape="rect" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html" title="Static executor implementation." alt="" coords="180,136,397,177"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for rclcpp::Executor:</div>
<div class="dyncontent">
<div class="center"><img src="classrclcpp_1_1Executor__coll__graph.png" border="0" usemap="#rclcpp_1_1Executor_coll__map" alt="Collaboration graph"/></div>
<map name="rclcpp_1_1Executor_coll__map" id="rclcpp_1_1Executor_coll__map">
<area shape="rect" title="Coordinate the order and timing of available communication tasks." alt="" coords="1319,175,1445,201"/>
<area shape="rect" href="http://en.cppreference.com/w/cpp/container/list.html" title=" " alt="" coords="835,5,1093,61"/>
<area shape="rect" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html" title=" " alt="" coords="877,86,1051,127"/>
<area shape="rect" href="http://en.cppreference.com/w/cpp/thread/mutex.html" title=" " alt="" coords="918,152,1010,179"/>
<area shape="rect" href="http://docs.ros2.org/foxy/api/rcl/structrcl__guard__condition__t.html" title=" " alt="" coords="509,297,671,324"/>
<area shape="rect" href="http://docs.ros2.org/foxy/api/rcl/structrcl__wait__set__t.html" title=" " alt="" coords="908,203,1020,229"/>
<area shape="rect" href="http://docs.ros2.org/foxy/api/rcl/structrcl__context__t.html" title=" " alt="" coords="301,297,408,324"/>
<area shape="rect" href="http://docs.ros2.org/foxy/api/rcl/structrcl__arguments__t.html" title=" " alt="" coords="5,297,132,324"/>
<area shape="rect" href="http://en.cppreference.com/w/cpp/container/list.html" title=" " alt="" coords="879,377,1049,418"/>
<area shape="rect" href="http://docs.ros2.org/foxy/api/rcl/structrcl__event__t.html" title=" " alt="" coords="543,28,637,55"/>
<area shape="rect" href="http://docs.ros2.org/foxy/api/rcl/structrcl__subscription__t.html" title=" " alt="" coords="522,79,658,105"/>
<area shape="rect" href="http://docs.ros2.org/foxy/api/rcl/structrcl__service__t.html" title=" " alt="" coords="538,129,642,156"/>
<area shape="rect" href="http://docs.ros2.org/foxy/api/rcl/structrcl__client__t.html" title=" " alt="" coords="543,180,637,207"/>
<area shape="rect" href="http://docs.ros2.org/foxy/api/rcl/structrcl__timer__t.html" title=" " alt="" coords="544,231,636,257"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3d28d13a7233751c9b7b023528f10228"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a3d28d13a7233751c9b7b023528f10228">Executor</a> (const <a class="el" href="structrclcpp_1_1ExecutorOptions.html">rclcpp::ExecutorOptions</a> &amp;options=<a class="el" href="structrclcpp_1_1ExecutorOptions.html">rclcpp::ExecutorOptions</a>())</td></tr>
<tr class="memdesc:a3d28d13a7233751c9b7b023528f10228"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classrclcpp_1_1Executor.html#a3d28d13a7233751c9b7b023528f10228">More...</a><br /></td></tr>
<tr class="separator:a3d28d13a7233751c9b7b023528f10228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946f5bfe58cb0ee5f52a98455248ed66"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a946f5bfe58cb0ee5f52a98455248ed66">~Executor</a> ()</td></tr>
<tr class="memdesc:a946f5bfe58cb0ee5f52a98455248ed66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor.  <a href="classrclcpp_1_1Executor.html#a946f5bfe58cb0ee5f52a98455248ed66">More...</a><br /></td></tr>
<tr class="separator:a946f5bfe58cb0ee5f52a98455248ed66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad096fec6846af2169ee97cd2d23e96ca"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#ad096fec6846af2169ee97cd2d23e96ca">spin</a> ()=0</td></tr>
<tr class="memdesc:ad096fec6846af2169ee97cd2d23e96ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do work periodically as it becomes available to us. Blocking call, may block indefinitely.  <a href="classrclcpp_1_1Executor.html#ad096fec6846af2169ee97cd2d23e96ca">More...</a><br /></td></tr>
<tr class="separator:ad096fec6846af2169ee97cd2d23e96ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f9649e4c2f3593c930f4d191e7e208"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a53f9649e4c2f3593c930f4d191e7e208">add_node</a> (rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node_ptr, bool notify=true)</td></tr>
<tr class="memdesc:a53f9649e4c2f3593c930f4d191e7e208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a node to the executor.  <a href="classrclcpp_1_1Executor.html#a53f9649e4c2f3593c930f4d191e7e208">More...</a><br /></td></tr>
<tr class="separator:a53f9649e4c2f3593c930f4d191e7e208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a2b87b3a60d3fd8525d18879cec14c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a83a2b87b3a60d3fd8525d18879cec14c">add_node</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; <a class="el" href="classrclcpp_1_1Node.html">rclcpp::Node</a> &gt; node_ptr, bool notify=true)</td></tr>
<tr class="memdesc:a83a2b87b3a60d3fd8525d18879cec14c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function which takes <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a> and forwards NodeBaseInterface.  <a href="classrclcpp_1_1Executor.html#a83a2b87b3a60d3fd8525d18879cec14c">More...</a><br /></td></tr>
<tr class="separator:a83a2b87b3a60d3fd8525d18879cec14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a660424725a58fc412fac8e86191b1f61"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a660424725a58fc412fac8e86191b1f61">remove_node</a> (rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node_ptr, bool notify=true)</td></tr>
<tr class="memdesc:a660424725a58fc412fac8e86191b1f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a node from the executor.  <a href="classrclcpp_1_1Executor.html#a660424725a58fc412fac8e86191b1f61">More...</a><br /></td></tr>
<tr class="separator:a660424725a58fc412fac8e86191b1f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0543bf6a85ae11a042cef13077ab364"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#ae0543bf6a85ae11a042cef13077ab364">remove_node</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; <a class="el" href="classrclcpp_1_1Node.html">rclcpp::Node</a> &gt; node_ptr, bool notify=true)</td></tr>
<tr class="memdesc:ae0543bf6a85ae11a042cef13077ab364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function which takes <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a> and forwards NodeBaseInterface.  <a href="classrclcpp_1_1Executor.html#ae0543bf6a85ae11a042cef13077ab364">More...</a><br /></td></tr>
<tr class="separator:ae0543bf6a85ae11a042cef13077ab364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af09dd5b81cc174fd7029fab65a726db9"><td class="memTemplParams" colspan="2">template&lt;typename RepT  = int64_t, typename T  = std::milli&gt; </td></tr>
<tr class="memitem:af09dd5b81cc174fd7029fab65a726db9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#af09dd5b81cc174fd7029fab65a726db9">spin_node_once</a> (rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node, <a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::duration</a>&lt; RepT, T &gt; timeout=<a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::duration</a>&lt; RepT, T &gt;(-1))</td></tr>
<tr class="memdesc:af09dd5b81cc174fd7029fab65a726db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a node to executor, execute the next available unit of work, and remove the node.  <a href="classrclcpp_1_1Executor.html#af09dd5b81cc174fd7029fab65a726db9">More...</a><br /></td></tr>
<tr class="separator:af09dd5b81cc174fd7029fab65a726db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9791fd5812f06add439c9cca86d6226b"><td class="memTemplParams" colspan="2">template&lt;typename NodeT  = rclcpp::Node, typename RepT  = int64_t, typename T  = std::milli&gt; </td></tr>
<tr class="memitem:a9791fd5812f06add439c9cca86d6226b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a9791fd5812f06add439c9cca86d6226b">spin_node_once</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; NodeT &gt; node, <a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::duration</a>&lt; RepT, T &gt; timeout=<a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::duration</a>&lt; RepT, T &gt;(-1))</td></tr>
<tr class="memdesc:a9791fd5812f06add439c9cca86d6226b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function which takes <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a> and forwards NodeBaseInterface.  <a href="classrclcpp_1_1Executor.html#a9791fd5812f06add439c9cca86d6226b">More...</a><br /></td></tr>
<tr class="separator:a9791fd5812f06add439c9cca86d6226b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49780b2217485638b0d7be720062e630"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a49780b2217485638b0d7be720062e630">spin_node_some</a> (rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node)</td></tr>
<tr class="memdesc:a49780b2217485638b0d7be720062e630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a node, complete all immediately available work, and remove the node.  <a href="classrclcpp_1_1Executor.html#a49780b2217485638b0d7be720062e630">More...</a><br /></td></tr>
<tr class="separator:a49780b2217485638b0d7be720062e630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8f89d67464b75cfc63f1ddf56f8850"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a9c8f89d67464b75cfc63f1ddf56f8850">spin_node_some</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; <a class="el" href="classrclcpp_1_1Node.html">rclcpp::Node</a> &gt; node)</td></tr>
<tr class="memdesc:a9c8f89d67464b75cfc63f1ddf56f8850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function which takes <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a> and forwards NodeBaseInterface.  <a href="classrclcpp_1_1Executor.html#a9c8f89d67464b75cfc63f1ddf56f8850">More...</a><br /></td></tr>
<tr class="separator:a9c8f89d67464b75cfc63f1ddf56f8850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae821cd4cf1040fe2da521fb19a458fa1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#ae821cd4cf1040fe2da521fb19a458fa1">spin_some</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::nanoseconds</a> max_duration=<a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::nanoseconds</a>(0))</td></tr>
<tr class="memdesc:ae821cd4cf1040fe2da521fb19a458fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete all available queued work without blocking.  <a href="classrclcpp_1_1Executor.html#ae821cd4cf1040fe2da521fb19a458fa1">More...</a><br /></td></tr>
<tr class="separator:ae821cd4cf1040fe2da521fb19a458fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4abb57eea7e1b6c95acc0e7abff62b2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#ae4abb57eea7e1b6c95acc0e7abff62b2">spin_once</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::nanoseconds</a> timeout=<a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::nanoseconds</a>(-1))</td></tr>
<tr class="separator:ae4abb57eea7e1b6c95acc0e7abff62b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484f01fbbbdc2604f349586d2b2f6830"><td class="memTemplParams" colspan="2">template&lt;typename ResponseT , typename TimeRepT  = int64_t, typename TimeT  = std::milli&gt; </td></tr>
<tr class="memitem:a484f01fbbbdc2604f349586d2b2f6830"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacerclcpp.html#a7b4ff5f1e516740d7e11ea97fe6f5532">FutureReturnCode</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a484f01fbbbdc2604f349586d2b2f6830">spin_until_future_complete</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/thread/shared_future.html">std::shared_future</a>&lt; ResponseT &gt; &amp;future, <a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::duration</a>&lt; TimeRepT, TimeT &gt; timeout=<a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::duration</a>&lt; TimeRepT, TimeT &gt;(-1))</td></tr>
<tr class="memdesc:a484f01fbbbdc2604f349586d2b2f6830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spin (blocking) until the future is complete, it times out waiting, or rclcpp is interrupted.  <a href="classrclcpp_1_1Executor.html#a484f01fbbbdc2604f349586d2b2f6830">More...</a><br /></td></tr>
<tr class="separator:a484f01fbbbdc2604f349586d2b2f6830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb21996107bcf4e62f8330e8d201e70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a0fb21996107bcf4e62f8330e8d201e70">cancel</a> ()</td></tr>
<tr class="memdesc:a0fb21996107bcf4e62f8330e8d201e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel any running spin* function, causing it to return.  <a href="classrclcpp_1_1Executor.html#a0fb21996107bcf4e62f8330e8d201e70">More...</a><br /></td></tr>
<tr class="separator:a0fb21996107bcf4e62f8330e8d201e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41ca2b0358c875337ac13a8130987e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#aa41ca2b0358c875337ac13a8130987e9">set_memory_strategy</a> (memory_strategy::MemoryStrategy::SharedPtr memory_strategy)</td></tr>
<tr class="memdesc:aa41ca2b0358c875337ac13a8130987e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support dynamic switching of the memory strategy.  <a href="classrclcpp_1_1Executor.html#aa41ca2b0358c875337ac13a8130987e9">More...</a><br /></td></tr>
<tr class="separator:aa41ca2b0358c875337ac13a8130987e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a562cd027f960258673a737c9e8d3be75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a562cd027f960258673a737c9e8d3be75">spin_node_once_nanoseconds</a> (rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node, <a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::nanoseconds</a> timeout)</td></tr>
<tr class="separator:a562cd027f960258673a737c9e8d3be75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915f4738cf48d6c08851be8264aad58d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a915f4738cf48d6c08851be8264aad58d">execute_any_executable</a> (<a class="el" href="structrclcpp_1_1AnyExecutable.html">AnyExecutable</a> &amp;any_exec)</td></tr>
<tr class="memdesc:a915f4738cf48d6c08851be8264aad58d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the next available executable and do the work associated with it.  <a href="classrclcpp_1_1Executor.html#a915f4738cf48d6c08851be8264aad58d">More...</a><br /></td></tr>
<tr class="separator:a915f4738cf48d6c08851be8264aad58d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af211465e15ae5b13bac0893ef9e0ed4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#af211465e15ae5b13bac0893ef9e0ed4e">wait_for_work</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::nanoseconds</a> timeout=<a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::nanoseconds</a>(-1))</td></tr>
<tr class="separator:af211465e15ae5b13bac0893ef9e0ed4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac865aeb892b5bf2a585bcdff1ed9fe00"><td class="memItemLeft" align="right" valign="top">rclcpp::node_interfaces::NodeBaseInterface::SharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#ac865aeb892b5bf2a585bcdff1ed9fe00">get_node_by_group</a> (rclcpp::CallbackGroup::SharedPtr group)</td></tr>
<tr class="separator:ac865aeb892b5bf2a585bcdff1ed9fe00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06baded5884fc91e6d36ab676f0b7fc3"><td class="memItemLeft" align="right" valign="top">rclcpp::CallbackGroup::SharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a06baded5884fc91e6d36ab676f0b7fc3">get_group_by_timer</a> (rclcpp::TimerBase::SharedPtr timer)</td></tr>
<tr class="separator:a06baded5884fc91e6d36ab676f0b7fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3c92aec4730186388701398c84263b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#aad3c92aec4730186388701398c84263b">get_next_ready_executable</a> (<a class="el" href="structrclcpp_1_1AnyExecutable.html">AnyExecutable</a> &amp;any_executable)</td></tr>
<tr class="separator:aad3c92aec4730186388701398c84263b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b530d7459b579ca22044a5e7a37a50"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a63b530d7459b579ca22044a5e7a37a50">get_next_executable</a> (<a class="el" href="structrclcpp_1_1AnyExecutable.html">AnyExecutable</a> &amp;any_executable, <a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::nanoseconds</a> timeout=<a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::nanoseconds</a>(-1))</td></tr>
<tr class="separator:a63b530d7459b579ca22044a5e7a37a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a3f825d7a6d22eb8a6c2974d89d8bcebc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a3f825d7a6d22eb8a6c2974d89d8bcebc">execute_subscription</a> (rclcpp::SubscriptionBase::SharedPtr subscription)</td></tr>
<tr class="separator:a3f825d7a6d22eb8a6c2974d89d8bcebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e62a3a7c60ab1569659aeaa47886b7e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a6e62a3a7c60ab1569659aeaa47886b7e">execute_timer</a> (rclcpp::TimerBase::SharedPtr timer)</td></tr>
<tr class="separator:a6e62a3a7c60ab1569659aeaa47886b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2e10441f4ad3c566c84f44e8d697d8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a8c2e10441f4ad3c566c84f44e8d697d8">execute_service</a> (rclcpp::ServiceBase::SharedPtr service)</td></tr>
<tr class="separator:a8c2e10441f4ad3c566c84f44e8d697d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a488790ad5eccaf4a7dc2b6eab6862147"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a488790ad5eccaf4a7dc2b6eab6862147">execute_client</a> (rclcpp::ClientBase::SharedPtr client)</td></tr>
<tr class="separator:a488790ad5eccaf4a7dc2b6eab6862147"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:afe759d8451caa0752e2209bb0863dbcd"><td class="memItemLeft" align="right" valign="top">std::atomic_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#afe759d8451caa0752e2209bb0863dbcd">spinning</a></td></tr>
<tr class="memdesc:afe759d8451caa0752e2209bb0863dbcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spinning state, used to prevent multi threaded calls to spin and to cancel blocking spins.  <a href="classrclcpp_1_1Executor.html#afe759d8451caa0752e2209bb0863dbcd">More...</a><br /></td></tr>
<tr class="separator:afe759d8451caa0752e2209bb0863dbcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08ff5546ad531eae007ce653bf1b163"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://docs.ros2.org/foxy/api/rcl/structrcl__guard__condition__t.html">rcl_guard_condition_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#af08ff5546ad531eae007ce653bf1b163">interrupt_guard_condition_</a> = rcl_get_zero_initialized_guard_condition()</td></tr>
<tr class="memdesc:af08ff5546ad531eae007ce653bf1b163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guard condition for signaling the rmw layer to wake up for special events.  <a href="classrclcpp_1_1Executor.html#af08ff5546ad531eae007ce653bf1b163">More...</a><br /></td></tr>
<tr class="separator:af08ff5546ad531eae007ce653bf1b163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07bb6ff536c37f44a5c05f3ba5c300ee"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://docs.ros2.org/foxy/api/rcl/structrcl__wait__set__t.html">rcl_wait_set_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a07bb6ff536c37f44a5c05f3ba5c300ee">wait_set_</a> = rcl_get_zero_initialized_wait_set()</td></tr>
<tr class="memdesc:a07bb6ff536c37f44a5c05f3ba5c300ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait set for managing entities that the rmw layer waits on.  <a href="classrclcpp_1_1Executor.html#a07bb6ff536c37f44a5c05f3ba5c300ee">More...</a><br /></td></tr>
<tr class="separator:a07bb6ff536c37f44a5c05f3ba5c300ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74228f8c4ef5138223eed4ed0d2559f"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/thread/mutex.html">std::mutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#ab74228f8c4ef5138223eed4ed0d2559f">memory_strategy_mutex_</a></td></tr>
<tr class="separator:ab74228f8c4ef5138223eed4ed0d2559f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d31b355624a35e3a806e5533084f78"><td class="memItemLeft" align="right" valign="top">memory_strategy::MemoryStrategy::SharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#aa1d31b355624a35e3a806e5533084f78">memory_strategy_</a></td></tr>
<tr class="memdesc:aa1d31b355624a35e3a806e5533084f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">The memory strategy: an interface for handling user-defined memory allocation strategies.  <a href="classrclcpp_1_1Executor.html#aa1d31b355624a35e3a806e5533084f78">More...</a><br /></td></tr>
<tr class="separator:aa1d31b355624a35e3a806e5533084f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb729b9e8a7e925e08fb0a9d6244282"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; <a class="el" href="classrclcpp_1_1Context.html">rclcpp::Context</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a9cb729b9e8a7e925e08fb0a9d6244282">context_</a></td></tr>
<tr class="memdesc:a9cb729b9e8a7e925e08fb0a9d6244282"><td class="mdescLeft">&#160;</td><td class="mdescRight">The context associated with this executor.  <a href="classrclcpp_1_1Executor.html#a9cb729b9e8a7e925e08fb0a9d6244282">More...</a><br /></td></tr>
<tr class="separator:a9cb729b9e8a7e925e08fb0a9d6244282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83944e8c14cee34664cf40d1bc29e058"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/list.html">std::list</a>&lt; rclcpp::node_interfaces::NodeBaseInterface::WeakPtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a83944e8c14cee34664cf40d1bc29e058">weak_nodes_</a></td></tr>
<tr class="separator:a83944e8c14cee34664cf40d1bc29e058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9be900933db041b3b72f02d043a6c5e"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/list.html">std::list</a>&lt; const <a class="elRef" href="http://docs.ros2.org/foxy/api/rcl/structrcl__guard__condition__t.html">rcl_guard_condition_t</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#ad9be900933db041b3b72f02d043a6c5e">guard_conditions_</a></td></tr>
<tr class="separator:ad9be900933db041b3b72f02d043a6c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Coordinate the order and timing of available communication tasks. </p>
<p><a class="el" href="classrclcpp_1_1Executor.html" title="Coordinate the order and timing of available communication tasks.">Executor</a> provides spin functions (including spin_node_once and spin_some). It coordinates the nodes and callback groups by looking for available work and completing it, based on the threading or concurrency scheme provided by the subclass implementation. An example of available work is executing a subscription callback, or a timer callback. The executor structure allows for a decoupling of the communication graph and the execution model. See SingleThreadedExecutor and MultiThreadedExecutor for examples of execution paradigms. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3d28d13a7233751c9b7b023528f10228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d28d13a7233751c9b7b023528f10228">&#9670;&nbsp;</a></span>Executor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rclcpp::Executor::Executor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrclcpp_1_1ExecutorOptions.html">rclcpp::ExecutorOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structrclcpp_1_1ExecutorOptions.html">rclcpp::ExecutorOptions</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Options used to configure the executor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a946f5bfe58cb0ee5f52a98455248ed66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a946f5bfe58cb0ee5f52a98455248ed66">&#9670;&nbsp;</a></span>~Executor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual rclcpp::Executor::~Executor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad096fec6846af2169ee97cd2d23e96ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad096fec6846af2169ee97cd2d23e96ca">&#9670;&nbsp;</a></span>spin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rclcpp::Executor::spin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do work periodically as it becomes available to us. Blocking call, may block indefinitely. </p>

<p>Implemented in <a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#a1cec9027c4c69e49a6e15398f01b7c47">rclcpp::executors::StaticSingleThreadedExecutor</a>, <a class="el" href="classrclcpp_1_1executors_1_1MultiThreadedExecutor.html#a7f14b56a547fb58ebe9aa49fc07a83cf">rclcpp::executors::MultiThreadedExecutor</a>, and <a class="el" href="classrclcpp_1_1executors_1_1SingleThreadedExecutor.html#a77218fef5f77a2084a251e7b885fd3d0">rclcpp::executors::SingleThreadedExecutor</a>.</p>

</div>
</div>
<a id="a53f9649e4c2f3593c930f4d191e7e208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53f9649e4c2f3593c930f4d191e7e208">&#9670;&nbsp;</a></span>add_node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rclcpp::Executor::add_node </td>
          <td>(</td>
          <td class="paramtype">rclcpp::node_interfaces::NodeBaseInterface::SharedPtr&#160;</td>
          <td class="paramname"><em>node_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>notify</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a node to the executor. </p>
<p>An executor can have zero or more nodes which provide work during <code>spin</code> functions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_ptr</td><td>Shared pointer to the node to be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">notify</td><td>True to trigger the interrupt guard condition during this function. If the executor is blocked at the rmw layer while waiting for work and it is notified that a new node was added, it will wake up. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#a5c04102c89554658c021dceb1555af2f">rclcpp::executors::StaticSingleThreadedExecutor</a>.</p>

</div>
</div>
<a id="a83a2b87b3a60d3fd8525d18879cec14c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83a2b87b3a60d3fd8525d18879cec14c">&#9670;&nbsp;</a></span>add_node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rclcpp::Executor::add_node </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; <a class="el" href="classrclcpp_1_1Node.html">rclcpp::Node</a> &gt;&#160;</td>
          <td class="paramname"><em>node_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>notify</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function which takes <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a> and forwards NodeBaseInterface. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1Executor.html#a53f9649e4c2f3593c930f4d191e7e208" title="Add a node to the executor.">rclcpp::Executor::add_node</a> </dd></dl>

<p>Reimplemented in <a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#acc40d425a0b14000dcec22b93a5ba194">rclcpp::executors::StaticSingleThreadedExecutor</a>.</p>

</div>
</div>
<a id="a660424725a58fc412fac8e86191b1f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a660424725a58fc412fac8e86191b1f61">&#9670;&nbsp;</a></span>remove_node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rclcpp::Executor::remove_node </td>
          <td>(</td>
          <td class="paramtype">rclcpp::node_interfaces::NodeBaseInterface::SharedPtr&#160;</td>
          <td class="paramname"><em>node_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>notify</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a node from the executor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_ptr</td><td>Shared pointer to the node to remove. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">notify</td><td>True to trigger the interrupt guard condition and wake up the executor. This is useful if the last node was removed from the executor while the executor was blocked waiting for work in another thread, because otherwise the executor would never be notified. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#ad0c159ea2f81661d52b06b1e8a4edbd0">rclcpp::executors::StaticSingleThreadedExecutor</a>.</p>

</div>
</div>
<a id="ae0543bf6a85ae11a042cef13077ab364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0543bf6a85ae11a042cef13077ab364">&#9670;&nbsp;</a></span>remove_node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rclcpp::Executor::remove_node </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; <a class="el" href="classrclcpp_1_1Node.html">rclcpp::Node</a> &gt;&#160;</td>
          <td class="paramname"><em>node_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>notify</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function which takes <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a> and forwards NodeBaseInterface. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrclcpp_1_1Executor.html#a660424725a58fc412fac8e86191b1f61" title="Remove a node from the executor.">rclcpp::Executor::remove_node</a> </dd></dl>

<p>Reimplemented in <a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#a9578b4ab98dda3b6493d35b87c302af4">rclcpp::executors::StaticSingleThreadedExecutor</a>.</p>

</div>
</div>
<a id="af09dd5b81cc174fd7029fab65a726db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af09dd5b81cc174fd7029fab65a726db9">&#9670;&nbsp;</a></span>spin_node_once() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RepT  = int64_t, typename T  = std::milli&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::Executor::spin_node_once </td>
          <td>(</td>
          <td class="paramtype">rclcpp::node_interfaces::NodeBaseInterface::SharedPtr&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::duration</a>&lt; RepT, T &gt;&#160;</td>
          <td class="paramname"><em>timeout</em> = <code><a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::duration</a>&lt;RepT,&#160;T&gt;(-1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a node to executor, execute the next available unit of work, and remove the node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Shared pointer to the node to add. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>How long to wait for work to become available. Negative values cause spin_node_once to block indefinitely (the default behavior). A timeout of 0 causes this function to be non-blocking. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9791fd5812f06add439c9cca86d6226b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9791fd5812f06add439c9cca86d6226b">&#9670;&nbsp;</a></span>spin_node_once() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeT  = rclcpp::Node, typename RepT  = int64_t, typename T  = std::milli&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::Executor::spin_node_once </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; NodeT &gt;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::duration</a>&lt; RepT, T &gt;&#160;</td>
          <td class="paramname"><em>timeout</em> = <code><a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::duration</a>&lt;RepT,&#160;T&gt;(-1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function which takes <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a> and forwards NodeBaseInterface. </p>

</div>
</div>
<a id="a49780b2217485638b0d7be720062e630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49780b2217485638b0d7be720062e630">&#9670;&nbsp;</a></span>spin_node_some() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::Executor::spin_node_some </td>
          <td>(</td>
          <td class="paramtype">rclcpp::node_interfaces::NodeBaseInterface::SharedPtr&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a node, complete all immediately available work, and remove the node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Shared pointer to the node to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c8f89d67464b75cfc63f1ddf56f8850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c8f89d67464b75cfc63f1ddf56f8850">&#9670;&nbsp;</a></span>spin_node_some() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::Executor::spin_node_some </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; <a class="el" href="classrclcpp_1_1Node.html">rclcpp::Node</a> &gt;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function which takes <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a> and forwards NodeBaseInterface. </p>

</div>
</div>
<a id="ae821cd4cf1040fe2da521fb19a458fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae821cd4cf1040fe2da521fb19a458fa1">&#9670;&nbsp;</a></span>spin_some()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rclcpp::Executor::spin_some </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::nanoseconds</a>&#160;</td>
          <td class="paramname"><em>max_duration</em> = <code><a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::nanoseconds</a>(0)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Complete all available queued work without blocking. </p>
<p>This function can be overridden. The default implementation is suitable for a single-threaded model of execution. Adding subscriptions, timers, services, etc. with blocking callbacks will cause this function to block (which may have unintended consequences).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max_duration</td><td>The maximum amount of time to spend executing work, or 0 for no limit. Note that <a class="el" href="classrclcpp_1_1Executor.html#ae821cd4cf1040fe2da521fb19a458fa1" title="Complete all available queued work without blocking.">spin_some()</a> may take longer than this time as it only returns once max_duration has been exceeded. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4abb57eea7e1b6c95acc0e7abff62b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4abb57eea7e1b6c95acc0e7abff62b2">&#9670;&nbsp;</a></span>spin_once()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rclcpp::Executor::spin_once </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::nanoseconds</a>&#160;</td>
          <td class="paramname"><em>timeout</em> = <code><a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::nanoseconds</a>(-1)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a484f01fbbbdc2604f349586d2b2f6830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a484f01fbbbdc2604f349586d2b2f6830">&#9670;&nbsp;</a></span>spin_until_future_complete()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResponseT , typename TimeRepT  = int64_t, typename TimeT  = std::milli&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacerclcpp.html#a7b4ff5f1e516740d7e11ea97fe6f5532">FutureReturnCode</a> rclcpp::Executor::spin_until_future_complete </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/thread/shared_future.html">std::shared_future</a>&lt; ResponseT &gt; &amp;&#160;</td>
          <td class="paramname"><em>future</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::duration</a>&lt; TimeRepT, TimeT &gt;&#160;</td>
          <td class="paramname"><em>timeout</em> = <code><a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::duration</a>&lt;TimeRepT,&#160;TimeT&gt;(-1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Spin (blocking) until the future is complete, it times out waiting, or rclcpp is interrupted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">future</td><td>The future to wait on. If this function returns SUCCESS, the future can be accessed without blocking (though it may still throw an exception). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Optional timeout parameter, which gets passed to <a class="el" href="classrclcpp_1_1Executor.html#af09dd5b81cc174fd7029fab65a726db9" title="Add a node to executor, execute the next available unit of work, and remove the node.">Executor::spin_node_once</a>. <code>-1</code> is block forever, <code>0</code> is non-blocking. If the time spent inside the blocking loop exceeds this timeout, return a TIMEOUT return code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return code, one of <code>SUCCESS</code>, <code>INTERRUPTED</code>, or <code>TIMEOUT</code>. </dd></dl>

</div>
</div>
<a id="a0fb21996107bcf4e62f8330e8d201e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fb21996107bcf4e62f8330e8d201e70">&#9670;&nbsp;</a></span>cancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::Executor::cancel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel any running spin* function, causing it to return. </p>
<p>This function can be called asynchonously from any thread. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="elRef" href="http://en.cppreference.com/w/cpp/error/runtime_error.html">std::runtime_error</a></td><td>if there is an issue triggering the guard condition </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa41ca2b0358c875337ac13a8130987e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa41ca2b0358c875337ac13a8130987e9">&#9670;&nbsp;</a></span>set_memory_strategy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::Executor::set_memory_strategy </td>
          <td>(</td>
          <td class="paramtype">memory_strategy::MemoryStrategy::SharedPtr&#160;</td>
          <td class="paramname"><em>memory_strategy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Support dynamic switching of the memory strategy. </p>
<p>Switching the memory strategy while the executor is spinning in another threading could have unintended consequences. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="namespacerclcpp_1_1memory__strategy.html">memory_strategy</a></td><td>Shared pointer to the memory strategy to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="elRef" href="http://en.cppreference.com/w/cpp/error/runtime_error.html">std::runtime_error</a></td><td>if <a class="el" href="namespacerclcpp_1_1memory__strategy.html">memory_strategy</a> is null </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a562cd027f960258673a737c9e8d3be75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a562cd027f960258673a737c9e8d3be75">&#9670;&nbsp;</a></span>spin_node_once_nanoseconds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::Executor::spin_node_once_nanoseconds </td>
          <td>(</td>
          <td class="paramtype">rclcpp::node_interfaces::NodeBaseInterface::SharedPtr&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::nanoseconds</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a915f4738cf48d6c08851be8264aad58d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a915f4738cf48d6c08851be8264aad58d">&#9670;&nbsp;</a></span>execute_any_executable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::Executor::execute_any_executable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrclcpp_1_1AnyExecutable.html">AnyExecutable</a> &amp;&#160;</td>
          <td class="paramname"><em>any_exec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the next available executable and do the work associated with it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">any_exec</td><td>Union structure that can hold any executable type (timer, subscription, service, client). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="elRef" href="http://en.cppreference.com/w/cpp/error/runtime_error.html">std::runtime_error</a></td><td>if there is an issue triggering the guard condition </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f825d7a6d22eb8a6c2974d89d8bcebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f825d7a6d22eb8a6c2974d89d8bcebc">&#9670;&nbsp;</a></span>execute_subscription()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rclcpp::Executor::execute_subscription </td>
          <td>(</td>
          <td class="paramtype">rclcpp::SubscriptionBase::SharedPtr&#160;</td>
          <td class="paramname"><em>subscription</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e62a3a7c60ab1569659aeaa47886b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e62a3a7c60ab1569659aeaa47886b7e">&#9670;&nbsp;</a></span>execute_timer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rclcpp::Executor::execute_timer </td>
          <td>(</td>
          <td class="paramtype">rclcpp::TimerBase::SharedPtr&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8c2e10441f4ad3c566c84f44e8d697d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c2e10441f4ad3c566c84f44e8d697d8">&#9670;&nbsp;</a></span>execute_service()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rclcpp::Executor::execute_service </td>
          <td>(</td>
          <td class="paramtype">rclcpp::ServiceBase::SharedPtr&#160;</td>
          <td class="paramname"><em>service</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a488790ad5eccaf4a7dc2b6eab6862147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a488790ad5eccaf4a7dc2b6eab6862147">&#9670;&nbsp;</a></span>execute_client()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rclcpp::Executor::execute_client </td>
          <td>(</td>
          <td class="paramtype">rclcpp::ClientBase::SharedPtr&#160;</td>
          <td class="paramname"><em>client</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af211465e15ae5b13bac0893ef9e0ed4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af211465e15ae5b13bac0893ef9e0ed4e">&#9670;&nbsp;</a></span>wait_for_work()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::Executor::wait_for_work </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::nanoseconds</a>&#160;</td>
          <td class="paramname"><em>timeout</em> = <code><a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::nanoseconds</a>(-1)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="elRef" href="http://en.cppreference.com/w/cpp/error/runtime_error.html">std::runtime_error</a></td><td>if the wait set can be cleared </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac865aeb892b5bf2a585bcdff1ed9fe00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac865aeb892b5bf2a585bcdff1ed9fe00">&#9670;&nbsp;</a></span>get_node_by_group()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rclcpp::node_interfaces::NodeBaseInterface::SharedPtr rclcpp::Executor::get_node_by_group </td>
          <td>(</td>
          <td class="paramtype">rclcpp::CallbackGroup::SharedPtr&#160;</td>
          <td class="paramname"><em>group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a06baded5884fc91e6d36ab676f0b7fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06baded5884fc91e6d36ab676f0b7fc3">&#9670;&nbsp;</a></span>get_group_by_timer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rclcpp::CallbackGroup::SharedPtr rclcpp::Executor::get_group_by_timer </td>
          <td>(</td>
          <td class="paramtype">rclcpp::TimerBase::SharedPtr&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aad3c92aec4730186388701398c84263b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad3c92aec4730186388701398c84263b">&#9670;&nbsp;</a></span>get_next_ready_executable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rclcpp::Executor::get_next_ready_executable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrclcpp_1_1AnyExecutable.html">AnyExecutable</a> &amp;&#160;</td>
          <td class="paramname"><em>any_executable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a63b530d7459b579ca22044a5e7a37a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63b530d7459b579ca22044a5e7a37a50">&#9670;&nbsp;</a></span>get_next_executable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rclcpp::Executor::get_next_executable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrclcpp_1_1AnyExecutable.html">AnyExecutable</a> &amp;&#160;</td>
          <td class="paramname"><em>any_executable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::nanoseconds</a>&#160;</td>
          <td class="paramname"><em>timeout</em> = <code><a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::nanoseconds</a>(-1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="afe759d8451caa0752e2209bb0863dbcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe759d8451caa0752e2209bb0863dbcd">&#9670;&nbsp;</a></span>spinning</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic_bool rclcpp::Executor::spinning</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Spinning state, used to prevent multi threaded calls to spin and to cancel blocking spins. </p>

</div>
</div>
<a id="af08ff5546ad531eae007ce653bf1b163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af08ff5546ad531eae007ce653bf1b163">&#9670;&nbsp;</a></span>interrupt_guard_condition_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://docs.ros2.org/foxy/api/rcl/structrcl__guard__condition__t.html">rcl_guard_condition_t</a> rclcpp::Executor::interrupt_guard_condition_ = rcl_get_zero_initialized_guard_condition()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Guard condition for signaling the rmw layer to wake up for special events. </p>

</div>
</div>
<a id="a07bb6ff536c37f44a5c05f3ba5c300ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07bb6ff536c37f44a5c05f3ba5c300ee">&#9670;&nbsp;</a></span>wait_set_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://docs.ros2.org/foxy/api/rcl/structrcl__wait__set__t.html">rcl_wait_set_t</a> rclcpp::Executor::wait_set_ = rcl_get_zero_initialized_wait_set()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait set for managing entities that the rmw layer waits on. </p>

</div>
</div>
<a id="ab74228f8c4ef5138223eed4ed0d2559f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab74228f8c4ef5138223eed4ed0d2559f">&#9670;&nbsp;</a></span>memory_strategy_mutex_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/thread/mutex.html">std::mutex</a> rclcpp::Executor::memory_strategy_mutex_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa1d31b355624a35e3a806e5533084f78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d31b355624a35e3a806e5533084f78">&#9670;&nbsp;</a></span>memory_strategy_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">memory_strategy::MemoryStrategy::SharedPtr rclcpp::Executor::memory_strategy_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The memory strategy: an interface for handling user-defined memory allocation strategies. </p>

</div>
</div>
<a id="a9cb729b9e8a7e925e08fb0a9d6244282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb729b9e8a7e925e08fb0a9d6244282">&#9670;&nbsp;</a></span>context_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt;<a class="el" href="classrclcpp_1_1Context.html">rclcpp::Context</a>&gt; rclcpp::Executor::context_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The context associated with this executor. </p>

</div>
</div>
<a id="a83944e8c14cee34664cf40d1bc29e058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83944e8c14cee34664cf40d1bc29e058">&#9670;&nbsp;</a></span>weak_nodes_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/list.html">std::list</a>&lt;rclcpp::node_interfaces::NodeBaseInterface::WeakPtr&gt; rclcpp::Executor::weak_nodes_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad9be900933db041b3b72f02d043a6c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9be900933db041b3b72f02d043a6c5e">&#9670;&nbsp;</a></span>guard_conditions_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/list.html">std::list</a>&lt;const <a class="elRef" href="http://docs.ros2.org/foxy/api/rcl/structrcl__guard__condition__t.html">rcl_guard_condition_t</a> *&gt; rclcpp::Executor::guard_conditions_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/rclcpp/<a class="el" href="executor_8hpp_source.html">executor.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
