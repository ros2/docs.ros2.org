<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rclcpp: rclcpp::executors::StaticSingleThreadedExecutor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rclcpp
   &#160;<span id="projectnumber">master</span>
   </div>
   <div id="projectbrief">C++ ROS Client Library API</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacerclcpp.html">rclcpp</a></li><li class="navelem"><a class="el" href="namespacerclcpp_1_1executors.html">executors</a></li><li class="navelem"><a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html">StaticSingleThreadedExecutor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rclcpp::executors::StaticSingleThreadedExecutor Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Static executor implementation.  
 <a href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="static__single__threaded__executor_8hpp_source.html">static_single_threaded_executor.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for rclcpp::executors::StaticSingleThreadedExecutor:</div>
<div class="dyncontent">
<div class="center"><img src="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor__inherit__graph.png" border="0" usemap="#rclcpp_1_1executors_1_1StaticSingleThreadedExecutor_inherit__map" alt="Inheritance graph"/></div>
<map name="rclcpp_1_1executors_1_1StaticSingleThreadedExecutor_inherit__map" id="rclcpp_1_1executors_1_1StaticSingleThreadedExecutor_inherit__map">
<area shape="rect" title="Static executor implementation." alt="" coords="5,80,223,121"/>
<area shape="rect" href="classrclcpp_1_1Executor.html" title="Coordinate the order and timing of available communication tasks." alt="" coords="51,5,177,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for rclcpp::executors::StaticSingleThreadedExecutor:</div>
<div class="dyncontent">
<div class="center"><img src="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor__coll__graph.png" border="0" usemap="#rclcpp_1_1executors_1_1StaticSingleThreadedExecutor_coll__map" alt="Collaboration graph"/></div>
<map name="rclcpp_1_1executors_1_1StaticSingleThreadedExecutor_coll__map" id="rclcpp_1_1executors_1_1StaticSingleThreadedExecutor_coll__map">
<area shape="rect" title="Static executor implementation." alt="" coords="1495,167,1712,209"/>
<area shape="rect" href="classrclcpp_1_1Executor.html" title="Coordinate the order and timing of available communication tasks." alt="" coords="1319,175,1445,201"/>
<area shape="rect" href="http://en.cppreference.com/w/cpp/container/list.html" title=" " alt="" coords="835,5,1093,61"/>
<area shape="rect" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html" title=" " alt="" coords="877,86,1051,127"/>
<area shape="rect" href="http://en.cppreference.com/w/cpp/thread/mutex.html" title=" " alt="" coords="918,152,1010,179"/>
<area shape="rect" href="http://docs.ros2.org/foxy/api/rcl/structrcl__guard__condition__t.html" title=" " alt="" coords="509,297,671,324"/>
<area shape="rect" href="http://docs.ros2.org/foxy/api/rcl/structrcl__wait__set__t.html" title=" " alt="" coords="908,203,1020,229"/>
<area shape="rect" href="http://docs.ros2.org/foxy/api/rcl/structrcl__context__t.html" title=" " alt="" coords="301,297,408,324"/>
<area shape="rect" href="http://docs.ros2.org/foxy/api/rcl/structrcl__arguments__t.html" title=" " alt="" coords="5,297,132,324"/>
<area shape="rect" href="http://en.cppreference.com/w/cpp/container/list.html" title=" " alt="" coords="879,377,1049,418"/>
<area shape="rect" href="http://docs.ros2.org/foxy/api/rcl/structrcl__event__t.html" title=" " alt="" coords="543,28,637,55"/>
<area shape="rect" href="http://docs.ros2.org/foxy/api/rcl/structrcl__subscription__t.html" title=" " alt="" coords="522,79,658,105"/>
<area shape="rect" href="http://docs.ros2.org/foxy/api/rcl/structrcl__service__t.html" title=" " alt="" coords="538,129,642,156"/>
<area shape="rect" href="http://docs.ros2.org/foxy/api/rcl/structrcl__client__t.html" title=" " alt="" coords="543,180,637,207"/>
<area shape="rect" href="http://docs.ros2.org/foxy/api/rcl/structrcl__timer__t.html" title=" " alt="" coords="544,231,636,257"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6ee69a543c46f731a74a8d33fe6bf3e5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#a6ee69a543c46f731a74a8d33fe6bf3e5">StaticSingleThreadedExecutor</a> (const <a class="el" href="structrclcpp_1_1ExecutorOptions.html">rclcpp::ExecutorOptions</a> &amp;options=<a class="el" href="structrclcpp_1_1ExecutorOptions.html">rclcpp::ExecutorOptions</a>())</td></tr>
<tr class="memdesc:a6ee69a543c46f731a74a8d33fe6bf3e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. See the default constructor for <a class="el" href="classrclcpp_1_1Executor.html" title="Coordinate the order and timing of available communication tasks.">Executor</a>.  <a href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#a6ee69a543c46f731a74a8d33fe6bf3e5">More...</a><br /></td></tr>
<tr class="separator:a6ee69a543c46f731a74a8d33fe6bf3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfba5ffd5adf68e26137f49a8587ad9e"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#acfba5ffd5adf68e26137f49a8587ad9e">~StaticSingleThreadedExecutor</a> ()</td></tr>
<tr class="memdesc:acfba5ffd5adf68e26137f49a8587ad9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destrcutor.  <a href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#acfba5ffd5adf68e26137f49a8587ad9e">More...</a><br /></td></tr>
<tr class="separator:acfba5ffd5adf68e26137f49a8587ad9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cec9027c4c69e49a6e15398f01b7c47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#a1cec9027c4c69e49a6e15398f01b7c47">spin</a> () override</td></tr>
<tr class="memdesc:a1cec9027c4c69e49a6e15398f01b7c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static executor implementation of spin.  <a href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#a1cec9027c4c69e49a6e15398f01b7c47">More...</a><br /></td></tr>
<tr class="separator:a1cec9027c4c69e49a6e15398f01b7c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c04102c89554658c021dceb1555af2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#a5c04102c89554658c021dceb1555af2f">add_node</a> (rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node_ptr, bool notify=true) override</td></tr>
<tr class="memdesc:a5c04102c89554658c021dceb1555af2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a node to the executor.  <a href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#a5c04102c89554658c021dceb1555af2f">More...</a><br /></td></tr>
<tr class="separator:a5c04102c89554658c021dceb1555af2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc40d425a0b14000dcec22b93a5ba194"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#acc40d425a0b14000dcec22b93a5ba194">add_node</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; <a class="el" href="classrclcpp_1_1Node.html">rclcpp::Node</a> &gt; node_ptr, bool notify=true) override</td></tr>
<tr class="memdesc:acc40d425a0b14000dcec22b93a5ba194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function which takes <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a> and forwards NodeBaseInterface.  <a href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#acc40d425a0b14000dcec22b93a5ba194">More...</a><br /></td></tr>
<tr class="separator:acc40d425a0b14000dcec22b93a5ba194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c159ea2f81661d52b06b1e8a4edbd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#ad0c159ea2f81661d52b06b1e8a4edbd0">remove_node</a> (rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node_ptr, bool notify=true) override</td></tr>
<tr class="memdesc:ad0c159ea2f81661d52b06b1e8a4edbd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a node from the executor.  <a href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#ad0c159ea2f81661d52b06b1e8a4edbd0">More...</a><br /></td></tr>
<tr class="separator:ad0c159ea2f81661d52b06b1e8a4edbd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9578b4ab98dda3b6493d35b87c302af4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#a9578b4ab98dda3b6493d35b87c302af4">remove_node</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; <a class="el" href="classrclcpp_1_1Node.html">rclcpp::Node</a> &gt; node_ptr, bool notify=true) override</td></tr>
<tr class="memdesc:a9578b4ab98dda3b6493d35b87c302af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function which takes <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a> and forwards NodeBaseInterface.  <a href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#a9578b4ab98dda3b6493d35b87c302af4">More...</a><br /></td></tr>
<tr class="separator:a9578b4ab98dda3b6493d35b87c302af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8aed736c98d24c72bd26db690d6e3ba"><td class="memTemplParams" colspan="2">template&lt;typename ResponseT , typename TimeRepT  = int64_t, typename TimeT  = std::milli&gt; </td></tr>
<tr class="memitem:ab8aed736c98d24c72bd26db690d6e3ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacerclcpp.html#a7b4ff5f1e516740d7e11ea97fe6f5532">rclcpp::FutureReturnCode</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#ab8aed736c98d24c72bd26db690d6e3ba">spin_until_future_complete</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/thread/shared_future.html">std::shared_future</a>&lt; ResponseT &gt; &amp;future, <a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::duration</a>&lt; TimeRepT, TimeT &gt; timeout=<a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::duration</a>&lt; TimeRepT, TimeT &gt;(-1))</td></tr>
<tr class="memdesc:ab8aed736c98d24c72bd26db690d6e3ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spin (blocking) until the future is complete, it times out waiting, or rclcpp is interrupted.  <a href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#ab8aed736c98d24c72bd26db690d6e3ba">More...</a><br /></td></tr>
<tr class="separator:ab8aed736c98d24c72bd26db690d6e3ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classrclcpp_1_1Executor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classrclcpp_1_1Executor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classrclcpp_1_1Executor.html">rclcpp::Executor</a></td></tr>
<tr class="memitem:a3d28d13a7233751c9b7b023528f10228 inherit pub_methods_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a3d28d13a7233751c9b7b023528f10228">Executor</a> (const <a class="el" href="structrclcpp_1_1ExecutorOptions.html">rclcpp::ExecutorOptions</a> &amp;options=<a class="el" href="structrclcpp_1_1ExecutorOptions.html">rclcpp::ExecutorOptions</a>())</td></tr>
<tr class="memdesc:a3d28d13a7233751c9b7b023528f10228 inherit pub_methods_classrclcpp_1_1Executor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classrclcpp_1_1Executor.html#a3d28d13a7233751c9b7b023528f10228">More...</a><br /></td></tr>
<tr class="separator:a3d28d13a7233751c9b7b023528f10228 inherit pub_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946f5bfe58cb0ee5f52a98455248ed66 inherit pub_methods_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a946f5bfe58cb0ee5f52a98455248ed66">~Executor</a> ()</td></tr>
<tr class="memdesc:a946f5bfe58cb0ee5f52a98455248ed66 inherit pub_methods_classrclcpp_1_1Executor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor.  <a href="classrclcpp_1_1Executor.html#a946f5bfe58cb0ee5f52a98455248ed66">More...</a><br /></td></tr>
<tr class="separator:a946f5bfe58cb0ee5f52a98455248ed66 inherit pub_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af09dd5b81cc174fd7029fab65a726db9 inherit pub_methods_classrclcpp_1_1Executor"><td class="memTemplParams" colspan="2">template&lt;typename RepT  = int64_t, typename T  = std::milli&gt; </td></tr>
<tr class="memitem:af09dd5b81cc174fd7029fab65a726db9 inherit pub_methods_classrclcpp_1_1Executor"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#af09dd5b81cc174fd7029fab65a726db9">spin_node_once</a> (rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node, <a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::duration</a>&lt; RepT, T &gt; timeout=<a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::duration</a>&lt; RepT, T &gt;(-1))</td></tr>
<tr class="memdesc:af09dd5b81cc174fd7029fab65a726db9 inherit pub_methods_classrclcpp_1_1Executor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a node to executor, execute the next available unit of work, and remove the node.  <a href="classrclcpp_1_1Executor.html#af09dd5b81cc174fd7029fab65a726db9">More...</a><br /></td></tr>
<tr class="separator:af09dd5b81cc174fd7029fab65a726db9 inherit pub_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9791fd5812f06add439c9cca86d6226b inherit pub_methods_classrclcpp_1_1Executor"><td class="memTemplParams" colspan="2">template&lt;typename NodeT  = rclcpp::Node, typename RepT  = int64_t, typename T  = std::milli&gt; </td></tr>
<tr class="memitem:a9791fd5812f06add439c9cca86d6226b inherit pub_methods_classrclcpp_1_1Executor"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a9791fd5812f06add439c9cca86d6226b">spin_node_once</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; NodeT &gt; node, <a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::duration</a>&lt; RepT, T &gt; timeout=<a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::duration</a>&lt; RepT, T &gt;(-1))</td></tr>
<tr class="memdesc:a9791fd5812f06add439c9cca86d6226b inherit pub_methods_classrclcpp_1_1Executor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function which takes <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a> and forwards NodeBaseInterface.  <a href="classrclcpp_1_1Executor.html#a9791fd5812f06add439c9cca86d6226b">More...</a><br /></td></tr>
<tr class="separator:a9791fd5812f06add439c9cca86d6226b inherit pub_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49780b2217485638b0d7be720062e630 inherit pub_methods_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a49780b2217485638b0d7be720062e630">spin_node_some</a> (rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node)</td></tr>
<tr class="memdesc:a49780b2217485638b0d7be720062e630 inherit pub_methods_classrclcpp_1_1Executor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a node, complete all immediately available work, and remove the node.  <a href="classrclcpp_1_1Executor.html#a49780b2217485638b0d7be720062e630">More...</a><br /></td></tr>
<tr class="separator:a49780b2217485638b0d7be720062e630 inherit pub_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8f89d67464b75cfc63f1ddf56f8850 inherit pub_methods_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a9c8f89d67464b75cfc63f1ddf56f8850">spin_node_some</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; <a class="el" href="classrclcpp_1_1Node.html">rclcpp::Node</a> &gt; node)</td></tr>
<tr class="memdesc:a9c8f89d67464b75cfc63f1ddf56f8850 inherit pub_methods_classrclcpp_1_1Executor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function which takes <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a> and forwards NodeBaseInterface.  <a href="classrclcpp_1_1Executor.html#a9c8f89d67464b75cfc63f1ddf56f8850">More...</a><br /></td></tr>
<tr class="separator:a9c8f89d67464b75cfc63f1ddf56f8850 inherit pub_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae821cd4cf1040fe2da521fb19a458fa1 inherit pub_methods_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#ae821cd4cf1040fe2da521fb19a458fa1">spin_some</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::nanoseconds</a> max_duration=<a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::nanoseconds</a>(0))</td></tr>
<tr class="memdesc:ae821cd4cf1040fe2da521fb19a458fa1 inherit pub_methods_classrclcpp_1_1Executor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete all available queued work without blocking.  <a href="classrclcpp_1_1Executor.html#ae821cd4cf1040fe2da521fb19a458fa1">More...</a><br /></td></tr>
<tr class="separator:ae821cd4cf1040fe2da521fb19a458fa1 inherit pub_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4abb57eea7e1b6c95acc0e7abff62b2 inherit pub_methods_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#ae4abb57eea7e1b6c95acc0e7abff62b2">spin_once</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::nanoseconds</a> timeout=<a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::nanoseconds</a>(-1))</td></tr>
<tr class="separator:ae4abb57eea7e1b6c95acc0e7abff62b2 inherit pub_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484f01fbbbdc2604f349586d2b2f6830 inherit pub_methods_classrclcpp_1_1Executor"><td class="memTemplParams" colspan="2">template&lt;typename ResponseT , typename TimeRepT  = int64_t, typename TimeT  = std::milli&gt; </td></tr>
<tr class="memitem:a484f01fbbbdc2604f349586d2b2f6830 inherit pub_methods_classrclcpp_1_1Executor"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacerclcpp.html#a7b4ff5f1e516740d7e11ea97fe6f5532">FutureReturnCode</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a484f01fbbbdc2604f349586d2b2f6830">spin_until_future_complete</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/thread/shared_future.html">std::shared_future</a>&lt; ResponseT &gt; &amp;future, <a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::duration</a>&lt; TimeRepT, TimeT &gt; timeout=<a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::duration</a>&lt; TimeRepT, TimeT &gt;(-1))</td></tr>
<tr class="memdesc:a484f01fbbbdc2604f349586d2b2f6830 inherit pub_methods_classrclcpp_1_1Executor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spin (blocking) until the future is complete, it times out waiting, or rclcpp is interrupted.  <a href="classrclcpp_1_1Executor.html#a484f01fbbbdc2604f349586d2b2f6830">More...</a><br /></td></tr>
<tr class="separator:a484f01fbbbdc2604f349586d2b2f6830 inherit pub_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb21996107bcf4e62f8330e8d201e70 inherit pub_methods_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a0fb21996107bcf4e62f8330e8d201e70">cancel</a> ()</td></tr>
<tr class="memdesc:a0fb21996107bcf4e62f8330e8d201e70 inherit pub_methods_classrclcpp_1_1Executor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel any running spin* function, causing it to return.  <a href="classrclcpp_1_1Executor.html#a0fb21996107bcf4e62f8330e8d201e70">More...</a><br /></td></tr>
<tr class="separator:a0fb21996107bcf4e62f8330e8d201e70 inherit pub_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41ca2b0358c875337ac13a8130987e9 inherit pub_methods_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#aa41ca2b0358c875337ac13a8130987e9">set_memory_strategy</a> (memory_strategy::MemoryStrategy::SharedPtr memory_strategy)</td></tr>
<tr class="memdesc:aa41ca2b0358c875337ac13a8130987e9 inherit pub_methods_classrclcpp_1_1Executor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support dynamic switching of the memory strategy.  <a href="classrclcpp_1_1Executor.html#aa41ca2b0358c875337ac13a8130987e9">More...</a><br /></td></tr>
<tr class="separator:aa41ca2b0358c875337ac13a8130987e9 inherit pub_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ab767fee73876b7a64cdc98ce9de0a9aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#ab767fee73876b7a64cdc98ce9de0a9aa">execute_ready_executables</a> ()</td></tr>
<tr class="memdesc:ab767fee73876b7a64cdc98ce9de0a9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check which executables in ExecutableList struct are ready from wait_set and execute them.  <a href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#ab767fee73876b7a64cdc98ce9de0a9aa">More...</a><br /></td></tr>
<tr class="separator:ab767fee73876b7a64cdc98ce9de0a9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classrclcpp_1_1Executor"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classrclcpp_1_1Executor')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classrclcpp_1_1Executor.html">rclcpp::Executor</a></td></tr>
<tr class="memitem:a562cd027f960258673a737c9e8d3be75 inherit pro_methods_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a562cd027f960258673a737c9e8d3be75">spin_node_once_nanoseconds</a> (rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node, <a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::nanoseconds</a> timeout)</td></tr>
<tr class="separator:a562cd027f960258673a737c9e8d3be75 inherit pro_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915f4738cf48d6c08851be8264aad58d inherit pro_methods_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a915f4738cf48d6c08851be8264aad58d">execute_any_executable</a> (<a class="el" href="structrclcpp_1_1AnyExecutable.html">AnyExecutable</a> &amp;any_exec)</td></tr>
<tr class="memdesc:a915f4738cf48d6c08851be8264aad58d inherit pro_methods_classrclcpp_1_1Executor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the next available executable and do the work associated with it.  <a href="classrclcpp_1_1Executor.html#a915f4738cf48d6c08851be8264aad58d">More...</a><br /></td></tr>
<tr class="separator:a915f4738cf48d6c08851be8264aad58d inherit pro_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af211465e15ae5b13bac0893ef9e0ed4e inherit pro_methods_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#af211465e15ae5b13bac0893ef9e0ed4e">wait_for_work</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::nanoseconds</a> timeout=<a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::nanoseconds</a>(-1))</td></tr>
<tr class="separator:af211465e15ae5b13bac0893ef9e0ed4e inherit pro_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac865aeb892b5bf2a585bcdff1ed9fe00 inherit pro_methods_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">rclcpp::node_interfaces::NodeBaseInterface::SharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#ac865aeb892b5bf2a585bcdff1ed9fe00">get_node_by_group</a> (rclcpp::CallbackGroup::SharedPtr group)</td></tr>
<tr class="separator:ac865aeb892b5bf2a585bcdff1ed9fe00 inherit pro_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06baded5884fc91e6d36ab676f0b7fc3 inherit pro_methods_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">rclcpp::CallbackGroup::SharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a06baded5884fc91e6d36ab676f0b7fc3">get_group_by_timer</a> (rclcpp::TimerBase::SharedPtr timer)</td></tr>
<tr class="separator:a06baded5884fc91e6d36ab676f0b7fc3 inherit pro_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3c92aec4730186388701398c84263b inherit pro_methods_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#aad3c92aec4730186388701398c84263b">get_next_ready_executable</a> (<a class="el" href="structrclcpp_1_1AnyExecutable.html">AnyExecutable</a> &amp;any_executable)</td></tr>
<tr class="separator:aad3c92aec4730186388701398c84263b inherit pro_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b530d7459b579ca22044a5e7a37a50 inherit pro_methods_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a63b530d7459b579ca22044a5e7a37a50">get_next_executable</a> (<a class="el" href="structrclcpp_1_1AnyExecutable.html">AnyExecutable</a> &amp;any_executable, <a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::nanoseconds</a> timeout=<a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::nanoseconds</a>(-1))</td></tr>
<tr class="separator:a63b530d7459b579ca22044a5e7a37a50 inherit pro_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_static_methods_classrclcpp_1_1Executor"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_classrclcpp_1_1Executor')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classrclcpp_1_1Executor.html">rclcpp::Executor</a></td></tr>
<tr class="memitem:a3f825d7a6d22eb8a6c2974d89d8bcebc inherit pro_static_methods_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a3f825d7a6d22eb8a6c2974d89d8bcebc">execute_subscription</a> (rclcpp::SubscriptionBase::SharedPtr subscription)</td></tr>
<tr class="separator:a3f825d7a6d22eb8a6c2974d89d8bcebc inherit pro_static_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e62a3a7c60ab1569659aeaa47886b7e inherit pro_static_methods_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a6e62a3a7c60ab1569659aeaa47886b7e">execute_timer</a> (rclcpp::TimerBase::SharedPtr timer)</td></tr>
<tr class="separator:a6e62a3a7c60ab1569659aeaa47886b7e inherit pro_static_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2e10441f4ad3c566c84f44e8d697d8 inherit pro_static_methods_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a8c2e10441f4ad3c566c84f44e8d697d8">execute_service</a> (rclcpp::ServiceBase::SharedPtr service)</td></tr>
<tr class="separator:a8c2e10441f4ad3c566c84f44e8d697d8 inherit pro_static_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a488790ad5eccaf4a7dc2b6eab6862147 inherit pro_static_methods_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a488790ad5eccaf4a7dc2b6eab6862147">execute_client</a> (rclcpp::ClientBase::SharedPtr client)</td></tr>
<tr class="separator:a488790ad5eccaf4a7dc2b6eab6862147 inherit pro_static_methods_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classrclcpp_1_1Executor"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classrclcpp_1_1Executor')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classrclcpp_1_1Executor.html">rclcpp::Executor</a></td></tr>
<tr class="memitem:afe759d8451caa0752e2209bb0863dbcd inherit pro_attribs_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">std::atomic_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#afe759d8451caa0752e2209bb0863dbcd">spinning</a></td></tr>
<tr class="memdesc:afe759d8451caa0752e2209bb0863dbcd inherit pro_attribs_classrclcpp_1_1Executor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spinning state, used to prevent multi threaded calls to spin and to cancel blocking spins.  <a href="classrclcpp_1_1Executor.html#afe759d8451caa0752e2209bb0863dbcd">More...</a><br /></td></tr>
<tr class="separator:afe759d8451caa0752e2209bb0863dbcd inherit pro_attribs_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08ff5546ad531eae007ce653bf1b163 inherit pro_attribs_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://docs.ros2.org/foxy/api/rcl/structrcl__guard__condition__t.html">rcl_guard_condition_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#af08ff5546ad531eae007ce653bf1b163">interrupt_guard_condition_</a> = rcl_get_zero_initialized_guard_condition()</td></tr>
<tr class="memdesc:af08ff5546ad531eae007ce653bf1b163 inherit pro_attribs_classrclcpp_1_1Executor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guard condition for signaling the rmw layer to wake up for special events.  <a href="classrclcpp_1_1Executor.html#af08ff5546ad531eae007ce653bf1b163">More...</a><br /></td></tr>
<tr class="separator:af08ff5546ad531eae007ce653bf1b163 inherit pro_attribs_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07bb6ff536c37f44a5c05f3ba5c300ee inherit pro_attribs_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://docs.ros2.org/foxy/api/rcl/structrcl__wait__set__t.html">rcl_wait_set_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a07bb6ff536c37f44a5c05f3ba5c300ee">wait_set_</a> = rcl_get_zero_initialized_wait_set()</td></tr>
<tr class="memdesc:a07bb6ff536c37f44a5c05f3ba5c300ee inherit pro_attribs_classrclcpp_1_1Executor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait set for managing entities that the rmw layer waits on.  <a href="classrclcpp_1_1Executor.html#a07bb6ff536c37f44a5c05f3ba5c300ee">More...</a><br /></td></tr>
<tr class="separator:a07bb6ff536c37f44a5c05f3ba5c300ee inherit pro_attribs_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74228f8c4ef5138223eed4ed0d2559f inherit pro_attribs_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/thread/mutex.html">std::mutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#ab74228f8c4ef5138223eed4ed0d2559f">memory_strategy_mutex_</a></td></tr>
<tr class="separator:ab74228f8c4ef5138223eed4ed0d2559f inherit pro_attribs_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d31b355624a35e3a806e5533084f78 inherit pro_attribs_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top">memory_strategy::MemoryStrategy::SharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#aa1d31b355624a35e3a806e5533084f78">memory_strategy_</a></td></tr>
<tr class="memdesc:aa1d31b355624a35e3a806e5533084f78 inherit pro_attribs_classrclcpp_1_1Executor"><td class="mdescLeft">&#160;</td><td class="mdescRight">The memory strategy: an interface for handling user-defined memory allocation strategies.  <a href="classrclcpp_1_1Executor.html#aa1d31b355624a35e3a806e5533084f78">More...</a><br /></td></tr>
<tr class="separator:aa1d31b355624a35e3a806e5533084f78 inherit pro_attribs_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb729b9e8a7e925e08fb0a9d6244282 inherit pro_attribs_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; <a class="el" href="classrclcpp_1_1Context.html">rclcpp::Context</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a9cb729b9e8a7e925e08fb0a9d6244282">context_</a></td></tr>
<tr class="memdesc:a9cb729b9e8a7e925e08fb0a9d6244282 inherit pro_attribs_classrclcpp_1_1Executor"><td class="mdescLeft">&#160;</td><td class="mdescRight">The context associated with this executor.  <a href="classrclcpp_1_1Executor.html#a9cb729b9e8a7e925e08fb0a9d6244282">More...</a><br /></td></tr>
<tr class="separator:a9cb729b9e8a7e925e08fb0a9d6244282 inherit pro_attribs_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83944e8c14cee34664cf40d1bc29e058 inherit pro_attribs_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/list.html">std::list</a>&lt; rclcpp::node_interfaces::NodeBaseInterface::WeakPtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#a83944e8c14cee34664cf40d1bc29e058">weak_nodes_</a></td></tr>
<tr class="separator:a83944e8c14cee34664cf40d1bc29e058 inherit pro_attribs_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9be900933db041b3b72f02d043a6c5e inherit pro_attribs_classrclcpp_1_1Executor"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/list.html">std::list</a>&lt; const <a class="elRef" href="http://docs.ros2.org/foxy/api/rcl/structrcl__guard__condition__t.html">rcl_guard_condition_t</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Executor.html#ad9be900933db041b3b72f02d043a6c5e">guard_conditions_</a></td></tr>
<tr class="separator:ad9be900933db041b3b72f02d043a6c5e inherit pro_attribs_classrclcpp_1_1Executor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Static executor implementation. </p>
<p>This executor is a static version of the original single threaded executor. It's static because it doesn't reconstruct the executable list for every iteration. All nodes, callbackgroups, timers, subscriptions etc. are created before <a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#a1cec9027c4c69e49a6e15398f01b7c47" title="Static executor implementation of spin.">spin()</a> is called, and modified only when an entity is added/removed to/from a node.</p>
<p>To run this executor instead of <a class="el" href="classrclcpp_1_1executors_1_1SingleThreadedExecutor.html" title="Single-threaded executor implementation.">SingleThreadedExecutor</a> replace: <a class="el" href="classrclcpp_1_1executors_1_1SingleThreadedExecutor.html" title="Single-threaded executor implementation.">rclcpp::executors::SingleThreadedExecutor</a> exec; by <a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html" title="Static executor implementation.">rclcpp::executors::StaticSingleThreadedExecutor</a> exec; in your source code and spin node(s) in the following way: exec.add_node(node); <a class="el" href="namespacerclcpp.html#a21e13577f5bcc5992de1d7dd08d8652b" title="Create a default single-threaded executor and spin the specified node.">exec.spin()</a>; exec.remove_node(node); </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6ee69a543c46f731a74a8d33fe6bf3e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ee69a543c46f731a74a8d33fe6bf3e5">&#9670;&nbsp;</a></span>StaticSingleThreadedExecutor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rclcpp::executors::StaticSingleThreadedExecutor::StaticSingleThreadedExecutor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrclcpp_1_1ExecutorOptions.html">rclcpp::ExecutorOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structrclcpp_1_1ExecutorOptions.html">rclcpp::ExecutorOptions</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. See the default constructor for <a class="el" href="classrclcpp_1_1Executor.html" title="Coordinate the order and timing of available communication tasks.">Executor</a>. </p>

</div>
</div>
<a id="acfba5ffd5adf68e26137f49a8587ad9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfba5ffd5adf68e26137f49a8587ad9e">&#9670;&nbsp;</a></span>~StaticSingleThreadedExecutor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual rclcpp::executors::StaticSingleThreadedExecutor::~StaticSingleThreadedExecutor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default destrcutor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1cec9027c4c69e49a6e15398f01b7c47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cec9027c4c69e49a6e15398f01b7c47">&#9670;&nbsp;</a></span>spin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::executors::StaticSingleThreadedExecutor::spin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static executor implementation of spin. </p>
<p>This function will block until work comes in, execute it, and keep blocking. It will only be interrupted by a CTRL-C (managed by the global signal handler). </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="elRef" href="http://en.cppreference.com/w/cpp/error/runtime_error.html">std::runtime_error</a></td><td>when <a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html#a1cec9027c4c69e49a6e15398f01b7c47" title="Static executor implementation of spin.">spin()</a> called while already spinning </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classrclcpp_1_1Executor.html#ad096fec6846af2169ee97cd2d23e96ca">rclcpp::Executor</a>.</p>

</div>
</div>
<a id="a5c04102c89554658c021dceb1555af2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c04102c89554658c021dceb1555af2f">&#9670;&nbsp;</a></span>add_node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::executors::StaticSingleThreadedExecutor::add_node </td>
          <td>(</td>
          <td class="paramtype">rclcpp::node_interfaces::NodeBaseInterface::SharedPtr&#160;</td>
          <td class="paramname"><em>node_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>notify</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a node to the executor. </p>
<p>An executor can have zero or more nodes which provide work during <code>spin</code> functions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_ptr</td><td>Shared pointer to the node to be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">notify</td><td>True to trigger the interrupt guard condition during this function. If the executor is blocked at the rmw layer while waiting for work and it is notified that a new node was added, it will wake up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="elRef" href="http://en.cppreference.com/w/cpp/error/runtime_error.html">std::runtime_error</a></td><td>if node was already added or if rcl_trigger_guard_condition return an error </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classrclcpp_1_1Executor.html#a53f9649e4c2f3593c930f4d191e7e208">rclcpp::Executor</a>.</p>

</div>
</div>
<a id="acc40d425a0b14000dcec22b93a5ba194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc40d425a0b14000dcec22b93a5ba194">&#9670;&nbsp;</a></span>add_node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::executors::StaticSingleThreadedExecutor::add_node </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; <a class="el" href="classrclcpp_1_1Node.html">rclcpp::Node</a> &gt;&#160;</td>
          <td class="paramname"><em>node_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>notify</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function which takes <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a> and forwards NodeBaseInterface. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="elRef" href="http://en.cppreference.com/w/cpp/error/runtime_error.html">std::runtime_error</a></td><td>if node was already added or if rcl_trigger_guard_condition returns an error </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classrclcpp_1_1Executor.html#a83a2b87b3a60d3fd8525d18879cec14c">rclcpp::Executor</a>.</p>

</div>
</div>
<a id="ad0c159ea2f81661d52b06b1e8a4edbd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0c159ea2f81661d52b06b1e8a4edbd0">&#9670;&nbsp;</a></span>remove_node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::executors::StaticSingleThreadedExecutor::remove_node </td>
          <td>(</td>
          <td class="paramtype">rclcpp::node_interfaces::NodeBaseInterface::SharedPtr&#160;</td>
          <td class="paramname"><em>node_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>notify</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a node from the executor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_ptr</td><td>Shared pointer to the node to remove. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">notify</td><td>True to trigger the interrupt guard condition and wake up the executor. This is useful if the last node was removed from the executor while the executor was blocked waiting for work in another thread, because otherwise the executor would never be notified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="elRef" href="http://en.cppreference.com/w/cpp/error/runtime_error.html">std::runtime_error</a></td><td>if rcl_trigger_guard_condition returns an error </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classrclcpp_1_1Executor.html#a660424725a58fc412fac8e86191b1f61">rclcpp::Executor</a>.</p>

</div>
</div>
<a id="a9578b4ab98dda3b6493d35b87c302af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9578b4ab98dda3b6493d35b87c302af4">&#9670;&nbsp;</a></span>remove_node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::executors::StaticSingleThreadedExecutor::remove_node </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; <a class="el" href="classrclcpp_1_1Node.html">rclcpp::Node</a> &gt;&#160;</td>
          <td class="paramname"><em>node_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>notify</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function which takes <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a> and forwards NodeBaseInterface. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="elRef" href="http://en.cppreference.com/w/cpp/error/runtime_error.html">std::runtime_error</a></td><td>if rcl_trigger_guard_condition returns an error </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classrclcpp_1_1Executor.html#ae0543bf6a85ae11a042cef13077ab364">rclcpp::Executor</a>.</p>

</div>
</div>
<a id="ab8aed736c98d24c72bd26db690d6e3ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8aed736c98d24c72bd26db690d6e3ba">&#9670;&nbsp;</a></span>spin_until_future_complete()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResponseT , typename TimeRepT  = int64_t, typename TimeT  = std::milli&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacerclcpp.html#a7b4ff5f1e516740d7e11ea97fe6f5532">rclcpp::FutureReturnCode</a> rclcpp::executors::StaticSingleThreadedExecutor::spin_until_future_complete </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/thread/shared_future.html">std::shared_future</a>&lt; ResponseT &gt; &amp;&#160;</td>
          <td class="paramname"><em>future</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::duration</a>&lt; TimeRepT, TimeT &gt;&#160;</td>
          <td class="paramname"><em>timeout</em> = <code><a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::duration</a>&lt;TimeRepT,&#160;TimeT&gt;(-1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Spin (blocking) until the future is complete, it times out waiting, or rclcpp is interrupted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">future</td><td>The future to wait on. If this function returns SUCCESS, the future can be accessed without blocking (though it may still throw an exception). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Optional timeout parameter, which gets passed to Executor::execute_ready_executables. <code>-1</code> is block forever, <code>0</code> is non-blocking. If the time spent inside the blocking loop exceeds this timeout, return a TIMEOUT return code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return code, one of <code>SUCCESS</code>, <code>INTERRUPTED</code>, or <code>TIMEOUT</code>.</dd></dl>
<p>Example usage: <a class="el" href="classrclcpp_1_1executors_1_1StaticSingleThreadedExecutor.html" title="Static executor implementation.">rclcpp::executors::StaticSingleThreadedExecutor</a> exec; // ... other part of code like creating node // define future exec.add_node(node); exec.spin_until_future_complete(future); </p>

</div>
</div>
<a id="ab767fee73876b7a64cdc98ce9de0a9aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab767fee73876b7a64cdc98ce9de0a9aa">&#9670;&nbsp;</a></span>execute_ready_executables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::executors::StaticSingleThreadedExecutor::execute_ready_executables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check which executables in ExecutableList struct are ready from wait_set and execute them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">exec_list</td><td>Structure that can hold subscriptionbases, timerbases, etc </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Optional timeout parameter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/rclcpp/executors/<a class="el" href="static__single__threaded__executor_8hpp_source.html">static_single_threaded_executor.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
