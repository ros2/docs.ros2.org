<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rclcpp: rclcpp::Context Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rclcpp
   &#160;<span id="projectnumber">master</span>
   </div>
   <div id="projectbrief">C++ ROS Client Library API</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacerclcpp.html">rclcpp</a></li><li class="navelem"><a class="el" href="classrclcpp_1_1Context.html">Context</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classrclcpp_1_1Context-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rclcpp::Context Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classrclcpp_1_1Context.html" title="Context which encapsulates shared state between nodes and other similar entities.">Context</a> which encapsulates shared state between nodes and other similar entities.  
 <a href="classrclcpp_1_1Context.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="context_8hpp_source.html">context.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for rclcpp::Context:</div>
<div class="dyncontent">
<div class="center"><img src="classrclcpp_1_1Context__inherit__graph.png" border="0" usemap="#rclcpp_1_1Context_inherit__map" alt="Inheritance graph"/></div>
<map name="rclcpp_1_1Context_inherit__map" id="rclcpp_1_1Context_inherit__map">
<area shape="rect" title="Context which encapsulates shared state between nodes and other similar entities." alt="" coords="36,95,156,121"/>
<area shape="rect" href="classrclcpp_1_1contexts_1_1DefaultContext.html" title=" " alt="" coords="5,169,187,211"/>
<area shape="rect" href="http://en.cppreference.com/w/cpp/memory/enable_shared_from_this.html" title=" " alt="" coords="10,5,182,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for rclcpp::Context:</div>
<div class="dyncontent">
<div class="center"><img src="classrclcpp_1_1Context__coll__graph.png" border="0" usemap="#rclcpp_1_1Context_coll__map" alt="Collaboration graph"/></div>
<map name="rclcpp_1_1Context_coll__map" id="rclcpp_1_1Context_coll__map">
<area shape="rect" title="Context which encapsulates shared state between nodes and other similar entities." alt="" coords="31,95,151,121"/>
<area shape="rect" href="http://en.cppreference.com/w/cpp/memory/enable_shared_from_this.html" title=" " alt="" coords="5,5,177,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a64bce7cbf8b92f3e0283077f26facf9b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Context.html#a64bce7cbf8b92f3e0283077f26facf9b">OnShutdownCallback</a> = <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/function.html">std::function</a>&lt; void()&gt;</td></tr>
<tr class="separator:a64bce7cbf8b92f3e0283077f26facf9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1b274e8c22d9f800a9a1527330f83f7f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Context.html#a1b274e8c22d9f800a9a1527330f83f7f">Context</a> ()</td></tr>
<tr class="memdesc:a1b274e8c22d9f800a9a1527330f83f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor, after which the <a class="el" href="classrclcpp_1_1Context.html" title="Context which encapsulates shared state between nodes and other similar entities.">Context</a> is still not "initialized".  <a href="classrclcpp_1_1Context.html#a1b274e8c22d9f800a9a1527330f83f7f">More...</a><br /></td></tr>
<tr class="separator:a1b274e8c22d9f800a9a1527330f83f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087366f7387944185bf8c02f4f8873c7"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Context.html#a087366f7387944185bf8c02f4f8873c7">~Context</a> ()</td></tr>
<tr class="separator:a087366f7387944185bf8c02f4f8873c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f938e3bd0a0f1eb3691d22c583ddfed"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Context.html#a6f938e3bd0a0f1eb3691d22c583ddfed">init</a> (int argc, char const *const argv[], const <a class="el" href="classrclcpp_1_1InitOptions.html">rclcpp::InitOptions</a> &amp;init_options=<a class="el" href="classrclcpp_1_1InitOptions.html">rclcpp::InitOptions</a>())</td></tr>
<tr class="memdesc:a6f938e3bd0a0f1eb3691d22c583ddfed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the context, and the underlying elements like the rcl context.  <a href="classrclcpp_1_1Context.html#a6f938e3bd0a0f1eb3691d22c583ddfed">More...</a><br /></td></tr>
<tr class="separator:a6f938e3bd0a0f1eb3691d22c583ddfed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab1efb0368a6d291c519cf90450762c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Context.html#afab1efb0368a6d291c519cf90450762c">is_valid</a> () const</td></tr>
<tr class="memdesc:afab1efb0368a6d291c519cf90450762c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the context is valid, otherwise false.  <a href="classrclcpp_1_1Context.html#afab1efb0368a6d291c519cf90450762c">More...</a><br /></td></tr>
<tr class="separator:afab1efb0368a6d291c519cf90450762c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de1320462bbdfe0b7f07614be2d98e9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classrclcpp_1_1InitOptions.html">rclcpp::InitOptions</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Context.html#a7de1320462bbdfe0b7f07614be2d98e9">get_init_options</a> () const</td></tr>
<tr class="memdesc:a7de1320462bbdfe0b7f07614be2d98e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the init options used during init.  <a href="classrclcpp_1_1Context.html#a7de1320462bbdfe0b7f07614be2d98e9">More...</a><br /></td></tr>
<tr class="separator:a7de1320462bbdfe0b7f07614be2d98e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7df3a8380939883be7e8c4c240f6255"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrclcpp_1_1InitOptions.html">rclcpp::InitOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Context.html#ab7df3a8380939883be7e8c4c240f6255">get_init_options</a> ()</td></tr>
<tr class="memdesc:ab7df3a8380939883be7e8c4c240f6255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the init options used during init.  <a href="classrclcpp_1_1Context.html#ab7df3a8380939883be7e8c4c240f6255">More...</a><br /></td></tr>
<tr class="separator:ab7df3a8380939883be7e8c4c240f6255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea006131f2eeb6a0e6c567e305ba9755"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Context.html#aea006131f2eeb6a0e6c567e305ba9755">shutdown_reason</a> ()</td></tr>
<tr class="memdesc:aea006131f2eeb6a0e6c567e305ba9755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the shutdown reason, or empty string if not shutdown.  <a href="classrclcpp_1_1Context.html#aea006131f2eeb6a0e6c567e305ba9755">More...</a><br /></td></tr>
<tr class="separator:aea006131f2eeb6a0e6c567e305ba9755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51bf15d106aa246001a4fdc15be7b2a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Context.html#ac51bf15d106aa246001a4fdc15be7b2a">shutdown</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;reason)</td></tr>
<tr class="memdesc:ac51bf15d106aa246001a4fdc15be7b2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shutdown the context, making it uninitialized and therefore invalid for derived entities.  <a href="classrclcpp_1_1Context.html#ac51bf15d106aa246001a4fdc15be7b2a">More...</a><br /></td></tr>
<tr class="separator:ac51bf15d106aa246001a4fdc15be7b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d731d83e73a5b368c9f5bee1d2d4cb2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classrclcpp_1_1Context.html#a64bce7cbf8b92f3e0283077f26facf9b">OnShutdownCallback</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Context.html#a0d731d83e73a5b368c9f5bee1d2d4cb2">on_shutdown</a> (<a class="el" href="classrclcpp_1_1Context.html#a64bce7cbf8b92f3e0283077f26facf9b">OnShutdownCallback</a> callback)</td></tr>
<tr class="memdesc:a0d731d83e73a5b368c9f5bee1d2d4cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a on_shutdown callback to be called when shutdown is called for this context.  <a href="classrclcpp_1_1Context.html#a0d731d83e73a5b368c9f5bee1d2d4cb2">More...</a><br /></td></tr>
<tr class="separator:a0d731d83e73a5b368c9f5bee1d2d4cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43fd7326634fb77c060b3bb1b33fb6af"><td class="memItemLeft" align="right" valign="top">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classrclcpp_1_1Context.html#a64bce7cbf8b92f3e0283077f26facf9b">OnShutdownCallback</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Context.html#a43fd7326634fb77c060b3bb1b33fb6af">get_on_shutdown_callbacks</a> () const</td></tr>
<tr class="memdesc:a43fd7326634fb77c060b3bb1b33fb6af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the shutdown callbacks as const.  <a href="classrclcpp_1_1Context.html#a43fd7326634fb77c060b3bb1b33fb6af">More...</a><br /></td></tr>
<tr class="separator:a43fd7326634fb77c060b3bb1b33fb6af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acacf947e05b997ece54cd189e7cfe0c2"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classrclcpp_1_1Context.html#a64bce7cbf8b92f3e0283077f26facf9b">OnShutdownCallback</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Context.html#acacf947e05b997ece54cd189e7cfe0c2">get_on_shutdown_callbacks</a> ()</td></tr>
<tr class="memdesc:acacf947e05b997ece54cd189e7cfe0c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the shutdown callbacks.  <a href="classrclcpp_1_1Context.html#acacf947e05b997ece54cd189e7cfe0c2">More...</a><br /></td></tr>
<tr class="separator:acacf947e05b997ece54cd189e7cfe0c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28596bd16aad20e057160f8a66d4697f"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; <a class="elRef" href="http://docs.ros2.org/foxy/api/rcl/structrcl__context__t.html">rcl_context_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Context.html#a28596bd16aad20e057160f8a66d4697f">get_rcl_context</a> ()</td></tr>
<tr class="memdesc:a28596bd16aad20e057160f8a66d4697f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the internal rcl context.  <a href="classrclcpp_1_1Context.html#a28596bd16aad20e057160f8a66d4697f">More...</a><br /></td></tr>
<tr class="separator:a28596bd16aad20e057160f8a66d4697f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf25fc22a74daf5ce85f6bdde3b92aa2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Context.html#adf25fc22a74daf5ce85f6bdde3b92aa2">sleep_for</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::nanoseconds</a> &amp;<a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">nanoseconds</a>)</td></tr>
<tr class="memdesc:adf25fc22a74daf5ce85f6bdde3b92aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleep for a given period of time or until <a class="el" href="classrclcpp_1_1Context.html#ac51bf15d106aa246001a4fdc15be7b2a" title="Shutdown the context, making it uninitialized and therefore invalid for derived entities.">shutdown()</a> is called.  <a href="classrclcpp_1_1Context.html#adf25fc22a74daf5ce85f6bdde3b92aa2">More...</a><br /></td></tr>
<tr class="separator:adf25fc22a74daf5ce85f6bdde3b92aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af659ad5489ffaf5e38f0db39c156d34a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Context.html#af659ad5489ffaf5e38f0db39c156d34a">interrupt_all_sleep_for</a> ()</td></tr>
<tr class="memdesc:af659ad5489ffaf5e38f0db39c156d34a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt any blocking sleep_for calls, causing them to return immediately and return true.  <a href="classrclcpp_1_1Context.html#af659ad5489ffaf5e38f0db39c156d34a">More...</a><br /></td></tr>
<tr class="separator:af659ad5489ffaf5e38f0db39c156d34a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e1bee2976ea83ec93518b3bc359b78"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://docs.ros2.org/foxy/api/rcl/structrcl__guard__condition__t.html">rcl_guard_condition_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Context.html#a79e1bee2976ea83ec93518b3bc359b78">get_interrupt_guard_condition</a> (<a class="elRef" href="http://docs.ros2.org/foxy/api/rcl/structrcl__wait__set__t.html">rcl_wait_set_t</a> *wait_set)</td></tr>
<tr class="memdesc:a79e1bee2976ea83ec93518b3bc359b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle to the guard condition which is triggered when interrupted.  <a href="classrclcpp_1_1Context.html#a79e1bee2976ea83ec93518b3bc359b78">More...</a><br /></td></tr>
<tr class="separator:a79e1bee2976ea83ec93518b3bc359b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48cfd20fea94c8e029d23af17e751e0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Context.html#a48cfd20fea94c8e029d23af17e751e0a">release_interrupt_guard_condition</a> (<a class="elRef" href="http://docs.ros2.org/foxy/api/rcl/structrcl__wait__set__t.html">rcl_wait_set_t</a> *wait_set)</td></tr>
<tr class="memdesc:a48cfd20fea94c8e029d23af17e751e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the previously allocated guard condition which is triggered when interrupted.  <a href="classrclcpp_1_1Context.html#a48cfd20fea94c8e029d23af17e751e0a">More...</a><br /></td></tr>
<tr class="separator:a48cfd20fea94c8e029d23af17e751e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4c2162e98eca3b8790666896c78fd14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Context.html#aa4c2162e98eca3b8790666896c78fd14">release_interrupt_guard_condition</a> (<a class="elRef" href="http://docs.ros2.org/foxy/api/rcl/structrcl__wait__set__t.html">rcl_wait_set_t</a> *wait_set, const <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/new/nothrow_t.html">std::nothrow_t</a> &amp;) noexcept</td></tr>
<tr class="memdesc:aa4c2162e98eca3b8790666896c78fd14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nothrow version of <a class="el" href="classrclcpp_1_1Context.html#a48cfd20fea94c8e029d23af17e751e0a" title="Release the previously allocated guard condition which is triggered when interrupted.">release_interrupt_guard_condition()</a>, logs to RCLCPP_ERROR instead.  <a href="classrclcpp_1_1Context.html#aa4c2162e98eca3b8790666896c78fd14">More...</a><br /></td></tr>
<tr class="separator:aa4c2162e98eca3b8790666896c78fd14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d2b3dc9f869675621b9c53714b9f86"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Context.html#ac2d2b3dc9f869675621b9c53714b9f86">interrupt_all_wait_sets</a> ()</td></tr>
<tr class="memdesc:ac2d2b3dc9f869675621b9c53714b9f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt any blocking executors, or wait sets associated with this context.  <a href="classrclcpp_1_1Context.html#ac2d2b3dc9f869675621b9c53714b9f86">More...</a><br /></td></tr>
<tr class="separator:ac2d2b3dc9f869675621b9c53714b9f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433b110b4d305be6b690ec3e08f7ec28"><td class="memTemplParams" colspan="2">template&lt;typename SubContext , typename ... Args&gt; </td></tr>
<tr class="memitem:a433b110b4d305be6b690ec3e08f7ec28"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; SubContext &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Context.html#a433b110b4d305be6b690ec3e08f7ec28">get_sub_context</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a433b110b4d305be6b690ec3e08f7ec28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a singleton instance for the SubContext type, constructing one if necessary.  <a href="classrclcpp_1_1Context.html#a433b110b4d305be6b690ec3e08f7ec28">More...</a><br /></td></tr>
<tr class="separator:a433b110b4d305be6b690ec3e08f7ec28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_enable_shared_from_this"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_enable_shared_from_this')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el"  href="http://en.cppreference.com/w/cpp/memory/enable_shared_from_this.html">std::enable_shared_from_this&lt; Context &gt;</a></td></tr>
<tr class="memitem: inherit pub_methods_enable_shared_from_this"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/enable_shared_from_this/enable_shared_from_this.html">enable_shared_from_this</a> (T... args)</td></tr>
<tr class="separator: inherit pub_methods_enable_shared_from_this"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pub_methods_enable_shared_from_this"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/enable_shared_from_this/operator=.html">operator=</a> (T... args)</td></tr>
<tr class="separator: inherit pub_methods_enable_shared_from_this"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pub_methods_enable_shared_from_this"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/enable_shared_from_this/shared_from_this.html">shared_from_this</a> (T... args)</td></tr>
<tr class="separator: inherit pub_methods_enable_shared_from_this"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pub_methods_enable_shared_from_this"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/enable_shared_from_this/~enable_shared_from_this.html">~enable_shared_from_this</a> (T... args)</td></tr>
<tr class="separator: inherit pub_methods_enable_shared_from_this"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ac0cafbb959c061a01dd0fe807cd31f42"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1Context.html#ac0cafbb959c061a01dd0fe807cd31f42">clean_up</a> ()</td></tr>
<tr class="separator:ac0cafbb959c061a01dd0fe807cd31f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classrclcpp_1_1Context.html" title="Context which encapsulates shared state between nodes and other similar entities.">Context</a> which encapsulates shared state between nodes and other similar entities. </p>
<p>A context also represents the lifecycle between init and shutdown of rclcpp. It is often used in conjunction with <a class="el" href="namespacerclcpp.html#a2db29afebba8f677bc8660a45bb910bb" title="Initialize communications via the rmw implementation and set up a global signal handler.">rclcpp::init</a>, or rclcpp::init_local, and <a class="el" href="namespacerclcpp.html#a493714a679d1591142800416a286689f" title="Shutdown rclcpp context, invalidating it for derived entities.">rclcpp::shutdown</a>. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a64bce7cbf8b92f3e0283077f26facf9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64bce7cbf8b92f3e0283077f26facf9b">&#9670;&nbsp;</a></span>OnShutdownCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classrclcpp_1_1Context.html#a64bce7cbf8b92f3e0283077f26facf9b">rclcpp::Context::OnShutdownCallback</a> =  <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/function.html">std::function</a>&lt;void ()&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1b274e8c22d9f800a9a1527330f83f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b274e8c22d9f800a9a1527330f83f7f">&#9670;&nbsp;</a></span>Context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rclcpp::Context::Context </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor, after which the <a class="el" href="classrclcpp_1_1Context.html" title="Context which encapsulates shared state between nodes and other similar entities.">Context</a> is still not "initialized". </p>
<p>Every context which is constructed is added to a global vector of contexts, which is used by the signal handler to conditionally shutdown each context on SIGINT. See the shutdown_on_sigint option in the <a class="el" href="classrclcpp_1_1InitOptions.html" title="Encapsulation of options for initializing rclcpp.">InitOptions</a> class. </p>

</div>
</div>
<a id="a087366f7387944185bf8c02f4f8873c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087366f7387944185bf8c02f4f8873c7">&#9670;&nbsp;</a></span>~Context()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual rclcpp::Context::~Context </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6f938e3bd0a0f1eb3691d22c583ddfed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f938e3bd0a0f1eb3691d22c583ddfed">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rclcpp::Context::init </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *const&#160;</td>
          <td class="paramname"><em>argv</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrclcpp_1_1InitOptions.html">rclcpp::InitOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>init_options</em> = <code><a class="el" href="classrclcpp_1_1InitOptions.html">rclcpp::InitOptions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the context, and the underlying elements like the rcl context. </p>
<p>This method must be called before passing this context to things like the constructor of <a class="el" href="classrclcpp_1_1Node.html" title="Node is the single point of entry for creating publishers and subscribers.">Node</a>. It must also be called before trying to shutdown the context.</p>
<p>Note that this function does not setup any signal handlers, so if you want it to be shutdown by the signal handler, then you need to either install them manually with rclcpp::install_signal_handers() or use <a class="el" href="namespacerclcpp.html#a2db29afebba8f677bc8660a45bb910bb" title="Initialize communications via the rmw implementation and set up a global signal handler.">rclcpp::init()</a>. In addition to installing the signal handlers, the shutdown_on_sigint of the <a class="el" href="classrclcpp_1_1InitOptions.html" title="Encapsulation of options for initializing rclcpp.">InitOptions</a> needs to be <code>true</code> for this context to be shutdown by the signal handler, otherwise it will be passed over.</p>
<p>After calling this method, <a class="el" href="classrclcpp_1_1Context.html#ac51bf15d106aa246001a4fdc15be7b2a" title="Shutdown the context, making it uninitialized and therefore invalid for derived entities.">shutdown()</a> can be called to invalidate the context for derived entities, e.g. nodes, guard conditions, etc. However, the underlying rcl context is not finalized until this <a class="el" href="classrclcpp_1_1Context.html" title="Context which encapsulates shared state between nodes and other similar entities.">Context</a>'s destructor is called or this function is called again. Allowing this class to go out of scope and get destructed or calling this function a second time while derived entities are still using the context is undefined behavior and should be avoided. It's a good idea to not reuse context objects and instead create a new one each time you need to shutdown and init again. This allows derived entities to hold on to shard pointers to the first context object until they are done.</p>
<p>This function is thread-safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">argc</td><td>number of arguments </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argv</td><td>argument array which may contain arguments intended for ROS </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">init_options</td><td>initialization options for rclcpp and underlying layers </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classrclcpp_1_1ContextAlreadyInitialized.html" title="Thrown when init is called on an already initialized context.">ContextAlreadyInitialized</a></td><td>if called if init is called more than once </td></tr>
    <tr><td class="paramname">anything</td><td><a class="el" href="namespacerclcpp_1_1exceptions.html#ad1d5563cfff9273f531a82c1dde13516" title="Throw a C++ std::exception which was created based on an rcl error.">rclcpp::exceptions::throw_from_rcl_error</a> can throw. </td></tr>
    <tr><td class="paramname"><a class="elRef" href="http://en.cppreference.com/w/cpp/error/runtime_error.html">std::runtime_error</a></td><td>if the global logging configure mutex is NULL </td></tr>
    <tr><td class="paramname"><a class="el" href="classrclcpp_1_1exceptions_1_1UnknownROSArgsError.html" title="Thrown when unparsed ROS specific arguments are found.">exceptions::UnknownROSArgsError</a></td><td>if there are unknown ROS arguments </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afab1efb0368a6d291c519cf90450762c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afab1efb0368a6d291c519cf90450762c">&#9670;&nbsp;</a></span>is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rclcpp::Context::is_valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the context is valid, otherwise false. </p>
<p>The context is valid if it has been initialized but not shutdown.</p>
<p>This function is thread-safe. This function is lock free so long as pointers and uint64_t atomics are lock free.</p>
<dl class="section return"><dt>Returns</dt><dd>true if valid, otherwise false </dd></dl>

</div>
</div>
<a id="a7de1320462bbdfe0b7f07614be2d98e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7de1320462bbdfe0b7f07614be2d98e9">&#9670;&nbsp;</a></span>get_init_options() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classrclcpp_1_1InitOptions.html">rclcpp::InitOptions</a>&amp; rclcpp::Context::get_init_options </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the init options used during init. </p>

</div>
</div>
<a id="ab7df3a8380939883be7e8c4c240f6255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7df3a8380939883be7e8c4c240f6255">&#9670;&nbsp;</a></span>get_init_options() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrclcpp_1_1InitOptions.html">rclcpp::InitOptions</a> rclcpp::Context::get_init_options </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a copy of the init options used during init. </p>

</div>
</div>
<a id="aea006131f2eeb6a0e6c567e305ba9755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea006131f2eeb6a0e6c567e305ba9755">&#9670;&nbsp;</a></span>shutdown_reason()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> rclcpp::Context::shutdown_reason </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the shutdown reason, or empty string if not shutdown. </p>
<p>This function is thread-safe. </p>

</div>
</div>
<a id="ac51bf15d106aa246001a4fdc15be7b2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac51bf15d106aa246001a4fdc15be7b2a">&#9670;&nbsp;</a></span>shutdown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool rclcpp::Context::shutdown </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>reason</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shutdown the context, making it uninitialized and therefore invalid for derived entities. </p>
<p>Several things happen when the context is shutdown, in this order:</p>
<ul>
<li>acquires a lock to prevent race conditions with init, on_shutdown, etc.</li>
<li>if the context is not initialized, return false</li>
<li>rcl_shutdown() is called on the internal <a class="elRef" href="http://docs.ros2.org/foxy/api/rcl/structrcl__context__t.html">rcl_context_t</a> instance</li>
<li>the shutdown reason is set</li>
<li>each on_shutdown callback is called, in the order that they were added</li>
<li>interrupt blocking <a class="el" href="classrclcpp_1_1Context.html#adf25fc22a74daf5ce85f6bdde3b92aa2" title="Sleep for a given period of time or until shutdown() is called.">sleep_for()</a> calls, so they return early due to shutdown</li>
<li>interrupt blocking executors and wait sets</li>
</ul>
<p>The underlying rcl context is not finalized by this function.</p>
<p>This function is thread-safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reason</td><td>the description of why shutdown happened </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if shutdown was successful, false if context was already shutdown </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">various</td><td>exceptions derived from <a class="el" href="classrclcpp_1_1exceptions_1_1RCLError.html" title="Created when the return code does not match one of the other specialized exceptions.">rclcpp::exceptions::RCLError</a>, if rcl_shutdown fails </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d731d83e73a5b368c9f5bee1d2d4cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d731d83e73a5b368c9f5bee1d2d4cb2">&#9670;&nbsp;</a></span>on_shutdown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classrclcpp_1_1Context.html#a64bce7cbf8b92f3e0283077f26facf9b">OnShutdownCallback</a> rclcpp::Context::on_shutdown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrclcpp_1_1Context.html#a64bce7cbf8b92f3e0283077f26facf9b">OnShutdownCallback</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a on_shutdown callback to be called when shutdown is called for this context. </p>
<p>These callbacks will be called in the order they are added as the second to last step in <a class="el" href="classrclcpp_1_1Context.html#ac51bf15d106aa246001a4fdc15be7b2a" title="Shutdown the context, making it uninitialized and therefore invalid for derived entities.">shutdown()</a>.</p>
<p>When shutdown occurs due to the signal handler, these callbacks are run asynchronoulsy in the dedicated singal handling thread.</p>
<p>Also, <a class="el" href="classrclcpp_1_1Context.html#ac51bf15d106aa246001a4fdc15be7b2a" title="Shutdown the context, making it uninitialized and therefore invalid for derived entities.">shutdown()</a> may be called from the destructor of this function. Therefore, it is not safe to throw exceptions from these callbacks. Instead, log errors or use some other mechanism to indicate an error has occurred.</p>
<p>On shutdown callbacks may be registered before init and after shutdown, and persist on repeated init's.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>the on shutdown callback to be registered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the callback passed, for convenience when storing a passed lambda </dd></dl>

</div>
</div>
<a id="a43fd7326634fb77c060b3bb1b33fb6af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43fd7326634fb77c060b3bb1b33fb6af">&#9670;&nbsp;</a></span>get_on_shutdown_callbacks() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="el" href="classrclcpp_1_1Context.html#a64bce7cbf8b92f3e0283077f26facf9b">OnShutdownCallback</a>&gt;&amp; rclcpp::Context::get_on_shutdown_callbacks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the shutdown callbacks as const. </p>
<p>Using the returned reference is not thread-safe with calls that modify the list of "on shutdown" callbacks, i.e. <a class="el" href="classrclcpp_1_1Context.html#a0d731d83e73a5b368c9f5bee1d2d4cb2" title="Add a on_shutdown callback to be called when shutdown is called for this context.">on_shutdown()</a>. </p>

</div>
</div>
<a id="acacf947e05b997ece54cd189e7cfe0c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acacf947e05b997ece54cd189e7cfe0c2">&#9670;&nbsp;</a></span>get_on_shutdown_callbacks() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="el" href="classrclcpp_1_1Context.html#a64bce7cbf8b92f3e0283077f26facf9b">OnShutdownCallback</a>&gt;&amp; rclcpp::Context::get_on_shutdown_callbacks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the shutdown callbacks. </p>
<p>Using the returned reference is not thread-safe with calls that modify the list of "on shutdown" callbacks, i.e. <a class="el" href="classrclcpp_1_1Context.html#a0d731d83e73a5b368c9f5bee1d2d4cb2" title="Add a on_shutdown callback to be called when shutdown is called for this context.">on_shutdown()</a>. </p>

</div>
</div>
<a id="a28596bd16aad20e057160f8a66d4697f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28596bd16aad20e057160f8a66d4697f">&#9670;&nbsp;</a></span>get_rcl_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt;<a class="elRef" href="http://docs.ros2.org/foxy/api/rcl/structrcl__context__t.html">rcl_context_t</a>&gt; rclcpp::Context::get_rcl_context </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the internal rcl context. </p>

</div>
</div>
<a id="adf25fc22a74daf5ce85f6bdde3b92aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf25fc22a74daf5ce85f6bdde3b92aa2">&#9670;&nbsp;</a></span>sleep_for()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rclcpp::Context::sleep_for </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::nanoseconds</a> &amp;&#160;</td>
          <td class="paramname"><em>nanoseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sleep for a given period of time or until <a class="el" href="classrclcpp_1_1Context.html#ac51bf15d106aa246001a4fdc15be7b2a" title="Shutdown the context, making it uninitialized and therefore invalid for derived entities.">shutdown()</a> is called. </p>
<p>This function can be interrupted early if:</p>
<ul>
<li>this context is <a class="el" href="classrclcpp_1_1Context.html#ac51bf15d106aa246001a4fdc15be7b2a" title="Shutdown the context, making it uninitialized and therefore invalid for derived entities.">shutdown()</a></li>
<li>this context is destructed (resulting in shutdown)</li>
<li>this context has shutdown_on_sigint=true and SIGINT occurs (resulting in shutdown)</li>
<li><a class="el" href="classrclcpp_1_1Context.html#af659ad5489ffaf5e38f0db39c156d34a" title="Interrupt any blocking sleep_for calls, causing them to return immediately and return true.">interrupt_all_sleep_for()</a> is called</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nanoseconds</td><td>A <a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::duration</a> representing how long to sleep for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the condition variable did not timeout, i.e. you were interrupted. </dd></dl>

</div>
</div>
<a id="af659ad5489ffaf5e38f0db39c156d34a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af659ad5489ffaf5e38f0db39c156d34a">&#9670;&nbsp;</a></span>interrupt_all_sleep_for()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rclcpp::Context::interrupt_all_sleep_for </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interrupt any blocking sleep_for calls, causing them to return immediately and return true. </p>

</div>
</div>
<a id="a79e1bee2976ea83ec93518b3bc359b78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79e1bee2976ea83ec93518b3bc359b78">&#9670;&nbsp;</a></span>get_interrupt_guard_condition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://docs.ros2.org/foxy/api/rcl/structrcl__guard__condition__t.html">rcl_guard_condition_t</a>* rclcpp::Context::get_interrupt_guard_condition </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://docs.ros2.org/foxy/api/rcl/structrcl__wait__set__t.html">rcl_wait_set_t</a> *&#160;</td>
          <td class="paramname"><em>wait_set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a handle to the guard condition which is triggered when interrupted. </p>
<p>This guard condition is triggered any time <a class="el" href="classrclcpp_1_1Context.html#ac2d2b3dc9f869675621b9c53714b9f86" title="Interrupt any blocking executors, or wait sets associated with this context.">interrupt_all_wait_sets()</a> is called, which may be called by the user, or <a class="el" href="classrclcpp_1_1Context.html#ac51bf15d106aa246001a4fdc15be7b2a" title="Shutdown the context, making it uninitialized and therefore invalid for derived entities.">shutdown()</a>. And in turn, <a class="el" href="classrclcpp_1_1Context.html#ac51bf15d106aa246001a4fdc15be7b2a" title="Shutdown the context, making it uninitialized and therefore invalid for derived entities.">shutdown()</a> may be called by the user, the destructor of this context, or the signal handler if installed and shutdown_on_sigint is true for this context.</p>
<p>The first time that this function is called for a given wait set a new guard condition will be created and returned; thereafter the same guard condition will be returned for the same wait set. This mechanism is designed to ensure that the same guard condition is not reused across wait sets (e.g., when using multiple executors in the same process). This method will throw an exception if initialization of the guard condition fails.</p>
<p>The returned guard condition needs to be released with the <a class="el" href="classrclcpp_1_1Context.html#a48cfd20fea94c8e029d23af17e751e0a" title="Release the previously allocated guard condition which is triggered when interrupted.">release_interrupt_guard_condition()</a> method in order to reclaim resources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wait_set</td><td>Pointer to the <a class="elRef" href="http://docs.ros2.org/foxy/api/rcl/structrcl__wait__set__t.html">rcl_wait_set_t</a> that will be using the resulting guard condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the guard condition. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">anything</td><td><a class="el" href="namespacerclcpp_1_1exceptions.html#ad1d5563cfff9273f531a82c1dde13516" title="Throw a C++ std::exception which was created based on an rcl error.">rclcpp::exceptions::throw_from_rcl_error</a> can throw. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48cfd20fea94c8e029d23af17e751e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48cfd20fea94c8e029d23af17e751e0a">&#9670;&nbsp;</a></span>release_interrupt_guard_condition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::Context::release_interrupt_guard_condition </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://docs.ros2.org/foxy/api/rcl/structrcl__wait__set__t.html">rcl_wait_set_t</a> *&#160;</td>
          <td class="paramname"><em>wait_set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release the previously allocated guard condition which is triggered when interrupted. </p>
<p>If you previously called <a class="el" href="classrclcpp_1_1Context.html#a79e1bee2976ea83ec93518b3bc359b78" title="Get a handle to the guard condition which is triggered when interrupted.">get_interrupt_guard_condition()</a> for a given wait set to get a interrupt guard condition, then you should call <a class="el" href="classrclcpp_1_1Context.html#a48cfd20fea94c8e029d23af17e751e0a" title="Release the previously allocated guard condition which is triggered when interrupted.">release_interrupt_guard_condition()</a> when you're done, to free that condition. Will throw an exception if <a class="el" href="classrclcpp_1_1Context.html#a79e1bee2976ea83ec93518b3bc359b78" title="Get a handle to the guard condition which is triggered when interrupted.">get_interrupt_guard_condition()</a> wasn't previously called for the given wait set.</p>
<p>After calling this, the pointer returned by <a class="el" href="classrclcpp_1_1Context.html#a79e1bee2976ea83ec93518b3bc359b78" title="Get a handle to the guard condition which is triggered when interrupted.">get_interrupt_guard_condition()</a> for the given wait_set is invalid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wait_set</td><td>Pointer to the <a class="elRef" href="http://docs.ros2.org/foxy/api/rcl/structrcl__wait__set__t.html">rcl_wait_set_t</a> that was using the resulting guard condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">anything</td><td><a class="el" href="namespacerclcpp_1_1exceptions.html#ad1d5563cfff9273f531a82c1dde13516" title="Throw a C++ std::exception which was created based on an rcl error.">rclcpp::exceptions::throw_from_rcl_error</a> can throw. </td></tr>
    <tr><td class="paramname"><a class="elRef" href="http://en.cppreference.com/w/cpp/error/runtime_error.html">std::runtime_error</a></td><td>if a nonexistent wait set is trying to release sigint guard condition. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4c2162e98eca3b8790666896c78fd14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4c2162e98eca3b8790666896c78fd14">&#9670;&nbsp;</a></span>release_interrupt_guard_condition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::Context::release_interrupt_guard_condition </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://docs.ros2.org/foxy/api/rcl/structrcl__wait__set__t.html">rcl_wait_set_t</a> *&#160;</td>
          <td class="paramname"><em>wait_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/new/nothrow_t.html">std::nothrow_t</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Nothrow version of <a class="el" href="classrclcpp_1_1Context.html#a48cfd20fea94c8e029d23af17e751e0a" title="Release the previously allocated guard condition which is triggered when interrupted.">release_interrupt_guard_condition()</a>, logs to RCLCPP_ERROR instead. </p>

</div>
</div>
<a id="ac2d2b3dc9f869675621b9c53714b9f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d2b3dc9f869675621b9c53714b9f86">&#9670;&nbsp;</a></span>interrupt_all_wait_sets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rclcpp::Context::interrupt_all_wait_sets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interrupt any blocking executors, or wait sets associated with this context. </p>

</div>
</div>
<a id="a433b110b4d305be6b690ec3e08f7ec28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a433b110b4d305be6b690ec3e08f7ec28">&#9670;&nbsp;</a></span>get_sub_context()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SubContext , typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt;SubContext&gt; rclcpp::Context::get_sub_context </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a singleton instance for the SubContext type, constructing one if necessary. </p>

</div>
</div>
<a id="ac0cafbb959c061a01dd0fe807cd31f42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0cafbb959c061a01dd0fe807cd31f42">&#9670;&nbsp;</a></span>clean_up()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rclcpp::Context::clean_up </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/rclcpp/<a class="el" href="context_8hpp_source.html">context.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
