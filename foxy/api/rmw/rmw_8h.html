<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rmw: include/rmw/rmw.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rmw
   &#160;<span id="projectnumber">master</span>
   </div>
   <div id="projectbrief">C API providing a middleware abstraction layer which is used to implement the rest of ROS.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_f1863b20b54cc3d25893e93314d6cb7b.html">rmw</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rmw.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &quot;<a class="elRef" href="http://docs.ros2.org/foxy/api/rcutils/macros_8h.html">rcutils/macros.h</a>&quot;</code><br />
<code>#include &quot;<a class="elRef" href="http://docs.ros2.org/foxy/api/rcutils/types_8h.html">rcutils/types.h</a>&quot;</code><br />
<code>#include &quot;rosidl_runtime_c/message_type_support_struct.h&quot;</code><br />
<code>#include &quot;rosidl_runtime_c/service_type_support_struct.h&quot;</code><br />
<code>#include &quot;rosidl_runtime_c/sequence_bound.h&quot;</code><br />
<code>#include &quot;<a class="el" href="init_8h_source.html">rmw/init.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="macros_8h_source.html">rmw/macros.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="qos__profiles_8h_source.html">rmw/qos_profiles.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="subscription__options_8h_source.html">rmw/subscription_options.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="message__sequence_8h_source.html">rmw/message_sequence.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="types_8h_source.html">rmw/types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="visibility__control_8h_source.html">rmw/visibility_control.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for rmw.h:</div>
<div class="dyncontent">
<div class="center"><img src="rmw_8h__incl.png" border="0" usemap="#include_2rmw_2rmw_8h" alt=""/></div>
<map name="include_2rmw_2rmw_8h" id="include_2rmw_2rmw_8h">
<area shape="rect" title=" " alt="" coords="1651,5,1797,32"/>
<area shape="rect" title=" " alt="" coords="1505,483,1588,509"/>
<area shape="rect" title=" " alt="" coords="1663,244,1737,271"/>
<area shape="rect" title=" " alt="" coords="1410,565,1481,591"/>
<area shape="rect" href="http://docs.ros2.org/foxy/api/rcutils/macros_8h.html.html" title=" " alt="" coords="43,647,170,673"/>
<area shape="rect" href="http://docs.ros2.org/foxy/api/rcutils/types_8h.html.html" title=" " alt="" coords="1913,87,2028,114"/>
<area shape="rect" title=" " alt="" coords="2053,80,2246,121"/>
<area shape="rect" title=" " alt="" coords="2271,80,2452,121"/>
<area shape="rect" title=" " alt="" coords="2477,80,2673,121"/>
<area shape="rect" href="init_8h.html" title=" " alt="" coords="871,244,959,271"/>
<area shape="rect" href="macros_8h.html" title=" " alt="" coords="119,565,246,591"/>
<area shape="rect" href="visibility__control_8h.html" title=" " alt="" coords="757,557,880,599"/>
<area shape="rect" href="qos__profiles_8h.html" title=" " alt="" coords="1321,87,1468,114"/>
<area shape="rect" href="types_8h.html" title=" " alt="" coords="1290,169,1393,196"/>
<area shape="rect" href="subscription__options_8h.html" title=" " alt="" coords="1045,87,1246,114"/>
<area shape="rect" href="message__sequence_8h.html" title=" " alt="" coords="1492,87,1687,114"/>
<area shape="rect" href="init__options_8h.html" title=" " alt="" coords="843,326,986,353"/>
<area shape="rect" href="ret__types_8h.html" title=" " alt="" coords="1280,483,1408,509"/>
<area shape="rect" href="http://docs.ros2.org/foxy/api/rcutils/allocator_8h.html.html" title=" " alt="" coords="595,483,730,509"/>
<area shape="rect" href="domain__id_8h.html" title=" " alt="" coords="847,408,982,435"/>
<area shape="rect" href="localhost_8h.html" title=" " alt="" coords="697,408,823,435"/>
<area shape="rect" href="security__options_8h.html" title=" " alt="" coords="1210,408,1385,435"/>
<area shape="rect" href="http://docs.ros2.org/foxy/api/rcutils/logging_8h.html.html" title=" " alt="" coords="305,326,431,353"/>
<area shape="rect" href="serialized__message_8h.html" title=" " alt="" coords="1174,244,1370,271"/>
<area shape="rect" href="error__handling_8h.html" title="Functions and macros to interact with error handling mechanisms." alt="" coords="246,408,418,435"/>
<area shape="rect" href="http://docs.ros2.org/foxy/api/rcutils/error__handling_8h.html.html" title=" " alt="" coords="246,483,418,509"/>
<area shape="rect" href="http://docs.ros2.org/foxy/api/rcutils/uint8__array_8h.html.html" title=" " alt="" coords="1177,319,1316,360"/>
</map>
</div>
</div>
<p><a href="rmw_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6dfb314c4e5edf3c28b1fb1ffe992b0c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a6dfb314c4e5edf3c28b1fb1ffe992b0c">rmw_get_implementation_identifier</a> (void)</td></tr>
<tr class="memdesc:a6dfb314c4e5edf3c28b1fb1ffe992b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the rmw implementation being used.  <a href="rmw_8h.html#a6dfb314c4e5edf3c28b1fb1ffe992b0c">More...</a><br /></td></tr>
<tr class="separator:a6dfb314c4e5edf3c28b1fb1ffe992b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d6ce17ee198857a68292a73016f6a4"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a77d6ce17ee198857a68292a73016f6a4">rmw_get_serialization_format</a> (void)</td></tr>
<tr class="memdesc:a77d6ce17ee198857a68292a73016f6a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unique serialization format for this middleware.  <a href="rmw_8h.html#a77d6ce17ee198857a68292a73016f6a4">More...</a><br /></td></tr>
<tr class="separator:a77d6ce17ee198857a68292a73016f6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94295dc4642ec2e735916410e19f5e7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrmw__node__t.html">rmw_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a94295dc4642ec2e735916410e19f5e7c">rmw_create_node</a> (<a class="el" href="structrmw__context__t.html">rmw_context_t</a> *context, const char *name, const char *namespace_, size_t domain_id, bool localhost_only)</td></tr>
<tr class="memdesc:a94295dc4642ec2e735916410e19f5e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a node and return a handle to that node.  <a href="rmw_8h.html#a94295dc4642ec2e735916410e19f5e7c">More...</a><br /></td></tr>
<tr class="separator:a94295dc4642ec2e735916410e19f5e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a2c3d9d51ebf753d6c531ab3b42253b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a0a2c3d9d51ebf753d6c531ab3b42253b">rmw_destroy_node</a> (<a class="el" href="structrmw__node__t.html">rmw_node_t</a> *node)</td></tr>
<tr class="memdesc:a0a2c3d9d51ebf753d6c531ab3b42253b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a given node handle, reclaim the resources, and deallocate the node handle.  <a href="rmw_8h.html#a0a2c3d9d51ebf753d6c531ab3b42253b">More...</a><br /></td></tr>
<tr class="separator:a0a2c3d9d51ebf753d6c531ab3b42253b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92814c6dea3900199e792d67fa448756"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a92814c6dea3900199e792d67fa448756">RCUTILS_DEPRECATED_WITH_MSG</a> (&quot;rmw_node_assert_liveliness implementation was removed.&quot; &quot; If manual liveliness assertion is needed, use MANUAL_BY_TOPIC.&quot;) rmw_ret_t rmw_node_assert_liveliness(const <a class="el" href="structrmw__node__t.html">rmw_node_t</a> *node)</td></tr>
<tr class="separator:a92814c6dea3900199e792d67fa448756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ca2bdd798c7b8f69da46d85e8d0fb9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structrmw__guard__condition__t.html">rmw_guard_condition_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a52ca2bdd798c7b8f69da46d85e8d0fb9">rmw_node_get_graph_guard_condition</a> (const <a class="el" href="structrmw__node__t.html">rmw_node_t</a> *node)</td></tr>
<tr class="memdesc:a52ca2bdd798c7b8f69da46d85e8d0fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a guard condition which is triggered when the ROS graph changes.  <a href="rmw_8h.html#a52ca2bdd798c7b8f69da46d85e8d0fb9">More...</a><br /></td></tr>
<tr class="separator:a52ca2bdd798c7b8f69da46d85e8d0fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d45143cc18afb6dfbeb7abf7c99b8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#af8d45143cc18afb6dfbeb7abf7c99b8e">rmw_init_publisher_allocation</a> (const rosidl_message_type_support_t *type_support, const rosidl_runtime_c__Sequence__bound *message_bounds, <a class="el" href="structrmw__publisher__allocation__t.html">rmw_publisher_allocation_t</a> *allocation)</td></tr>
<tr class="memdesc:af8d45143cc18afb6dfbeb7abf7c99b8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a publisher allocation to be used with later publications.  <a href="rmw_8h.html#af8d45143cc18afb6dfbeb7abf7c99b8e">More...</a><br /></td></tr>
<tr class="separator:af8d45143cc18afb6dfbeb7abf7c99b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a8ee7b6eef8d2b843484e77ead4992f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a1a8ee7b6eef8d2b843484e77ead4992f">rmw_fini_publisher_allocation</a> (<a class="el" href="structrmw__publisher__allocation__t.html">rmw_publisher_allocation_t</a> *allocation)</td></tr>
<tr class="memdesc:a1a8ee7b6eef8d2b843484e77ead4992f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a publisher allocation object.  <a href="rmw_8h.html#a1a8ee7b6eef8d2b843484e77ead4992f">More...</a><br /></td></tr>
<tr class="separator:a1a8ee7b6eef8d2b843484e77ead4992f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88f271e589b70ac0084488281f4637d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrmw__publisher__options__t.html">rmw_publisher_options_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#af88f271e589b70ac0084488281f4637d">rmw_get_default_publisher_options</a> (void)</td></tr>
<tr class="memdesc:af88f271e589b70ac0084488281f4637d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="structrmw__publisher__options__t.html" title="Options that can be used to configure the creation of a publisher in rmw.">rmw_publisher_options_t</a> initialized with default values.  <a href="rmw_8h.html#af88f271e589b70ac0084488281f4637d">More...</a><br /></td></tr>
<tr class="separator:af88f271e589b70ac0084488281f4637d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a149b0600fa9ce696c83a63f0e1e806ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrmw__publisher__t.html">rmw_publisher_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a149b0600fa9ce696c83a63f0e1e806ce">rmw_create_publisher</a> (const <a class="el" href="structrmw__node__t.html">rmw_node_t</a> *node, const rosidl_message_type_support_t *type_support, const char *topic_name, const <a class="el" href="structrmw__qos__profile__t.html">rmw_qos_profile_t</a> *qos_policies, const <a class="el" href="structrmw__publisher__options__t.html">rmw_publisher_options_t</a> *publisher_options)</td></tr>
<tr class="memdesc:a149b0600fa9ce696c83a63f0e1e806ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and return an rmw publisher.  <a href="rmw_8h.html#a149b0600fa9ce696c83a63f0e1e806ce">More...</a><br /></td></tr>
<tr class="separator:a149b0600fa9ce696c83a63f0e1e806ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297f8ae702c5f1eb51c40928e735de74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a297f8ae702c5f1eb51c40928e735de74">rmw_destroy_publisher</a> (<a class="el" href="structrmw__node__t.html">rmw_node_t</a> *node, <a class="el" href="structrmw__publisher__t.html">rmw_publisher_t</a> *publisher)</td></tr>
<tr class="separator:a297f8ae702c5f1eb51c40928e735de74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0768752013e0a1ee2776a303d3fc074"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#ae0768752013e0a1ee2776a303d3fc074">rmw_borrow_loaned_message</a> (const <a class="el" href="structrmw__publisher__t.html">rmw_publisher_t</a> *publisher, const rosidl_message_type_support_t *type_support, void **ros_message)</td></tr>
<tr class="memdesc:ae0768752013e0a1ee2776a303d3fc074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Borrow a loaned message.  <a href="rmw_8h.html#ae0768752013e0a1ee2776a303d3fc074">More...</a><br /></td></tr>
<tr class="separator:ae0768752013e0a1ee2776a303d3fc074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd05b65f77e840f7276397fdbf64894"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#abbd05b65f77e840f7276397fdbf64894">rmw_return_loaned_message_from_publisher</a> (const <a class="el" href="structrmw__publisher__t.html">rmw_publisher_t</a> *publisher, void *loaned_message)</td></tr>
<tr class="memdesc:abbd05b65f77e840f7276397fdbf64894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a loaned message previously borrow from a publisher.  <a href="rmw_8h.html#abbd05b65f77e840f7276397fdbf64894">More...</a><br /></td></tr>
<tr class="separator:abbd05b65f77e840f7276397fdbf64894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab625a62ba2f32e3d3a7c7ca1f6e0dbd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#ab625a62ba2f32e3d3a7c7ca1f6e0dbd6">rmw_publish</a> (const <a class="el" href="structrmw__publisher__t.html">rmw_publisher_t</a> *publisher, const void *ros_message, <a class="el" href="structrmw__publisher__allocation__t.html">rmw_publisher_allocation_t</a> *allocation)</td></tr>
<tr class="memdesc:ab625a62ba2f32e3d3a7c7ca1f6e0dbd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish a given ros_message.  <a href="rmw_8h.html#ab625a62ba2f32e3d3a7c7ca1f6e0dbd6">More...</a><br /></td></tr>
<tr class="separator:ab625a62ba2f32e3d3a7c7ca1f6e0dbd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01da69d8613952343abd5d65107399a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#ab01da69d8613952343abd5d65107399a">rmw_publish_loaned_message</a> (const <a class="el" href="structrmw__publisher__t.html">rmw_publisher_t</a> *publisher, void *ros_message, <a class="el" href="structrmw__publisher__allocation__t.html">rmw_publisher_allocation_t</a> *allocation)</td></tr>
<tr class="memdesc:ab01da69d8613952343abd5d65107399a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish a loaned ros_message.  <a href="rmw_8h.html#ab01da69d8613952343abd5d65107399a">More...</a><br /></td></tr>
<tr class="separator:ab01da69d8613952343abd5d65107399a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a046ba6f8ff184ebb01ab269b31a49f33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a046ba6f8ff184ebb01ab269b31a49f33">rmw_publisher_count_matched_subscriptions</a> (const <a class="el" href="structrmw__publisher__t.html">rmw_publisher_t</a> *publisher, size_t *subscription_count)</td></tr>
<tr class="memdesc:a046ba6f8ff184ebb01ab269b31a49f33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the number of matched subscriptions to a publisher.  <a href="rmw_8h.html#a046ba6f8ff184ebb01ab269b31a49f33">More...</a><br /></td></tr>
<tr class="separator:a046ba6f8ff184ebb01ab269b31a49f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a809010ecc3e404d8880382e2d4b35976"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a809010ecc3e404d8880382e2d4b35976">rmw_publisher_get_actual_qos</a> (const <a class="el" href="structrmw__publisher__t.html">rmw_publisher_t</a> *publisher, <a class="el" href="structrmw__qos__profile__t.html">rmw_qos_profile_t</a> *qos)</td></tr>
<tr class="memdesc:a809010ecc3e404d8880382e2d4b35976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the actual qos settings of the publisher.  <a href="rmw_8h.html#a809010ecc3e404d8880382e2d4b35976">More...</a><br /></td></tr>
<tr class="separator:a809010ecc3e404d8880382e2d4b35976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca69c33387b6185146c3f115ec2a24a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#abca69c33387b6185146c3f115ec2a24a">rmw_publish_serialized_message</a> (const <a class="el" href="structrmw__publisher__t.html">rmw_publisher_t</a> *publisher, const <a class="el" href="serialized__message_8h.html#ac1f977c2322bf36dc67f58235ee157ed">rmw_serialized_message_t</a> *serialized_message, <a class="el" href="structrmw__publisher__allocation__t.html">rmw_publisher_allocation_t</a> *allocation)</td></tr>
<tr class="memdesc:abca69c33387b6185146c3f115ec2a24a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish an already serialized message.  <a href="rmw_8h.html#abca69c33387b6185146c3f115ec2a24a">More...</a><br /></td></tr>
<tr class="separator:abca69c33387b6185146c3f115ec2a24a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c172e30e87562f7f7ad25bae8b0ec8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a0c172e30e87562f7f7ad25bae8b0ec8b">rmw_get_serialized_message_size</a> (const rosidl_message_type_support_t *type_support, const rosidl_runtime_c__Sequence__bound *message_bounds, size_t *size)</td></tr>
<tr class="memdesc:a0c172e30e87562f7f7ad25bae8b0ec8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the size of a serialized message.  <a href="rmw_8h.html#a0c172e30e87562f7f7ad25bae8b0ec8b">More...</a><br /></td></tr>
<tr class="separator:a0c172e30e87562f7f7ad25bae8b0ec8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4025992c2194103d3fe417d2373e95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a1e4025992c2194103d3fe417d2373e95">rmw_publisher_assert_liveliness</a> (const <a class="el" href="structrmw__publisher__t.html">rmw_publisher_t</a> *publisher)</td></tr>
<tr class="memdesc:a1e4025992c2194103d3fe417d2373e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually assert that this Publisher is alive (for RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC)  <a href="rmw_8h.html#a1e4025992c2194103d3fe417d2373e95">More...</a><br /></td></tr>
<tr class="separator:a1e4025992c2194103d3fe417d2373e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787c040bb59b0470ba51eee7e2bc04cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a787c040bb59b0470ba51eee7e2bc04cd">rmw_serialize</a> (const void *ros_message, const rosidl_message_type_support_t *type_support, <a class="el" href="serialized__message_8h.html#ac1f977c2322bf36dc67f58235ee157ed">rmw_serialized_message_t</a> *serialized_message)</td></tr>
<tr class="memdesc:a787c040bb59b0470ba51eee7e2bc04cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a ROS message into a rmw_serialized_message_t.  <a href="rmw_8h.html#a787c040bb59b0470ba51eee7e2bc04cd">More...</a><br /></td></tr>
<tr class="separator:a787c040bb59b0470ba51eee7e2bc04cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dee9c2eed962055a68febe9622f807c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a9dee9c2eed962055a68febe9622f807c">rmw_deserialize</a> (const <a class="el" href="serialized__message_8h.html#ac1f977c2322bf36dc67f58235ee157ed">rmw_serialized_message_t</a> *serialized_message, const rosidl_message_type_support_t *type_support, void *ros_message)</td></tr>
<tr class="memdesc:a9dee9c2eed962055a68febe9622f807c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize a ROS message.  <a href="rmw_8h.html#a9dee9c2eed962055a68febe9622f807c">More...</a><br /></td></tr>
<tr class="separator:a9dee9c2eed962055a68febe9622f807c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68cb3b9b96efa6d370257d83598d4bed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a68cb3b9b96efa6d370257d83598d4bed">rmw_init_subscription_allocation</a> (const rosidl_message_type_support_t *type_support, const rosidl_runtime_c__Sequence__bound *message_bounds, <a class="el" href="structrmw__subscription__allocation__t.html">rmw_subscription_allocation_t</a> *allocation)</td></tr>
<tr class="memdesc:a68cb3b9b96efa6d370257d83598d4bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a subscription allocation to be used with later <code>take</code>s.  <a href="rmw_8h.html#a68cb3b9b96efa6d370257d83598d4bed">More...</a><br /></td></tr>
<tr class="separator:a68cb3b9b96efa6d370257d83598d4bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e2408746a0e03bdaa290ef32780253"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a26e2408746a0e03bdaa290ef32780253">rmw_fini_subscription_allocation</a> (<a class="el" href="structrmw__subscription__allocation__t.html">rmw_subscription_allocation_t</a> *allocation)</td></tr>
<tr class="memdesc:a26e2408746a0e03bdaa290ef32780253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a publisher allocation object.  <a href="rmw_8h.html#a26e2408746a0e03bdaa290ef32780253">More...</a><br /></td></tr>
<tr class="separator:a26e2408746a0e03bdaa290ef32780253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a864d424c6aa5fc57b1ca3dbe19a697"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrmw__subscription__t.html">rmw_subscription_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a3a864d424c6aa5fc57b1ca3dbe19a697">rmw_create_subscription</a> (const <a class="el" href="structrmw__node__t.html">rmw_node_t</a> *node, const rosidl_message_type_support_t *type_support, const char *topic_name, const <a class="el" href="structrmw__qos__profile__t.html">rmw_qos_profile_t</a> *qos_policies, const <a class="el" href="structrmw__subscription__options__t.html">rmw_subscription_options_t</a> *subscription_options)</td></tr>
<tr class="memdesc:a3a864d424c6aa5fc57b1ca3dbe19a697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and return an rmw subscription.  <a href="rmw_8h.html#a3a864d424c6aa5fc57b1ca3dbe19a697">More...</a><br /></td></tr>
<tr class="separator:a3a864d424c6aa5fc57b1ca3dbe19a697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606270f7d253dba6eb9c279061bd2b6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a606270f7d253dba6eb9c279061bd2b6c">rmw_destroy_subscription</a> (<a class="el" href="structrmw__node__t.html">rmw_node_t</a> *node, <a class="el" href="structrmw__subscription__t.html">rmw_subscription_t</a> *subscription)</td></tr>
<tr class="separator:a606270f7d253dba6eb9c279061bd2b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f83284d1a1a2de0cbbc270fab7e2254"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a7f83284d1a1a2de0cbbc270fab7e2254">rmw_subscription_count_matched_publishers</a> (const <a class="el" href="structrmw__subscription__t.html">rmw_subscription_t</a> *subscription, size_t *publisher_count)</td></tr>
<tr class="memdesc:a7f83284d1a1a2de0cbbc270fab7e2254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the number of matched publishers to a subscription.  <a href="rmw_8h.html#a7f83284d1a1a2de0cbbc270fab7e2254">More...</a><br /></td></tr>
<tr class="separator:a7f83284d1a1a2de0cbbc270fab7e2254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2db56457082adaf379577e4f963bce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a1b2db56457082adaf379577e4f963bce">rmw_subscription_get_actual_qos</a> (const <a class="el" href="structrmw__subscription__t.html">rmw_subscription_t</a> *subscription, <a class="el" href="structrmw__qos__profile__t.html">rmw_qos_profile_t</a> *qos)</td></tr>
<tr class="memdesc:a1b2db56457082adaf379577e4f963bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the actual qos settings of the subscription.  <a href="rmw_8h.html#a1b2db56457082adaf379577e4f963bce">More...</a><br /></td></tr>
<tr class="separator:a1b2db56457082adaf379577e4f963bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9bf29af7069593e2f8dfa2296710080"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#af9bf29af7069593e2f8dfa2296710080">rmw_take</a> (const <a class="el" href="structrmw__subscription__t.html">rmw_subscription_t</a> *subscription, void *ros_message, bool *taken, <a class="el" href="structrmw__subscription__allocation__t.html">rmw_subscription_allocation_t</a> *allocation)</td></tr>
<tr class="memdesc:af9bf29af7069593e2f8dfa2296710080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take an incoming message from a subscription.  <a href="rmw_8h.html#af9bf29af7069593e2f8dfa2296710080">More...</a><br /></td></tr>
<tr class="separator:af9bf29af7069593e2f8dfa2296710080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8498c763a02e0fe9203ab6c9dfba0408"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a8498c763a02e0fe9203ab6c9dfba0408">rmw_take_with_info</a> (const <a class="el" href="structrmw__subscription__t.html">rmw_subscription_t</a> *subscription, void *ros_message, bool *taken, <a class="el" href="structrmw__message__info__t.html">rmw_message_info_t</a> *message_info, <a class="el" href="structrmw__subscription__allocation__t.html">rmw_subscription_allocation_t</a> *allocation)</td></tr>
<tr class="memdesc:a8498c763a02e0fe9203ab6c9dfba0408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take an incoming message from a subscription with additional metadata.  <a href="rmw_8h.html#a8498c763a02e0fe9203ab6c9dfba0408">More...</a><br /></td></tr>
<tr class="separator:a8498c763a02e0fe9203ab6c9dfba0408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec493534247a1c57a1a0579b0f4120ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#aec493534247a1c57a1a0579b0f4120ef">rmw_take_sequence</a> (const <a class="el" href="structrmw__subscription__t.html">rmw_subscription_t</a> *subscription, size_t count, <a class="el" href="structrmw__message__sequence__t.html">rmw_message_sequence_t</a> *message_sequence, <a class="el" href="structrmw__message__info__sequence__t.html">rmw_message_info_sequence_t</a> *message_info_sequence, size_t *taken, <a class="el" href="structrmw__subscription__allocation__t.html">rmw_subscription_allocation_t</a> *allocation)</td></tr>
<tr class="memdesc:aec493534247a1c57a1a0579b0f4120ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take multiple incoming messages from a subscription with additional metadata.  <a href="rmw_8h.html#aec493534247a1c57a1a0579b0f4120ef">More...</a><br /></td></tr>
<tr class="separator:aec493534247a1c57a1a0579b0f4120ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef04c20dab1bc6cdb27343046ccab28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a8ef04c20dab1bc6cdb27343046ccab28">rmw_take_serialized_message</a> (const <a class="el" href="structrmw__subscription__t.html">rmw_subscription_t</a> *subscription, <a class="el" href="serialized__message_8h.html#ac1f977c2322bf36dc67f58235ee157ed">rmw_serialized_message_t</a> *serialized_message, bool *taken, <a class="el" href="structrmw__subscription__allocation__t.html">rmw_subscription_allocation_t</a> *allocation)</td></tr>
<tr class="memdesc:a8ef04c20dab1bc6cdb27343046ccab28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a message without deserializing it.  <a href="rmw_8h.html#a8ef04c20dab1bc6cdb27343046ccab28">More...</a><br /></td></tr>
<tr class="separator:a8ef04c20dab1bc6cdb27343046ccab28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a8f380a5f4a5b37a48396a74a3238c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a16a8f380a5f4a5b37a48396a74a3238c">rmw_take_serialized_message_with_info</a> (const <a class="el" href="structrmw__subscription__t.html">rmw_subscription_t</a> *subscription, <a class="el" href="serialized__message_8h.html#ac1f977c2322bf36dc67f58235ee157ed">rmw_serialized_message_t</a> *serialized_message, bool *taken, <a class="el" href="structrmw__message__info__t.html">rmw_message_info_t</a> *message_info, <a class="el" href="structrmw__subscription__allocation__t.html">rmw_subscription_allocation_t</a> *allocation)</td></tr>
<tr class="memdesc:a16a8f380a5f4a5b37a48396a74a3238c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a message without deserializing it and with its additional message information.  <a href="rmw_8h.html#a16a8f380a5f4a5b37a48396a74a3238c">More...</a><br /></td></tr>
<tr class="separator:a16a8f380a5f4a5b37a48396a74a3238c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95da7643ef0f44a457361151bf6cbc3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a95da7643ef0f44a457361151bf6cbc3c">rmw_take_loaned_message</a> (const <a class="el" href="structrmw__subscription__t.html">rmw_subscription_t</a> *subscription, void **loaned_message, bool *taken, <a class="el" href="structrmw__subscription__allocation__t.html">rmw_subscription_allocation_t</a> *allocation)</td></tr>
<tr class="memdesc:a95da7643ef0f44a457361151bf6cbc3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a loaned message.  <a href="rmw_8h.html#a95da7643ef0f44a457361151bf6cbc3c">More...</a><br /></td></tr>
<tr class="separator:a95da7643ef0f44a457361151bf6cbc3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163d11727369827302b7f021cea837d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a163d11727369827302b7f021cea837d4">rmw_take_loaned_message_with_info</a> (const <a class="el" href="structrmw__subscription__t.html">rmw_subscription_t</a> *subscription, void **loaned_message, bool *taken, <a class="el" href="structrmw__message__info__t.html">rmw_message_info_t</a> *message_info, <a class="el" href="structrmw__subscription__allocation__t.html">rmw_subscription_allocation_t</a> *allocation)</td></tr>
<tr class="memdesc:a163d11727369827302b7f021cea837d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a loaned message and with its additional message information.  <a href="rmw_8h.html#a163d11727369827302b7f021cea837d4">More...</a><br /></td></tr>
<tr class="separator:a163d11727369827302b7f021cea837d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c931744261eaa9d362e145193cf7d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#ae1c931744261eaa9d362e145193cf7d8">rmw_return_loaned_message_from_subscription</a> (const <a class="el" href="structrmw__subscription__t.html">rmw_subscription_t</a> *subscription, void *loaned_message)</td></tr>
<tr class="memdesc:ae1c931744261eaa9d362e145193cf7d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a loaned message previously taken from a subscription.  <a href="rmw_8h.html#ae1c931744261eaa9d362e145193cf7d8">More...</a><br /></td></tr>
<tr class="separator:ae1c931744261eaa9d362e145193cf7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208bb1dd4d3c77cceee53ceba7abb8ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrmw__client__t.html">rmw_client_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a208bb1dd4d3c77cceee53ceba7abb8ac">rmw_create_client</a> (const <a class="el" href="structrmw__node__t.html">rmw_node_t</a> *node, const rosidl_service_type_support_t *type_support, const char *service_name, const <a class="el" href="structrmw__qos__profile__t.html">rmw_qos_profile_t</a> *qos_policies)</td></tr>
<tr class="memdesc:a208bb1dd4d3c77cceee53ceba7abb8ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an rmw client to communicate with the specified service.  <a href="rmw_8h.html#a208bb1dd4d3c77cceee53ceba7abb8ac">More...</a><br /></td></tr>
<tr class="separator:a208bb1dd4d3c77cceee53ceba7abb8ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da675215fe98e4bcb8cf202c3503c5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a3da675215fe98e4bcb8cf202c3503c5e">rmw_destroy_client</a> (<a class="el" href="structrmw__node__t.html">rmw_node_t</a> *node, <a class="el" href="structrmw__client__t.html">rmw_client_t</a> *client)</td></tr>
<tr class="memdesc:a3da675215fe98e4bcb8cf202c3503c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy and unregister a service client.  <a href="rmw_8h.html#a3da675215fe98e4bcb8cf202c3503c5e">More...</a><br /></td></tr>
<tr class="separator:a3da675215fe98e4bcb8cf202c3503c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9abc3e631cd2529f168d04be97f1db29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a9abc3e631cd2529f168d04be97f1db29">rmw_send_request</a> (const <a class="el" href="structrmw__client__t.html">rmw_client_t</a> *client, const void *ros_request, int64_t *sequence_id)</td></tr>
<tr class="memdesc:a9abc3e631cd2529f168d04be97f1db29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a service request to the rmw server.  <a href="rmw_8h.html#a9abc3e631cd2529f168d04be97f1db29">More...</a><br /></td></tr>
<tr class="separator:a9abc3e631cd2529f168d04be97f1db29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31be4bb944b42b553a700a762d789dee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a31be4bb944b42b553a700a762d789dee">rmw_take_response</a> (const <a class="el" href="structrmw__client__t.html">rmw_client_t</a> *client, <a class="el" href="structrmw__service__info__t.html">rmw_service_info_t</a> *request_header, void *ros_response, bool *taken)</td></tr>
<tr class="memdesc:a31be4bb944b42b553a700a762d789dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to get the response from a service request.  <a href="rmw_8h.html#a31be4bb944b42b553a700a762d789dee">More...</a><br /></td></tr>
<tr class="separator:a31be4bb944b42b553a700a762d789dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cac43fcb2ffd40268e472e94159ee5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrmw__service__t.html">rmw_service_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a41cac43fcb2ffd40268e472e94159ee5">rmw_create_service</a> (const <a class="el" href="structrmw__node__t.html">rmw_node_t</a> *node, const rosidl_service_type_support_t *type_support, const char *service_name, const <a class="el" href="structrmw__qos__profile__t.html">rmw_qos_profile_t</a> *qos_policies)</td></tr>
<tr class="memdesc:a41cac43fcb2ffd40268e472e94159ee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an rmw service server that responds to requests.  <a href="rmw_8h.html#a41cac43fcb2ffd40268e472e94159ee5">More...</a><br /></td></tr>
<tr class="separator:a41cac43fcb2ffd40268e472e94159ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39dc6f857dfa69a69bb198dc7fa96fed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a39dc6f857dfa69a69bb198dc7fa96fed">rmw_destroy_service</a> (<a class="el" href="structrmw__node__t.html">rmw_node_t</a> *node, <a class="el" href="structrmw__service__t.html">rmw_service_t</a> *service)</td></tr>
<tr class="memdesc:a39dc6f857dfa69a69bb198dc7fa96fed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy and unregister the service from this node.  <a href="rmw_8h.html#a39dc6f857dfa69a69bb198dc7fa96fed">More...</a><br /></td></tr>
<tr class="separator:a39dc6f857dfa69a69bb198dc7fa96fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5fdf79993ad434417b5edabe2023813"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#af5fdf79993ad434417b5edabe2023813">rmw_take_request</a> (const <a class="el" href="structrmw__service__t.html">rmw_service_t</a> *service, <a class="el" href="structrmw__service__info__t.html">rmw_service_info_t</a> *request_header, void *ros_request, bool *taken)</td></tr>
<tr class="memdesc:af5fdf79993ad434417b5edabe2023813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to take a request from this service's request buffer.  <a href="rmw_8h.html#af5fdf79993ad434417b5edabe2023813">More...</a><br /></td></tr>
<tr class="separator:af5fdf79993ad434417b5edabe2023813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb55ba2b2a957cefb0a77b77ddc5afda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#abb55ba2b2a957cefb0a77b77ddc5afda">rmw_send_response</a> (const <a class="el" href="structrmw__service__t.html">rmw_service_t</a> *service, <a class="el" href="structrmw__request__id__t.html">rmw_request_id_t</a> *request_header, void *ros_response)</td></tr>
<tr class="memdesc:abb55ba2b2a957cefb0a77b77ddc5afda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send response to a client's request.  <a href="rmw_8h.html#abb55ba2b2a957cefb0a77b77ddc5afda">More...</a><br /></td></tr>
<tr class="separator:abb55ba2b2a957cefb0a77b77ddc5afda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6994bb0042f3a057aa2657149b9f79b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrmw__guard__condition__t.html">rmw_guard_condition_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a6994bb0042f3a057aa2657149b9f79b4">rmw_create_guard_condition</a> (<a class="el" href="structrmw__context__t.html">rmw_context_t</a> *context)</td></tr>
<tr class="memdesc:a6994bb0042f3a057aa2657149b9f79b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a guard condition and return a handle to that guard condition.  <a href="rmw_8h.html#a6994bb0042f3a057aa2657149b9f79b4">More...</a><br /></td></tr>
<tr class="separator:a6994bb0042f3a057aa2657149b9f79b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdbd5e36cc0c98e9ab4b018d3a13dfe2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#acdbd5e36cc0c98e9ab4b018d3a13dfe2">rmw_destroy_guard_condition</a> (<a class="el" href="structrmw__guard__condition__t.html">rmw_guard_condition_t</a> *guard_condition)</td></tr>
<tr class="memdesc:acdbd5e36cc0c98e9ab4b018d3a13dfe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a given guard condition handle, reclaim the resources, and deallocate the handle.  <a href="rmw_8h.html#acdbd5e36cc0c98e9ab4b018d3a13dfe2">More...</a><br /></td></tr>
<tr class="separator:acdbd5e36cc0c98e9ab4b018d3a13dfe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c06507746a703e9a053c87c4a711fdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a2c06507746a703e9a053c87c4a711fdc">rmw_trigger_guard_condition</a> (const <a class="el" href="structrmw__guard__condition__t.html">rmw_guard_condition_t</a> *guard_condition)</td></tr>
<tr class="separator:a2c06507746a703e9a053c87c4a711fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29d471adffff01c7738ec165f571aca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrmw__wait__set__t.html">rmw_wait_set_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#ac29d471adffff01c7738ec165f571aca">rmw_create_wait_set</a> (<a class="el" href="structrmw__context__t.html">rmw_context_t</a> *context, size_t max_conditions)</td></tr>
<tr class="memdesc:ac29d471adffff01c7738ec165f571aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a wait set to store conditions that the middleware will block on.  <a href="rmw_8h.html#ac29d471adffff01c7738ec165f571aca">More...</a><br /></td></tr>
<tr class="separator:ac29d471adffff01c7738ec165f571aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42465b1d9fddb3556a1a9f5d44d60b6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a42465b1d9fddb3556a1a9f5d44d60b6c">rmw_destroy_wait_set</a> (<a class="el" href="structrmw__wait__set__t.html">rmw_wait_set_t</a> *wait_set)</td></tr>
<tr class="memdesc:a42465b1d9fddb3556a1a9f5d44d60b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy and free memory of this wait_set.  <a href="rmw_8h.html#a42465b1d9fddb3556a1a9f5d44d60b6c">More...</a><br /></td></tr>
<tr class="separator:a42465b1d9fddb3556a1a9f5d44d60b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f480dd59075e80288fb596b2951be2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a5f480dd59075e80288fb596b2951be2b">rmw_wait</a> (<a class="el" href="structrmw__subscriptions__t.html">rmw_subscriptions_t</a> *subscriptions, <a class="el" href="structrmw__guard__conditions__t.html">rmw_guard_conditions_t</a> *guard_conditions, <a class="el" href="structrmw__services__t.html">rmw_services_t</a> *services, <a class="el" href="structrmw__clients__t.html">rmw_clients_t</a> *clients, <a class="el" href="structrmw__events__t.html">rmw_events_t</a> *events, <a class="el" href="structrmw__wait__set__t.html">rmw_wait_set_t</a> *wait_set, const <a class="el" href="structrmw__time__t.html">rmw_time_t</a> *wait_timeout)</td></tr>
<tr class="memdesc:a5f480dd59075e80288fb596b2951be2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits on sets of different waitable entities and returns when one is ready.  <a href="rmw_8h.html#a5f480dd59075e80288fb596b2951be2b">More...</a><br /></td></tr>
<tr class="separator:a5f480dd59075e80288fb596b2951be2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a897976680c178e0be5ef4d4a17f9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a64a897976680c178e0be5ef4d4a17f9f">rmw_get_node_names</a> (const <a class="el" href="structrmw__node__t.html">rmw_node_t</a> *node, <a class="elRef" href="http://docs.ros2.org/foxy/api/rcutils/structrcutils__string__array__t.html">rcutils_string_array_t</a> *node_names, <a class="elRef" href="http://docs.ros2.org/foxy/api/rcutils/structrcutils__string__array__t.html">rcutils_string_array_t</a> *node_namespaces)</td></tr>
<tr class="memdesc:a64a897976680c178e0be5ef4d4a17f9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of node name and namespaces discovered via a node.  <a href="rmw_8h.html#a64a897976680c178e0be5ef4d4a17f9f">More...</a><br /></td></tr>
<tr class="separator:a64a897976680c178e0be5ef4d4a17f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9388d5cc9d2cb460e48f4212735c935"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#aa9388d5cc9d2cb460e48f4212735c935">rmw_get_node_names_with_enclaves</a> (const <a class="el" href="structrmw__node__t.html">rmw_node_t</a> *node, <a class="elRef" href="http://docs.ros2.org/foxy/api/rcutils/structrcutils__string__array__t.html">rcutils_string_array_t</a> *node_names, <a class="elRef" href="http://docs.ros2.org/foxy/api/rcutils/structrcutils__string__array__t.html">rcutils_string_array_t</a> *node_namespaces, <a class="elRef" href="http://docs.ros2.org/foxy/api/rcutils/structrcutils__string__array__t.html">rcutils_string_array_t</a> *enclaves)</td></tr>
<tr class="memdesc:aa9388d5cc9d2cb460e48f4212735c935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of node name and namespaces discovered via a node with its enclave.  <a href="rmw_8h.html#aa9388d5cc9d2cb460e48f4212735c935">More...</a><br /></td></tr>
<tr class="separator:aa9388d5cc9d2cb460e48f4212735c935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c761fb53a29f44b41fc299ffbb9cb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a83c761fb53a29f44b41fc299ffbb9cb4">rmw_count_publishers</a> (const <a class="el" href="structrmw__node__t.html">rmw_node_t</a> *node, const char *topic_name, size_t *count)</td></tr>
<tr class="memdesc:a83c761fb53a29f44b41fc299ffbb9cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of publishers matching a topic name.  <a href="rmw_8h.html#a83c761fb53a29f44b41fc299ffbb9cb4">More...</a><br /></td></tr>
<tr class="separator:a83c761fb53a29f44b41fc299ffbb9cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d48df829636837092ef47f91514675e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a3d48df829636837092ef47f91514675e">rmw_count_subscribers</a> (const <a class="el" href="structrmw__node__t.html">rmw_node_t</a> *node, const char *topic_name, size_t *count)</td></tr>
<tr class="memdesc:a3d48df829636837092ef47f91514675e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of subscribers matching a topic name.  <a href="rmw_8h.html#a3d48df829636837092ef47f91514675e">More...</a><br /></td></tr>
<tr class="separator:a3d48df829636837092ef47f91514675e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a846898b23af992f7f3eaa17eaf741e9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a846898b23af992f7f3eaa17eaf741e9f">rmw_get_gid_for_publisher</a> (const <a class="el" href="structrmw__publisher__t.html">rmw_publisher_t</a> *publisher, <a class="el" href="structrmw__gid__t.html">rmw_gid_t</a> *gid)</td></tr>
<tr class="memdesc:a846898b23af992f7f3eaa17eaf741e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unique identifier of the publisher.  <a href="rmw_8h.html#a846898b23af992f7f3eaa17eaf741e9f">More...</a><br /></td></tr>
<tr class="separator:a846898b23af992f7f3eaa17eaf741e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280fd9c0cf4fc49fbe6786b64b835194"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a280fd9c0cf4fc49fbe6786b64b835194">rmw_compare_gids_equal</a> (const <a class="el" href="structrmw__gid__t.html">rmw_gid_t</a> *gid1, const <a class="el" href="structrmw__gid__t.html">rmw_gid_t</a> *gid2, bool *result)</td></tr>
<tr class="memdesc:a280fd9c0cf4fc49fbe6786b64b835194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two gid objects are the same.  <a href="rmw_8h.html#a280fd9c0cf4fc49fbe6786b64b835194">More...</a><br /></td></tr>
<tr class="separator:a280fd9c0cf4fc49fbe6786b64b835194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0cec9687e5e4738aba7e061014eb3d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#af0cec9687e5e4738aba7e061014eb3d5">rmw_service_server_is_available</a> (const <a class="el" href="structrmw__node__t.html">rmw_node_t</a> *node, const <a class="el" href="structrmw__client__t.html">rmw_client_t</a> *client, bool *is_available)</td></tr>
<tr class="memdesc:af0cec9687e5e4738aba7e061014eb3d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a service server is available for the given service client.  <a href="rmw_8h.html#af0cec9687e5e4738aba7e061014eb3d5">More...</a><br /></td></tr>
<tr class="separator:af0cec9687e5e4738aba7e061014eb3d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95cc3dd8de47abb8a105d0b8a30419c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a95cc3dd8de47abb8a105d0b8a30419c9">rmw_set_log_severity</a> (<a class="el" href="types_8h.html#a0e0bd7d4ee1297d1a365f12fde05bceb">rmw_log_severity_t</a> severity)</td></tr>
<tr class="memdesc:a95cc3dd8de47abb8a105d0b8a30419c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current log severity.  <a href="rmw_8h.html#a95cc3dd8de47abb8a105d0b8a30419c9">More...</a><br /></td></tr>
<tr class="separator:a95cc3dd8de47abb8a105d0b8a30419c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6dfb314c4e5edf3c28b1fb1ffe992b0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dfb314c4e5edf3c28b1fb1ffe992b0c">&#9670;&nbsp;</a></span>rmw_get_implementation_identifier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rmw_get_implementation_identifier </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of the rmw implementation being used. </p>
<dl class="section return"><dt>Returns</dt><dd>Name of rmw implementation </dd></dl>

</div>
</div>
<a id="a77d6ce17ee198857a68292a73016f6a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d6ce17ee198857a68292a73016f6a4">&#9670;&nbsp;</a></span>rmw_get_serialization_format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rmw_get_serialization_format </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the unique serialization format for this middleware. </p>
<p>Return the format in which binary data is serialized. One middleware can only have one encoding. In contrast to the implementation identifier, the serialization format can be equal between multiple RMW implementations. This means, that the same binary messages can be deserialized by RMW implementations with the same format. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="rmw_8h.html#a787c040bb59b0470ba51eee7e2bc04cd" title="Serialize a ROS message into a rmw_serialized_message_t.">rmw_serialize</a> </dd>
<dd>
<a class="el" href="rmw_8h.html#a9dee9c2eed962055a68febe9622f807c" title="Deserialize a ROS message.">rmw_deserialize</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>serialization format </dd></dl>

</div>
</div>
<a id="a94295dc4642ec2e735916410e19f5e7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94295dc4642ec2e735916410e19f5e7c">&#9670;&nbsp;</a></span>rmw_create_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrmw__node__t.html">rmw_node_t</a>* rmw_create_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrmw__context__t.html">rmw_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>namespace_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>domain_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>localhost_only</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a node and return a handle to that node. </p>
<p>This function can fail, and therefore return <code>NULL</code>, if:</p><ul>
<li>context, name, namespace_, or security_options is <code>NULL</code></li>
<li>context, security_options is invalid</li>
<li>memory allocation fails during node creation</li>
<li>an unspecified error occurs</li>
</ul>
<p>The context must be non-null and valid, i.e. it has been initialized by <code><a class="el" href="init_8h.html#af74e9a1b897e41dc8f4c94a74bb9b1a5" title="Initialize the middleware with the given options, and yielding an context.">rmw_init()</a></code> and has not been finalized by <code><a class="el" href="init_8h.html#a36ece6fcb6294f21a0b69cb091e3ee5a" title="Shutdown the middleware for a given context.">rmw_shutdown()</a></code>.</p>
<p>The name and namespace_ should be valid node name and namespace, and this should be asserted by the caller (e.g. <code>rcl</code>).</p>
<p>The domain ID should be used to physically separate nodes at the communication graph level by the middleware. For RTPS/DDS this maps naturally to their concept of domain id.</p>
<p>The security options should always be non-null and encapsulate the essential security configurations for the node and its entities.</p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute </th><th class="markdownTableHeadNone">Adherence  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory </td><td class="markdownTableBodyNone">Yes  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe </td><td class="markdownTableBodyNone">No  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics </td><td class="markdownTableBodyNone">No [1]  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free </td><td class="markdownTableBodyNone">No [1]  </td></tr>
</table>
<p><em>[1] rmw implementation defined, check the implementation documentation</em></p>
<p>This should be defined by the rmw implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>init context that this node should be associated with </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>the node name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">namespace_</td><td>the node namespace </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">domain_id</td><td>the id of the domain that the node should join </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">security_options</td><td>the security configurations for the node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">localhost_only</td><td>whenever to use loopback only for communication or default network interfaces. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rmw node handle or <code>NULL</code> if there was an error </dd></dl>

</div>
</div>
<a id="a0a2c3d9d51ebf753d6c531ab3b42253b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a2c3d9d51ebf753d6c531ab3b42253b">&#9670;&nbsp;</a></span>rmw_destroy_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_destroy_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrmw__node__t.html">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a given node handle, reclaim the resources, and deallocate the node handle. </p>
<p>The method may assume - but should verify - that all publishers, subscribers, services, and clients created from this node have already been destroyed. If the rmw implementation chooses to verify instead of assume, it should return <code>RMW_RET_ERROR</code> and set a human readable error message if any entity created from this node has not yet been destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>the node handle to be destroyed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if node is null, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a92814c6dea3900199e792d67fa448756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92814c6dea3900199e792d67fa448756">&#9670;&nbsp;</a></span>RCUTILS_DEPRECATED_WITH_MSG()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RCUTILS_DEPRECATED_WITH_MSG </td>
          <td>(</td>
          <td class="paramtype">&quot;rmw_node_assert_liveliness implementation was removed.&quot; &quot; If manual liveliness assertion is&#160;</td>
          <td class="paramname"><em>needed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">use MANUAL_BY_TOPIC.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a52ca2bdd798c7b8f69da46d85e8d0fb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52ca2bdd798c7b8f69da46d85e8d0fb9">&#9670;&nbsp;</a></span>rmw_node_get_graph_guard_condition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structrmw__guard__condition__t.html">rmw_guard_condition_t</a>* rmw_node_get_graph_guard_condition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__node__t.html">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a guard condition which is triggered when the ROS graph changes. </p>
<p>The handle returned is a pointer to an internally held rmw guard condition. This function can fail, and therefore return <code>NULL</code>, if:</p><ul>
<li>node is <code>NULL</code></li>
<li>node is invalid</li>
</ul>
<p>The returned handle is made invalid if the node is destroyed or if <a class="el" href="init_8h.html#a36ece6fcb6294f21a0b69cb091e3ee5a" title="Shutdown the middleware for a given context.">rmw_shutdown()</a> is called.</p>
<p>The guard condition will be triggered anytime a change to the ROS graph occurs. A ROS graph change includes things like (but not limited to) a new publisher advertises, a new subscription is created, a new service becomes available, a subscription is canceled, etc.</p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute </th><th class="markdownTableHeadNone">Adherence  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory </td><td class="markdownTableBodyNone">No  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe </td><td class="markdownTableBodyNone">Yes  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics </td><td class="markdownTableBodyNone">No  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free </td><td class="markdownTableBodyNone">Yes  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>pointer to the rmw node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rmw guard condition handle if successful, otherwise <code>NULL</code> </dd></dl>

</div>
</div>
<a id="af8d45143cc18afb6dfbeb7abf7c99b8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8d45143cc18afb6dfbeb7abf7c99b8e">&#9670;&nbsp;</a></span>rmw_init_publisher_allocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_init_publisher_allocation </td>
          <td>(</td>
          <td class="paramtype">const rosidl_message_type_support_t *&#160;</td>
          <td class="paramname"><em>type_support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rosidl_runtime_c__Sequence__bound *&#160;</td>
          <td class="paramname"><em>message_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__publisher__allocation__t.html">rmw_publisher_allocation_t</a> *&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a publisher allocation to be used with later publications. </p>
<p>This creates an allocation object that can be used in conjunction with the rmw_publish method to perform more carefully control memory allocations.</p>
<p>This will allow the middleware to preallocate the correct amount of memory for a given message type and message bounds. As allocation is performed in this method, it will not be necessary to allocate in the <code>rmw_publish</code> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_support</td><td>Type support of the message to be preallocated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message_bounds</td><td>Bounds structure of the message to be preallocated. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">allocation</td><td>Allocation structure to be passed to <code>rmw_publish</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if an argument is null, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a1a8ee7b6eef8d2b843484e77ead4992f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a8ee7b6eef8d2b843484e77ead4992f">&#9670;&nbsp;</a></span>rmw_fini_publisher_allocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_fini_publisher_allocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrmw__publisher__allocation__t.html">rmw_publisher_allocation_t</a> *&#160;</td>
          <td class="paramname"><em>allocation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a publisher allocation object. </p>
<p>This deallocates any memory allocated by <code>rmw_init_publisher_allocation</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allocation</td><td>Allocation object to be destroyed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if argument is null, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="af88f271e589b70ac0084488281f4637d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af88f271e589b70ac0084488281f4637d">&#9670;&nbsp;</a></span>rmw_get_default_publisher_options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrmw__publisher__options__t.html">rmw_publisher_options_t</a> rmw_get_default_publisher_options </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <a class="el" href="structrmw__publisher__options__t.html" title="Options that can be used to configure the creation of a publisher in rmw.">rmw_publisher_options_t</a> initialized with default values. </p>

</div>
</div>
<a id="a149b0600fa9ce696c83a63f0e1e806ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a149b0600fa9ce696c83a63f0e1e806ce">&#9670;&nbsp;</a></span>rmw_create_publisher()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrmw__publisher__t.html">rmw_publisher_t</a>* rmw_create_publisher </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__node__t.html">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rosidl_message_type_support_t *&#160;</td>
          <td class="paramname"><em>type_support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrmw__qos__profile__t.html">rmw_qos_profile_t</a> *&#160;</td>
          <td class="paramname"><em>qos_policies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrmw__publisher__options__t.html">rmw_publisher_options_t</a> *&#160;</td>
          <td class="paramname"><em>publisher_options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and return an rmw publisher. </p>
<p>\TODO(wjwwood): add detailed documentation, adding a not about one of the arguments for now.</p>
<p>The argument <code>publisher_options</code> must not be nullptr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">publisher_options</td><td>options for configuring the publisher </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a297f8ae702c5f1eb51c40928e735de74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a297f8ae702c5f1eb51c40928e735de74">&#9670;&nbsp;</a></span>rmw_destroy_publisher()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_destroy_publisher </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrmw__node__t.html">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__publisher__t.html">rmw_publisher_t</a> *&#160;</td>
          <td class="paramname"><em>publisher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae0768752013e0a1ee2776a303d3fc074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0768752013e0a1ee2776a303d3fc074">&#9670;&nbsp;</a></span>rmw_borrow_loaned_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_borrow_loaned_message </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__publisher__t.html">rmw_publisher_t</a> *&#160;</td>
          <td class="paramname"><em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rosidl_message_type_support_t *&#160;</td>
          <td class="paramname"><em>type_support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>ros_message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Borrow a loaned message. </p>
<p>The memory allocated for the ros message belongs to the middleware and must not be deallocated. A call to </p><dl class="section see"><dt>See also</dt><dd>rmw_publish_loned_message as well as </dd>
<dd>
rmw_return_loaned_message_from_publisher` will return ownership of the loaned message back to the middleware.</dd></dl>
<p>In order to react to failures, the ros message is passed by pointer as an output parameter. Therefore, the pointer to the ros message has to be <code>null</code> and not previously allocated or else that memory is lost.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">publisher</td><td>Publisher to which the allocated message is associated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_support</td><td>Typesupport to which the internal ros message is allocated. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ros_message</td><td>The pointer to be filled with a valid ros message by the middleware. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if the ros message was correctly initialized, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if an argument other than the ros message is null, or </dd>
<dd>
<code>RMW_RET_BAD_ALLOC</code> if the ros message could not be correctly created, or </dd>
<dd>
<code>RMW_RET_UNSUPPORTED</code> if the rmw_implementation does not support loaned_message, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occured. </dd></dl>

</div>
</div>
<a id="abbd05b65f77e840f7276397fdbf64894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd05b65f77e840f7276397fdbf64894">&#9670;&nbsp;</a></span>rmw_return_loaned_message_from_publisher()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_return_loaned_message_from_publisher </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__publisher__t.html">rmw_publisher_t</a> *&#160;</td>
          <td class="paramname"><em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>loaned_message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a loaned message previously borrow from a publisher. </p>
<p>The ownership of the passed in ros message will be transferred back to the middleware. The middleware might deallocate and destroy the message so that the pointer is no longer guaranteed to be valid after this call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">publisher</td><td>Publisher to which the loaned message is associated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">loaned_message</td><td>Loaned message to be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if an argument is null, or </dd>
<dd>
<code>RMW_RET_UNSUPPORTED</code> if the rmw_implementation does not support loaned_message, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs and no message can be initialized. </dd></dl>

</div>
</div>
<a id="ab625a62ba2f32e3d3a7c7ca1f6e0dbd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab625a62ba2f32e3d3a7c7ca1f6e0dbd6">&#9670;&nbsp;</a></span>rmw_publish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_publish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__publisher__t.html">rmw_publisher_t</a> *&#160;</td>
          <td class="paramname"><em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ros_message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__publisher__allocation__t.html">rmw_publisher_allocation_t</a> *&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Publish a given ros_message. </p>
<p>Publish a given ROS message via a publisher.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">publisher</td><td>Publisher to be used to send message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ros_message</td><td>Message to be sent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocation</td><td>Specify preallocated memory to use (may be NULL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if publisher or ros_message is null, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="ab01da69d8613952343abd5d65107399a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab01da69d8613952343abd5d65107399a">&#9670;&nbsp;</a></span>rmw_publish_loaned_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_publish_loaned_message </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__publisher__t.html">rmw_publisher_t</a> *&#160;</td>
          <td class="paramname"><em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ros_message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__publisher__allocation__t.html">rmw_publisher_allocation_t</a> *&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Publish a loaned ros_message. </p>
<p>Publish a loaned ROS message via a publisher and return ownership of the loaned message back to the middleware.</p>
<p>In contrast to </p><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="rmw_8h.html#ab625a62ba2f32e3d3a7c7ca1f6e0dbd6" title="Publish a given ros_message.">rmw_publish</a></code> the ownership of the ros message is being transferred to the middleware which might deallocate the memory for it. Similar to </dd>
<dd>
<code><a class="el" href="rmw_8h.html#abbd05b65f77e840f7276397fdbf64894" title="Return a loaned message previously borrow from a publisher.">rmw_return_loaned_message_from_publisher</a></code> the passed in ros message might not be valid after this call and thus should only be called with messages previously loaned with a call to </dd>
<dd>
<code><a class="el" href="rmw_8h.html#ae0768752013e0a1ee2776a303d3fc074" title="Borrow a loaned message.">rmw_borrow_loaned_message</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">publisher</td><td>Publisher to be used to send message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ros_message</td><td>Message to be sent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocation</td><td>Specify preallocated memory to use (may be NULL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if publisher or ros_message is null, or </dd>
<dd>
<code>RMW_RET_UNSUPPORTED</code> if the rmw_implementation does not support loaned_message, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a046ba6f8ff184ebb01ab269b31a49f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a046ba6f8ff184ebb01ab269b31a49f33">&#9670;&nbsp;</a></span>rmw_publisher_count_matched_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_publisher_count_matched_subscriptions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__publisher__t.html">rmw_publisher_t</a> *&#160;</td>
          <td class="paramname"><em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>subscription_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the number of matched subscriptions to a publisher. </p>
<p>Query the underlying middleware to determine how many subscriptions are matched to a given publisher.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">publisher</td><td>the publisher object to inspect </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">subscription_count</td><td>the number of subscriptions matched </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if either argument is null, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a809010ecc3e404d8880382e2d4b35976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a809010ecc3e404d8880382e2d4b35976">&#9670;&nbsp;</a></span>rmw_publisher_get_actual_qos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_publisher_get_actual_qos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__publisher__t.html">rmw_publisher_t</a> *&#160;</td>
          <td class="paramname"><em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__qos__profile__t.html">rmw_qos_profile_t</a> *&#160;</td>
          <td class="paramname"><em>qos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the actual qos settings of the publisher. </p>
<p>Query the underlying middleware to determine the qos settings of the publisher. The actual configuration applied when using RMW_*_SYSTEM_DEFAULT can only be resolved after the creation of the publisher, and it depends on the underlying rmw implementation. If the underlying setting in use can't be represented in ROS terms, it will be set to RMW_*_UNKNOWN. The value of avoid_ros_namespace_conventions field is not resolved with this function. The rcl function rcl_publisher_get_actual_qos resolves it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">publisher</td><td>the publisher object to inspect </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">qos</td><td>the actual qos settings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if either argument is null, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="abca69c33387b6185146c3f115ec2a24a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abca69c33387b6185146c3f115ec2a24a">&#9670;&nbsp;</a></span>rmw_publish_serialized_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_publish_serialized_message </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__publisher__t.html">rmw_publisher_t</a> *&#160;</td>
          <td class="paramname"><em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="serialized__message_8h.html#ac1f977c2322bf36dc67f58235ee157ed">rmw_serialized_message_t</a> *&#160;</td>
          <td class="paramname"><em>serialized_message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__publisher__allocation__t.html">rmw_publisher_allocation_t</a> *&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Publish an already serialized message. </p>
<p>The publisher must already be registered with the correct message type support so that it can send serialized data corresponding to that type. This function sends the serialized byte stream directly over the wire without having to serialize the message first. A ROS message can be serialized manually using the <a class="el" href="rmw_8h.html#a787c040bb59b0470ba51eee7e2bc04cd" title="Serialize a ROS message into a rmw_serialized_message_t.">rmw_serialize()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">publisher</td><td>The publisher object registered to send the message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">serialized_message</td><td>The serialized message holding the byte stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocation</td><td>Specify preallocated memory to use (may be NULL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a0c172e30e87562f7f7ad25bae8b0ec8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c172e30e87562f7f7ad25bae8b0ec8b">&#9670;&nbsp;</a></span>rmw_get_serialized_message_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_get_serialized_message_size </td>
          <td>(</td>
          <td class="paramtype">const rosidl_message_type_support_t *&#160;</td>
          <td class="paramname"><em>type_support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rosidl_runtime_c__Sequence__bound *&#160;</td>
          <td class="paramname"><em>message_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the size of a serialized message. </p>
<p>Given a message definition and bounds, compute the serialized size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_support</td><td>The type support of the message to compute. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bounds</td><td>Artifical bounds to use on unbounded fields. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size</td><td>The computed size of the serialized message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if either argument is null, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a1e4025992c2194103d3fe417d2373e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4025992c2194103d3fe417d2373e95">&#9670;&nbsp;</a></span>rmw_publisher_assert_liveliness()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_publisher_assert_liveliness </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__publisher__t.html">rmw_publisher_t</a> *&#160;</td>
          <td class="paramname"><em>publisher</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Manually assert that this Publisher is alive (for RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC) </p>
<p>If the rmw Liveliness policy is set to RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC, the creator of this publisher may manually call <code>assert_liveliness</code> at some point in time to signal to the rest of the system that this Node is still alive.</p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute </th><th class="markdownTableHeadNone">Adherence  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory </td><td class="markdownTableBodyNone">No  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe </td><td class="markdownTableBodyNone">Yes  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics </td><td class="markdownTableBodyNone">No  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free </td><td class="markdownTableBodyNone">Yes  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">publisher</td><td>handle to the publisher that needs liveliness to be asserted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if the liveliness assertion was completed successfully, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unspecified error occurs, or </dd>
<dd>
<code>RMW_RET_UNSUPPORTED</code> if the rmw implementation does not support asserting liveliness. </dd></dl>

</div>
</div>
<a id="a787c040bb59b0470ba51eee7e2bc04cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a787c040bb59b0470ba51eee7e2bc04cd">&#9670;&nbsp;</a></span>rmw_serialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_serialize </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ros_message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rosidl_message_type_support_t *&#160;</td>
          <td class="paramname"><em>type_support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="serialized__message_8h.html#ac1f977c2322bf36dc67f58235ee157ed">rmw_serialized_message_t</a> *&#160;</td>
          <td class="paramname"><em>serialized_message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize a ROS message into a rmw_serialized_message_t. </p>
<p>The ROS message is serialized into a byte stream contained within the rmw_serialized_message_t structure. The serialization format depends on the underlying middleware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ros_message</td><td>the typed ROS message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_support</td><td>the typesupport for the ROS message </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">serialized_message</td><td>the destination for the serialize ROS message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_BAD_ALLOC</code> if memory allocation failed, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a9dee9c2eed962055a68febe9622f807c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dee9c2eed962055a68febe9622f807c">&#9670;&nbsp;</a></span>rmw_deserialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_deserialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="serialized__message_8h.html#ac1f977c2322bf36dc67f58235ee157ed">rmw_serialized_message_t</a> *&#160;</td>
          <td class="paramname"><em>serialized_message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rosidl_message_type_support_t *&#160;</td>
          <td class="paramname"><em>type_support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ros_message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserialize a ROS message. </p>
<p>The given rmw_serialized_message_t's internal byte stream buffer is deserialized into the given ROS message. The ROS message must already be allocated and initialized, and must match the given typesupport structure. The serialization format expected in the rmw_serialized_message_t depends on the underlying middleware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">serialized_message</td><td>the serialized message holding the byte stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_support</td><td>the typesupport for the typed ros message </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ros_message</td><td>destination for the deserialized ROS message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_BAD_ALLOC</code> if memory allocation failed, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a68cb3b9b96efa6d370257d83598d4bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68cb3b9b96efa6d370257d83598d4bed">&#9670;&nbsp;</a></span>rmw_init_subscription_allocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_init_subscription_allocation </td>
          <td>(</td>
          <td class="paramtype">const rosidl_message_type_support_t *&#160;</td>
          <td class="paramname"><em>type_support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rosidl_runtime_c__Sequence__bound *&#160;</td>
          <td class="paramname"><em>message_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__subscription__allocation__t.html">rmw_subscription_allocation_t</a> *&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a subscription allocation to be used with later <code>take</code>s. </p>
<p>This creates an allocation object that can be used in conjunction with the rmw_take method to perform more carefully control memory allocations.</p>
<p>This will allow the middleware to preallocate the correct amount of memory for a given message type and message bounds. As allocation is performed in this method, it will not be necessary to allocate in the <code>rmw_take</code> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_support</td><td>Type support of the message to be preallocated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message_bounds</td><td>Bounds structure of the message to be preallocated. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">allocation</td><td>Allocation structure to be passed to <code>rmw_take</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if an argument is null, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a26e2408746a0e03bdaa290ef32780253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e2408746a0e03bdaa290ef32780253">&#9670;&nbsp;</a></span>rmw_fini_subscription_allocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_fini_subscription_allocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrmw__subscription__allocation__t.html">rmw_subscription_allocation_t</a> *&#160;</td>
          <td class="paramname"><em>allocation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a publisher allocation object. </p>
<p>This deallocates memory allocated by <code>rmw_init_subscription_allocation</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allocation</td><td>Allocation object to be destroyed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if argument is null, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a3a864d424c6aa5fc57b1ca3dbe19a697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a864d424c6aa5fc57b1ca3dbe19a697">&#9670;&nbsp;</a></span>rmw_create_subscription()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrmw__subscription__t.html">rmw_subscription_t</a>* rmw_create_subscription </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__node__t.html">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rosidl_message_type_support_t *&#160;</td>
          <td class="paramname"><em>type_support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrmw__qos__profile__t.html">rmw_qos_profile_t</a> *&#160;</td>
          <td class="paramname"><em>qos_policies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrmw__subscription__options__t.html">rmw_subscription_options_t</a> *&#160;</td>
          <td class="paramname"><em>subscription_options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and return an rmw subscription. </p>
<p>\TODO(wjwwood): add detailed documentation, adding a not about one of the arguments for now.</p>
<p>The argument <code>subscription_options</code> must not be nullptr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subscription_options</td><td>options for configuring the subscription </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a606270f7d253dba6eb9c279061bd2b6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a606270f7d253dba6eb9c279061bd2b6c">&#9670;&nbsp;</a></span>rmw_destroy_subscription()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_destroy_subscription </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrmw__node__t.html">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__subscription__t.html">rmw_subscription_t</a> *&#160;</td>
          <td class="paramname"><em>subscription</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f83284d1a1a2de0cbbc270fab7e2254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f83284d1a1a2de0cbbc270fab7e2254">&#9670;&nbsp;</a></span>rmw_subscription_count_matched_publishers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_subscription_count_matched_publishers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__subscription__t.html">rmw_subscription_t</a> *&#160;</td>
          <td class="paramname"><em>subscription</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>publisher_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the number of matched publishers to a subscription. </p>
<p>Query the underlying middleware to determine how many publishers are matched to a given subscription.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subscription</td><td>the subscription object to inspect </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">publisher_count</td><td>the number of publishers matched </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if either argument is null, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a1b2db56457082adaf379577e4f963bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b2db56457082adaf379577e4f963bce">&#9670;&nbsp;</a></span>rmw_subscription_get_actual_qos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_subscription_get_actual_qos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__subscription__t.html">rmw_subscription_t</a> *&#160;</td>
          <td class="paramname"><em>subscription</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__qos__profile__t.html">rmw_qos_profile_t</a> *&#160;</td>
          <td class="paramname"><em>qos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the actual qos settings of the subscription. </p>
<p>Query the underlying middleware to determine the qos settings of the subscription. The actual configuration applied when using RMW_*_SYSTEM_DEFAULT can only be resolved after the creation of the subscription, and it depends on the underlying rmw implementation. If the underlying setting in use can't be represented in ROS terms, it will be set to RMW_*_UNKNOWN. The value of avoid_ros_namespace_conventions field is not resolved with this function. The rcl function rcl_subscription_get_actual_qos resolves it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subscription</td><td>the subscription object to inspect </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">qos</td><td>the actual qos settings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if either argument is null, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="af9bf29af7069593e2f8dfa2296710080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9bf29af7069593e2f8dfa2296710080">&#9670;&nbsp;</a></span>rmw_take()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_take </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__subscription__t.html">rmw_subscription_t</a> *&#160;</td>
          <td class="paramname"><em>subscription</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ros_message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>taken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__subscription__allocation__t.html">rmw_subscription_allocation_t</a> *&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take an incoming message from a subscription. </p>
<p>Take an incoming ROS message from a given subscription.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subscription</td><td>The subscription object to take from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ros_message</td><td>The ROS message data on success. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">taken</td><td>Boolean flag indicating if a message was taken or not. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocation</td><td>Preallocated buffer to use (may be NULL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a8498c763a02e0fe9203ab6c9dfba0408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8498c763a02e0fe9203ab6c9dfba0408">&#9670;&nbsp;</a></span>rmw_take_with_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_take_with_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__subscription__t.html">rmw_subscription_t</a> *&#160;</td>
          <td class="paramname"><em>subscription</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ros_message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>taken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__message__info__t.html">rmw_message_info_t</a> *&#160;</td>
          <td class="paramname"><em>message_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__subscription__allocation__t.html">rmw_subscription_allocation_t</a> *&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take an incoming message from a subscription with additional metadata. </p>
<p>Take an incoming ROS message from a given subscription.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subscription</td><td>The subscription object to take from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ros_message</td><td>The ROS message data on success. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">taken</td><td>Boolean flag indicating if a message was taken or not. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">message_info</td><td>Additional message metadata. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocation</td><td>Preallocated buffer to use (may be NULL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="aec493534247a1c57a1a0579b0f4120ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec493534247a1c57a1a0579b0f4120ef">&#9670;&nbsp;</a></span>rmw_take_sequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_take_sequence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__subscription__t.html">rmw_subscription_t</a> *&#160;</td>
          <td class="paramname"><em>subscription</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__message__sequence__t.html">rmw_message_sequence_t</a> *&#160;</td>
          <td class="paramname"><em>message_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__message__info__sequence__t.html">rmw_message_info_sequence_t</a> *&#160;</td>
          <td class="paramname"><em>message_info_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>taken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__subscription__allocation__t.html">rmw_subscription_allocation_t</a> *&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take multiple incoming messages from a subscription with additional metadata. </p>
<p>Take a sequence of ROS messgages from a given subscription.</p>
<p>While <code>count</code> messages may be requested, fewer messages may be available on the subscription. In this case, only the currently available messages will be returned. The <code>taken</code> flag indicates the number of messages actually taken. The method will return <code>RMW_RET_OK</code> even in the case that fewer (or zero) messages were retrieved. from the subscription, and will <code>RMW_RET_ERROR</code> in the case of unexpected errors. In the case that <code>count</code> is zero, the function will return <code>RMW_RET_INVALID_ARGUMENT</code>.</p>
<p><code>message_sequence</code> and <code>message_info_sequence</code> should be initialized and have sufficient capacity. It is not critical that the sequence sizes match, and they may be reused from previous calls. Both must be valid (not NULL) for the method to run successfully.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subscription</td><td>The subscription object to take from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of messages to attempt to take. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">message_sequence</td><td>The sequence of ROS message data on success. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">message_info_sequence</td><td>The sequence of additional message metadata on success. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">taken</td><td>Number of messages actually taken from subscription. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocation</td><td>Preallocated buffer to use (may be NULL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if an argument is invalid, or </dd>
<dd>
<code>RMW_RET_BAD_ALLOC</code> if memory allocation failed, or </dd>
<dd>
<code>RMW_RET_INCORRECT_RMW_IMPLEMENTATION</code> if the rmw implementation does not match, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a8ef04c20dab1bc6cdb27343046ccab28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ef04c20dab1bc6cdb27343046ccab28">&#9670;&nbsp;</a></span>rmw_take_serialized_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_take_serialized_message </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__subscription__t.html">rmw_subscription_t</a> *&#160;</td>
          <td class="paramname"><em>subscription</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="serialized__message_8h.html#ac1f977c2322bf36dc67f58235ee157ed">rmw_serialized_message_t</a> *&#160;</td>
          <td class="paramname"><em>serialized_message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>taken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__subscription__allocation__t.html">rmw_subscription_allocation_t</a> *&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a message without deserializing it. </p>
<p>The message is taken in its serialized form. In contrast to rmw_take, the message is not deserialized in its ROS type but rather returned as a byte stream. The subscriber has to be registered for a specific type. But instead of receiving the message as its corresponding message type, it is taken as a byte stream. If needed, this byte stream can then be deserialized in a ROS message with a call to rmw_deserialize.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subscription</td><td>Subscription object to take from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">serialized_message</td><td>The destination in which to store the serialized message. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">taken</td><td>Boolean flag indicating if a message was taken or not. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocation</td><td>Preallocated buffer to use (may be NULL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_BAD_ALLOC</code> if memory allocation failed, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a16a8f380a5f4a5b37a48396a74a3238c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16a8f380a5f4a5b37a48396a74a3238c">&#9670;&nbsp;</a></span>rmw_take_serialized_message_with_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_take_serialized_message_with_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__subscription__t.html">rmw_subscription_t</a> *&#160;</td>
          <td class="paramname"><em>subscription</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="serialized__message_8h.html#ac1f977c2322bf36dc67f58235ee157ed">rmw_serialized_message_t</a> *&#160;</td>
          <td class="paramname"><em>serialized_message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>taken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__message__info__t.html">rmw_message_info_t</a> *&#160;</td>
          <td class="paramname"><em>message_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__subscription__allocation__t.html">rmw_subscription_allocation_t</a> *&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a message without deserializing it and with its additional message information. </p>
<p>The same as <a class="el" href="rmw_8h.html#a8ef04c20dab1bc6cdb27343046ccab28" title="Take a message without deserializing it.">rmw_take_serialized_message()</a>, except it also includes the <a class="el" href="structrmw__message__info__t.html" title="Information describing an rmw message.">rmw_message_info_t</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subscription</td><td>Subscription object to take from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">serialized_message</td><td>The destination in which to store the serialized message. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">taken</td><td>Boolean flag indicating if a message was taken or not. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">message_info</td><td>A structure containing meta information about the taken message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocation</td><td>Preallocated buffer to use (may be NULL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_BAD_ALLOC</code> if memory allocation failed, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a95da7643ef0f44a457361151bf6cbc3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95da7643ef0f44a457361151bf6cbc3c">&#9670;&nbsp;</a></span>rmw_take_loaned_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_take_loaned_message </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__subscription__t.html">rmw_subscription_t</a> *&#160;</td>
          <td class="paramname"><em>subscription</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>loaned_message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>taken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__subscription__allocation__t.html">rmw_subscription_allocation_t</a> *&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a loaned message. </p>
<p>If capable, the middleware can loan messages containing incoming messages. The message is owned by the middleware and thus has to be returned with a call to </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="rmw_8h.html#ae1c931744261eaa9d362e145193cf7d8" title="Return a loaned message previously taken from a subscription.">rmw_return_loaned_message_from_subscription</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subscription</td><td>Subscription object to take from. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">loaned_message</td><td>The destination in which to store the loaned message. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">taken</td><td>Boolean flag indicating if a message was taken or not. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocation</td><td>Preallocated buffer to use (may be NULL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_BAD_ALLOC</code> if memory allocation failed, or </dd>
<dd>
<code>RMW_RET_UNSUPPORTED</code> if the rmw_implementation does not support loaned_message, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a163d11727369827302b7f021cea837d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a163d11727369827302b7f021cea837d4">&#9670;&nbsp;</a></span>rmw_take_loaned_message_with_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_take_loaned_message_with_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__subscription__t.html">rmw_subscription_t</a> *&#160;</td>
          <td class="paramname"><em>subscription</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>loaned_message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>taken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__message__info__t.html">rmw_message_info_t</a> *&#160;</td>
          <td class="paramname"><em>message_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__subscription__allocation__t.html">rmw_subscription_allocation_t</a> *&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a loaned message and with its additional message information. </p>
<p>If capable, the middleware can loan messages containing incoming messages. The message is owned by the middleware and thus has to be returned with a call to </p><dl class="section see"><dt>See also</dt><dd>rmw_release_loaned_message.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subscription</td><td>Subscription object to take from. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">loaned_message</td><td>The destination in which to store the loaned message. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">taken</td><td>Boolean flag indicating if a message was taken or not. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">message_info</td><td>A structure containing meta information about the taken message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocation</td><td>Preallocated buffer to use (may be NULL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_BAD_ALLOC</code> if memory allocation failed, or </dd>
<dd>
<code>RMW_RET_UNSUPPORTED</code> if the rmw_implementation does not support loaned_message, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="ae1c931744261eaa9d362e145193cf7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1c931744261eaa9d362e145193cf7d8">&#9670;&nbsp;</a></span>rmw_return_loaned_message_from_subscription()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_return_loaned_message_from_subscription </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__subscription__t.html">rmw_subscription_t</a> *&#160;</td>
          <td class="paramname"><em>subscription</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>loaned_message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a loaned message previously taken from a subscription. </p>
<p>After the taking a loaned message from the middleware, the middleware has to keep the memory for the loaned message alive and valid as long as the user is working with that loan. In order to indicate that the loaned message is no longer needed, the call to </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="rmw_8h.html#ae1c931744261eaa9d362e145193cf7d8" title="Return a loaned message previously taken from a subscription.">rmw_return_loaned_message_from_subscription</a> tells the middleware that memory can be deallocated/destroyed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subscription</td><td>The subscription instance which loaned the message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">loaned_message</td><td>The message to be released. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a208bb1dd4d3c77cceee53ceba7abb8ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a208bb1dd4d3c77cceee53ceba7abb8ac">&#9670;&nbsp;</a></span>rmw_create_client()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrmw__client__t.html">rmw_client_t</a>* rmw_create_client </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__node__t.html">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rosidl_service_type_support_t *&#160;</td>
          <td class="paramname"><em>type_support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>service_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrmw__qos__profile__t.html">rmw_qos_profile_t</a> *&#160;</td>
          <td class="paramname"><em>qos_policies</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an rmw client to communicate with the specified service. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Handle to node with which to register this client </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_support</td><td>The type_support of this rosidl service </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">service_name</td><td>The name of the ROS 2 service to connect with </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qos_policies</td><td>The QoS profile policies to utilize for this connection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The initialized client if successful, <code>nullptr</code> if not </dd></dl>

</div>
</div>
<a id="a3da675215fe98e4bcb8cf202c3503c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3da675215fe98e4bcb8cf202c3503c5e">&#9670;&nbsp;</a></span>rmw_destroy_client()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_destroy_client </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrmw__node__t.html">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__client__t.html">rmw_client_t</a> *&#160;</td>
          <td class="paramname"><em>client</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy and unregister a service client. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>The associated node whose client will be destroyed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">client</td><td>The service client to destroy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RMW_RET_OK if successful, otherwise an appropriate error code </dd></dl>

</div>
</div>
<a id="a9abc3e631cd2529f168d04be97f1db29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9abc3e631cd2529f168d04be97f1db29">&#9670;&nbsp;</a></span>rmw_send_request()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_send_request </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__client__t.html">rmw_client_t</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ros_request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>sequence_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a service request to the rmw server. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">client</td><td>The connected client over which to send this request </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ros_request</td><td>the request message to send to the server </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sequence_id</td><td>A unique identification value to identify this request </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RMW_RET_OK if successful, otherwise an appropriate error code </dd></dl>

</div>
</div>
<a id="a31be4bb944b42b553a700a762d789dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31be4bb944b42b553a700a762d789dee">&#9670;&nbsp;</a></span>rmw_take_response()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_take_response </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__client__t.html">rmw_client_t</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__service__info__t.html">rmw_service_info_t</a> *&#160;</td>
          <td class="paramname"><em>request_header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ros_response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>taken</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to get the response from a service request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">client</td><td>The connected client to check on this request </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">request_header</td><td>Header response information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ros_response</td><td>The response of this service request, </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">taken</td><td>True if the response was taken, false otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RMW_RET_OK if successful, otherwise an appropriate error code </dd></dl>

</div>
</div>
<a id="a41cac43fcb2ffd40268e472e94159ee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41cac43fcb2ffd40268e472e94159ee5">&#9670;&nbsp;</a></span>rmw_create_service()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrmw__service__t.html">rmw_service_t</a>* rmw_create_service </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__node__t.html">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rosidl_service_type_support_t *&#160;</td>
          <td class="paramname"><em>type_support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>service_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrmw__qos__profile__t.html">rmw_qos_profile_t</a> *&#160;</td>
          <td class="paramname"><em>qos_policies</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an rmw service server that responds to requests. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>The node that responds the service requests </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_support</td><td>The type support description of this service </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">service_name</td><td>The name of this service advertised across the ROS graph </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qos_policies</td><td>The QoS profile policies to utilize for connections </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created service object if successful, otherwise a nullptr </dd></dl>

</div>
</div>
<a id="a39dc6f857dfa69a69bb198dc7fa96fed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39dc6f857dfa69a69bb198dc7fa96fed">&#9670;&nbsp;</a></span>rmw_destroy_service()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_destroy_service </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrmw__node__t.html">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__service__t.html">rmw_service_t</a> *&#160;</td>
          <td class="paramname"><em>service</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy and unregister the service from this node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>The node that owns the service that is being destroyed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">service</td><td>Pointer to the service type created in <code>rmw_create_service</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RMW_RET_OK if successful, otherwise an appropriate error code </dd></dl>

</div>
</div>
<a id="af5fdf79993ad434417b5edabe2023813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5fdf79993ad434417b5edabe2023813">&#9670;&nbsp;</a></span>rmw_take_request()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_take_request </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__service__t.html">rmw_service_t</a> *&#160;</td>
          <td class="paramname"><em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__service__info__t.html">rmw_service_info_t</a> *&#160;</td>
          <td class="paramname"><em>request_header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ros_request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>taken</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to take a request from this service's request buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">service</td><td>service object that responds to these requests </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">request_header</td><td>Request information header with writer guid and sequence number </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ros_request</td><td>The deserialized ros_request, and is unmodified if there are no requests </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">taken</td><td>true if the request was taken, otherwise false </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RMW_RET_OK if successful, otherwise an appropriate error code </dd></dl>

</div>
</div>
<a id="abb55ba2b2a957cefb0a77b77ddc5afda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb55ba2b2a957cefb0a77b77ddc5afda">&#9670;&nbsp;</a></span>rmw_send_response()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_send_response </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__service__t.html">rmw_service_t</a> *&#160;</td>
          <td class="paramname"><em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__request__id__t.html">rmw_request_id_t</a> *&#160;</td>
          <td class="paramname"><em>request_header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ros_response</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send response to a client's request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">service</td><td>The service that responding to this request </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">request_header</td><td>The request header obtained when this request was taken </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ros_response</td><td>The response message to send to the client </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RMW_RET_OK if successful, otherwise an appropriate error code </dd></dl>

</div>
</div>
<a id="a6994bb0042f3a057aa2657149b9f79b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6994bb0042f3a057aa2657149b9f79b4">&#9670;&nbsp;</a></span>rmw_create_guard_condition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrmw__guard__condition__t.html">rmw_guard_condition_t</a>* rmw_create_guard_condition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrmw__context__t.html">rmw_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a guard condition and return a handle to that guard condition. </p>
<p>This function can fail, and therefore return <code>NULL</code>, if:</p><ul>
<li>context is <code>NULL</code></li>
<li>context is invalid</li>
<li>memory allocation fails during guard condition creation</li>
<li>an unspecified error occurs</li>
</ul>
<p>The context must be non-null and valid, i.e. it has been initialized by <code><a class="el" href="init_8h.html#af74e9a1b897e41dc8f4c94a74bb9b1a5" title="Initialize the middleware with the given options, and yielding an context.">rmw_init()</a></code> and has not been finalized by <code><a class="el" href="init_8h.html#a36ece6fcb6294f21a0b69cb091e3ee5a" title="Shutdown the middleware for a given context.">rmw_shutdown()</a></code>.</p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute </th><th class="markdownTableHeadNone">Adherence  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allocates Memory </td><td class="markdownTableBodyNone">Yes  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-Safe </td><td class="markdownTableBodyNone">No  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uses Atomics </td><td class="markdownTableBodyNone">No [1]  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lock-Free </td><td class="markdownTableBodyNone">No [1]  </td></tr>
</table>
<p><em>[1] rmw implementation defined, check the implementation documentation</em></p>
<p>This should be defined by the rmw implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>init context that this node should be associated with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rmw guard condition handle or <code>NULL</code> if there was an error </dd></dl>

</div>
</div>
<a id="acdbd5e36cc0c98e9ab4b018d3a13dfe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdbd5e36cc0c98e9ab4b018d3a13dfe2">&#9670;&nbsp;</a></span>rmw_destroy_guard_condition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_destroy_guard_condition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrmw__guard__condition__t.html">rmw_guard_condition_t</a> *&#160;</td>
          <td class="paramname"><em>guard_condition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a given guard condition handle, reclaim the resources, and deallocate the handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">guard_condition</td><td>the guard condition handle to be destroyed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if guard_condition is null, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a2c06507746a703e9a053c87c4a711fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c06507746a703e9a053c87c4a711fdc">&#9670;&nbsp;</a></span>rmw_trigger_guard_condition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_trigger_guard_condition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__guard__condition__t.html">rmw_guard_condition_t</a> *&#160;</td>
          <td class="paramname"><em>guard_condition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac29d471adffff01c7738ec165f571aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac29d471adffff01c7738ec165f571aca">&#9670;&nbsp;</a></span>rmw_create_wait_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrmw__wait__set__t.html">rmw_wait_set_t</a>* rmw_create_wait_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrmw__context__t.html">rmw_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_conditions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a wait set to store conditions that the middleware will block on. </p>
<p>This function can fail, and therefore return <code>NULL</code>, if:</p><ul>
<li>context is <code>NULL</code></li>
<li>context is invalid</li>
<li>memory allocation fails during wait set creation</li>
<li>an unspecified error occurs</li>
</ul>
<p>If <code>max_conditions</code> is <code>0</code>, the wait set can store an unbounded number of conditions to wait on. If <code>max_conditions</code> is greater than <code>0</code>, the number of conditions that can be attached to the wait set is bounded at <code>max_conditions</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>init context that this node should be associated with </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_conditions</td><td>The maximum number of conditions that can be attached to the wait set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the created wait set, <code>NULL</code> if an error occurred. </dd></dl>

</div>
</div>
<a id="a42465b1d9fddb3556a1a9f5d44d60b6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42465b1d9fddb3556a1a9f5d44d60b6c">&#9670;&nbsp;</a></span>rmw_destroy_wait_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_destroy_wait_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrmw__wait__set__t.html">rmw_wait_set_t</a> *&#160;</td>
          <td class="paramname"><em>wait_set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy and free memory of this wait_set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wait_set</td><td>The wait_set object to destroy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RMW_RET_OK if successful, otherwise an appropriate error code </dd></dl>

</div>
</div>
<a id="a5f480dd59075e80288fb596b2951be2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f480dd59075e80288fb596b2951be2b">&#9670;&nbsp;</a></span>rmw_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrmw__subscriptions__t.html">rmw_subscriptions_t</a> *&#160;</td>
          <td class="paramname"><em>subscriptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__guard__conditions__t.html">rmw_guard_conditions_t</a> *&#160;</td>
          <td class="paramname"><em>guard_conditions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__services__t.html">rmw_services_t</a> *&#160;</td>
          <td class="paramname"><em>services</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__clients__t.html">rmw_clients_t</a> *&#160;</td>
          <td class="paramname"><em>clients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__events__t.html">rmw_events_t</a> *&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__wait__set__t.html">rmw_wait_set_t</a> *&#160;</td>
          <td class="paramname"><em>wait_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrmw__time__t.html">rmw_time_t</a> *&#160;</td>
          <td class="paramname"><em>wait_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits on sets of different waitable entities and returns when one is ready. </p>
<p>Add conditions to the wait set and wait until a response comes in, or until the timeout is reached. The arrays contain type-erased representations of waitable entities. This function casts the pointers to middleware-specific conditions and adds them to the wait set.</p>
<p>The count variables in the arrays represents the number of valid pointers in the array. <code>NULL</code> pointers are in the array considered invalid. If they are encountered, an error is returned.</p>
<p>The array structs are allocated and deallocated outside of this function. They do not have any information about how much memory is allocated for the arrays.</p>
<p>After the wait wakes up, the entries in each array that correspond to conditions that were not triggered are set to <code>NULL</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subscriptions</td><td>Array of subscriptions to wait on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">guard_conditions</td><td>Array of guard conditions to wait on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">services</td><td>Array of services to wait on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clients</td><td>Array of clients to wait on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wait_set</td><td>Storage for the wait set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wait_timeout</td><td>If NULL, block until a condition is ready. If zero, check only for immediately available conditions and don't block. Else, this represents the maximum time to wait for a response from the wait set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if success, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if error, or </dd>
<dd>
<code>RMW_RET_TIMEOUT</code> if wait timed out. </dd></dl>

</div>
</div>
<a id="a64a897976680c178e0be5ef4d4a17f9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64a897976680c178e0be5ef4d4a17f9f">&#9670;&nbsp;</a></span>rmw_get_node_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_get_node_names </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__node__t.html">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://docs.ros2.org/foxy/api/rcutils/structrcutils__string__array__t.html">rcutils_string_array_t</a> *&#160;</td>
          <td class="paramname"><em>node_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://docs.ros2.org/foxy/api/rcutils/structrcutils__string__array__t.html">rcutils_string_array_t</a> *&#160;</td>
          <td class="paramname"><em>node_namespaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a list of node name and namespaces discovered via a node. </p>
<p>This function will return a list of node names and a list of node namespaces that are discovered via the middleware. The two lists represent pairs of namespace and name for each discovered node. The lists will be the same length and the same position will refer to the same node across lists.</p>
<p>The node parameter must not be <code>NULL</code>, and must point to a valid node.</p>
<p>The node_names parameter must not be <code>NULL</code>, and must point to a valid string array.</p>
<p>The node_namespaces parameter must not be <code>NULL</code>, and must point to a valid string array.</p>
<p>This function does manipulate heap memory. This function is not thread-safe. This function is lock-free.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>the handle to the node being used to query the ROS graph </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">node_names</td><td>a list of discovered node names </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">node_namespaces</td><td>a list of discovered node namespaces </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if node the query was made successfully, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a id="aa9388d5cc9d2cb460e48f4212735c935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9388d5cc9d2cb460e48f4212735c935">&#9670;&nbsp;</a></span>rmw_get_node_names_with_enclaves()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_get_node_names_with_enclaves </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__node__t.html">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://docs.ros2.org/foxy/api/rcutils/structrcutils__string__array__t.html">rcutils_string_array_t</a> *&#160;</td>
          <td class="paramname"><em>node_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://docs.ros2.org/foxy/api/rcutils/structrcutils__string__array__t.html">rcutils_string_array_t</a> *&#160;</td>
          <td class="paramname"><em>node_namespaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://docs.ros2.org/foxy/api/rcutils/structrcutils__string__array__t.html">rcutils_string_array_t</a> *&#160;</td>
          <td class="paramname"><em>enclaves</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a list of node name and namespaces discovered via a node with its enclave. </p>
<p>Similar to <a class="el" href="rmw_8h.html#a64a897976680c178e0be5ef4d4a17f9f">rmw_get_node_names</a>, but it also provides the enclave name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>the handle to the node being used to query the ROS graph </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">node_names</td><td>a list of discovered node names </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">node_namespaces</td><td>a list of discovered node namespaces </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">enclaves</td><td>list of discovered nodes' enclave names </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if node the query was made successfully, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a id="a83c761fb53a29f44b41fc299ffbb9cb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83c761fb53a29f44b41fc299ffbb9cb4">&#9670;&nbsp;</a></span>rmw_count_publishers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_count_publishers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__node__t.html">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the number of publishers matching a topic name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>rmw node connected to the ROS graph </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">topic_name</td><td>The name of the topic to match under possible prefixes </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">count</td><td>The number of publishers matching the topic name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RMW_RET_OK if successful, otherwise an appropriate error code </dd></dl>

</div>
</div>
<a id="a3d48df829636837092ef47f91514675e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d48df829636837092ef47f91514675e">&#9670;&nbsp;</a></span>rmw_count_subscribers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_count_subscribers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__node__t.html">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the number of subscribers matching a topic name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>rmw node connected to the ROS graph </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">topic_name</td><td>The name of the topic to match under possible prefixes </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">count</td><td>The number of subscribers matching the topic name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RMW_RET_OK if successful, otherwise an appropriate error code </dd></dl>

</div>
</div>
<a id="a846898b23af992f7f3eaa17eaf741e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a846898b23af992f7f3eaa17eaf741e9f">&#9670;&nbsp;</a></span>rmw_get_gid_for_publisher()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_get_gid_for_publisher </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__publisher__t.html">rmw_publisher_t</a> *&#160;</td>
          <td class="paramname"><em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__gid__t.html">rmw_gid_t</a> *&#160;</td>
          <td class="paramname"><em>gid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the unique identifier of the publisher. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">publisher</td><td>The publisher to get the gid of </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">gid</td><td>The resulting gid </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RMW_RET_OK if successful, otherwise an appropriate error code </dd></dl>

</div>
</div>
<a id="a280fd9c0cf4fc49fbe6786b64b835194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a280fd9c0cf4fc49fbe6786b64b835194">&#9670;&nbsp;</a></span>rmw_compare_gids_equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_compare_gids_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__gid__t.html">rmw_gid_t</a> *&#160;</td>
          <td class="paramname"><em>gid1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrmw__gid__t.html">rmw_gid_t</a> *&#160;</td>
          <td class="paramname"><em>gid2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if two gid objects are the same. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gid1</td><td>One gid1 to compare </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gid2</td><td>The other gid to compare </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bool</td><td>true if the gid objects match, false otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RMW_RET_OK if successful, otherwise an appropriate error code </dd></dl>

</div>
</div>
<a id="af0cec9687e5e4738aba7e061014eb3d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0cec9687e5e4738aba7e061014eb3d5">&#9670;&nbsp;</a></span>rmw_service_server_is_available()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_service_server_is_available </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__node__t.html">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrmw__client__t.html">rmw_client_t</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_available</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a service server is available for the given service client. </p>
<p>This function will return true for <code>is_available</code> if there is a service server available for the given client.</p>
<p>The node parameter must not be <code>NULL</code>, and must point to a valid node.</p>
<p>The client parameter must not be <code>NULL</code>, and must point to a valid client.</p>
<p>The given client and node must match, i.e. the client must have been created using the given node.</p>
<p>The is_available parameter must not be <code>NULL</code>, and must point to a bool variable. The result of the check will be stored in the is_available parameter.</p>
<p>This function does manipulate heap memory. This function is not thread-safe. This function is lock-free.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>the handle to the node being used to query the ROS graph </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">client</td><td>the handle to the service client being queried </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_available</td><td>set to true if there is a service server available, else false </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if node the check was made successfully, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a id="a95cc3dd8de47abb8a105d0b8a30419c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95cc3dd8de47abb8a105d0b8a30419c9">&#9670;&nbsp;</a></span>rmw_set_log_severity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_set_log_severity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#a0e0bd7d4ee1297d1a365f12fde05bceb">rmw_log_severity_t</a>&#160;</td>
          <td class="paramname"><em>severity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the current log severity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">severity</td><td>The log severity to set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RMW_RET_OK if successful, otherwise an appropriate error code </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
