<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rcl: include/rcl/node.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rcl
   &#160;<span id="projectnumber">master</span>
   </div>
   <div id="projectbrief">C API providing common ROS client library functionality.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_283a3917c54ce6b1b3757c2d5b61678e.html">rcl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">node.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &quot;<a class="el" href="allocator_8h_source.html">rcl/allocator.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="macros_8h_source.html">rcl/macros.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="types_8h_source.html">rcl/types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="visibility__control_8h_source.html">rcl/visibility_control.h</a>&quot;</code><br />
</div>
<p><a href="node_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrcl__node__t.html">rcl_node_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure which encapsulates a ROS Node.  <a href="structrcl__node__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrcl__node__options__t.html">rcl_node_options_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure which encapsulates the options for creating a <a class="el" href="structrcl__node__t.html" title="Structure which encapsulates a ROS Node. ">rcl_node_t</a>.  <a href="structrcl__node__options__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a6558b9534e72809f14f8604f1680f8c7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8h.html#a6558b9534e72809f14f8604f1680f8c7">RCL_NODE_OPTIONS_DEFAULT_DOMAIN_ID</a>&#160;&#160;&#160;SIZE_MAX</td></tr>
<tr class="memdesc:a6558b9534e72809f14f8604f1680f8c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant which indicates that the default domain id should be used.  <a href="#a6558b9534e72809f14f8604f1680f8c7">More...</a><br /></td></tr>
<tr class="separator:a6558b9534e72809f14f8604f1680f8c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a2a3ab0cd94b43b061b0ead5762a313d9"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structrcl__node__t.html">rcl_node_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8h.html#a2a3ab0cd94b43b061b0ead5762a313d9">rcl_node_t</a></td></tr>
<tr class="memdesc:a2a3ab0cd94b43b061b0ead5762a313d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure which encapsulates a ROS Node.  <a href="#a2a3ab0cd94b43b061b0ead5762a313d9">More...</a><br /></td></tr>
<tr class="separator:a2a3ab0cd94b43b061b0ead5762a313d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbb2da7b3f0b3bb9bf42f78ad1c875a"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structrcl__node__options__t.html">rcl_node_options_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8h.html#adcbb2da7b3f0b3bb9bf42f78ad1c875a">rcl_node_options_t</a></td></tr>
<tr class="memdesc:adcbb2da7b3f0b3bb9bf42f78ad1c875a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure which encapsulates the options for creating a <a class="el" href="structrcl__node__t.html" title="Structure which encapsulates a ROS Node. ">rcl_node_t</a>.  <a href="#adcbb2da7b3f0b3bb9bf42f78ad1c875a">More...</a><br /></td></tr>
<tr class="separator:adcbb2da7b3f0b3bb9bf42f78ad1c875a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a81df2a24fd74f87d520fba94297eb583"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrcl__node__t.html">rcl_node_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8h.html#a81df2a24fd74f87d520fba94297eb583">rcl_get_zero_initialized_node</a> (void)</td></tr>
<tr class="memdesc:a81df2a24fd74f87d520fba94297eb583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="structrcl__node__t.html" title="Structure which encapsulates a ROS Node. ">rcl_node_t</a> struct with members initialized to <code>NULL</code>.  <a href="#a81df2a24fd74f87d520fba94297eb583">More...</a><br /></td></tr>
<tr class="separator:a81df2a24fd74f87d520fba94297eb583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf1d973c1bffeced9659892e14926a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8h.html#abbf1d973c1bffeced9659892e14926a2">rcl_node_init</a> (<a class="el" href="structrcl__node__t.html">rcl_node_t</a> *node, const char *name, const char *namespace_, const <a class="el" href="structrcl__node__options__t.html">rcl_node_options_t</a> *options)</td></tr>
<tr class="memdesc:abbf1d973c1bffeced9659892e14926a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a ROS node.  <a href="#abbf1d973c1bffeced9659892e14926a2">More...</a><br /></td></tr>
<tr class="separator:abbf1d973c1bffeced9659892e14926a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d2a1a7959d7b2db49a3653235d414c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8h.html#a00d2a1a7959d7b2db49a3653235d414c">rcl_node_fini</a> (<a class="el" href="structrcl__node__t.html">rcl_node_t</a> *node)</td></tr>
<tr class="memdesc:a00d2a1a7959d7b2db49a3653235d414c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalized a <a class="el" href="structrcl__node__t.html" title="Structure which encapsulates a ROS Node. ">rcl_node_t</a>.  <a href="#a00d2a1a7959d7b2db49a3653235d414c">More...</a><br /></td></tr>
<tr class="separator:a00d2a1a7959d7b2db49a3653235d414c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6391b8a89bd72f8e69113a471c005c3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrcl__node__options__t.html">rcl_node_options_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8h.html#a6391b8a89bd72f8e69113a471c005c3c">rcl_node_get_default_options</a> (void)</td></tr>
<tr class="memdesc:a6391b8a89bd72f8e69113a471c005c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the default node options in a <a class="el" href="structrcl__node__options__t.html" title="Structure which encapsulates the options for creating a rcl_node_t. ">rcl_node_options_t</a>.  <a href="#a6391b8a89bd72f8e69113a471c005c3c">More...</a><br /></td></tr>
<tr class="separator:a6391b8a89bd72f8e69113a471c005c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ca79d13d9386492f01cbd1b8f1e462"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8h.html#a45ca79d13d9386492f01cbd1b8f1e462">rcl_node_is_valid</a> (const <a class="el" href="structrcl__node__t.html">rcl_node_t</a> *node)</td></tr>
<tr class="memdesc:a45ca79d13d9386492f01cbd1b8f1e462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the node is valid, else <code>false</code>.  <a href="#a45ca79d13d9386492f01cbd1b8f1e462">More...</a><br /></td></tr>
<tr class="separator:a45ca79d13d9386492f01cbd1b8f1e462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a905967814f810ea932571e8fc7a2b361"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8h.html#a905967814f810ea932571e8fc7a2b361">rcl_node_get_name</a> (const <a class="el" href="structrcl__node__t.html">rcl_node_t</a> *node)</td></tr>
<tr class="memdesc:a905967814f810ea932571e8fc7a2b361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name of the node.  <a href="#a905967814f810ea932571e8fc7a2b361">More...</a><br /></td></tr>
<tr class="separator:a905967814f810ea932571e8fc7a2b361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e59f116c9c3e5e0ba66164e07a0257c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8h.html#a3e59f116c9c3e5e0ba66164e07a0257c">rcl_node_get_namespace</a> (const <a class="el" href="structrcl__node__t.html">rcl_node_t</a> *node)</td></tr>
<tr class="memdesc:a3e59f116c9c3e5e0ba66164e07a0257c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the namespace of the node.  <a href="#a3e59f116c9c3e5e0ba66164e07a0257c">More...</a><br /></td></tr>
<tr class="separator:a3e59f116c9c3e5e0ba66164e07a0257c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2003915c35630138561fa1685e6d5b4d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structrcl__node__options__t.html">rcl_node_options_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8h.html#a2003915c35630138561fa1685e6d5b4d">rcl_node_get_options</a> (const <a class="el" href="structrcl__node__t.html">rcl_node_t</a> *node)</td></tr>
<tr class="memdesc:a2003915c35630138561fa1685e6d5b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the rcl node options.  <a href="#a2003915c35630138561fa1685e6d5b4d">More...</a><br /></td></tr>
<tr class="separator:a2003915c35630138561fa1685e6d5b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d42413e6bc60595465f84fbe29a3dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8h.html#a82d42413e6bc60595465f84fbe29a3dc">rcl_node_get_domain_id</a> (const <a class="el" href="structrcl__node__t.html">rcl_node_t</a> *node, size_t *domain_id)</td></tr>
<tr class="memdesc:a82d42413e6bc60595465f84fbe29a3dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ROS domain ID that the node is using.  <a href="#a82d42413e6bc60595465f84fbe29a3dc">More...</a><br /></td></tr>
<tr class="separator:a82d42413e6bc60595465f84fbe29a3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0178170356c99b3991b09dde56c290"><td class="memItemLeft" align="right" valign="top"><a class="elRef" doxygen="/home/dhood/ros2_beta3/doxygen_tag_files/rmw.tag:http://docs.ros2.org/latest/api/rmw/" href="http://docs.ros2.org/latest/api/rmw/structrmw__node__t.html">rmw_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8h.html#aeb0178170356c99b3991b09dde56c290">rcl_node_get_rmw_handle</a> (const <a class="el" href="structrcl__node__t.html">rcl_node_t</a> *node)</td></tr>
<tr class="memdesc:aeb0178170356c99b3991b09dde56c290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the rmw node handle.  <a href="#aeb0178170356c99b3991b09dde56c290">More...</a><br /></td></tr>
<tr class="separator:aeb0178170356c99b3991b09dde56c290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f37990c0cbf01bb2eb381a71d679f32"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8h.html#a1f37990c0cbf01bb2eb381a71d679f32">rcl_node_get_rcl_instance_id</a> (const <a class="el" href="structrcl__node__t.html">rcl_node_t</a> *node)</td></tr>
<tr class="memdesc:a1f37990c0cbf01bb2eb381a71d679f32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the associated rcl instance id.  <a href="#a1f37990c0cbf01bb2eb381a71d679f32">More...</a><br /></td></tr>
<tr class="separator:a1f37990c0cbf01bb2eb381a71d679f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e19802da544266e87a3fdad345c86f"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structrcl__guard__condition__t.html">rcl_guard_condition_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8h.html#ac0e19802da544266e87a3fdad345c86f">rcl_node_get_graph_guard_condition</a> (const <a class="el" href="structrcl__node__t.html">rcl_node_t</a> *node)</td></tr>
<tr class="memdesc:ac0e19802da544266e87a3fdad345c86f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a guard condition which is triggered when the ROS graph changes.  <a href="#ac0e19802da544266e87a3fdad345c86f">More...</a><br /></td></tr>
<tr class="separator:ac0e19802da544266e87a3fdad345c86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a6558b9534e72809f14f8604f1680f8c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6558b9534e72809f14f8604f1680f8c7">&#9670;&nbsp;</a></span>RCL_NODE_OPTIONS_DEFAULT_DOMAIN_ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RCL_NODE_OPTIONS_DEFAULT_DOMAIN_ID&#160;&#160;&#160;SIZE_MAX</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constant which indicates that the default domain id should be used. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a2a3ab0cd94b43b061b0ead5762a313d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a3ab0cd94b43b061b0ead5762a313d9">&#9670;&nbsp;</a></span>rcl_node_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structrcl__node__t.html">rcl_node_t</a>  <a class="el" href="structrcl__node__t.html">rcl_node_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Structure which encapsulates a ROS Node. </p>

</div>
</div>
<a id="adcbb2da7b3f0b3bb9bf42f78ad1c875a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcbb2da7b3f0b3bb9bf42f78ad1c875a">&#9670;&nbsp;</a></span>rcl_node_options_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structrcl__node__options__t.html">rcl_node_options_t</a>  <a class="el" href="structrcl__node__options__t.html">rcl_node_options_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Structure which encapsulates the options for creating a <a class="el" href="structrcl__node__t.html" title="Structure which encapsulates a ROS Node. ">rcl_node_t</a>. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a81df2a24fd74f87d520fba94297eb583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81df2a24fd74f87d520fba94297eb583">&#9670;&nbsp;</a></span>rcl_get_zero_initialized_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrcl__node__t.html">rcl_node_t</a> rcl_get_zero_initialized_node </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <a class="el" href="structrcl__node__t.html" title="Structure which encapsulates a ROS Node. ">rcl_node_t</a> struct with members initialized to <code>NULL</code>. </p>

</div>
</div>
<a id="abbf1d973c1bffeced9659892e14926a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf1d973c1bffeced9659892e14926a2">&#9670;&nbsp;</a></span>rcl_node_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> rcl_node_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__node__t.html">rcl_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>namespace_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrcl__node__options__t.html">rcl_node_options_t</a> *&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a ROS node. </p>
<p>Calling this on a <a class="el" href="structrcl__node__t.html" title="Structure which encapsulates a ROS Node. ">rcl_node_t</a> makes it a valid node handle until rcl_shutdown is called or until rcl_node_fini is called on it.</p>
<p>After calling, the ROS node object can be used to create other middleware primitives like publishers, services, parameters, etc.</p>
<p>The name of the node must not be NULL and adhere to naming restrictions, see the <a class="elRef" doxygen="/home/dhood/ros2_beta3/doxygen_tag_files/rmw.tag:http://docs.ros2.org/latest/api/rmw/" href="http://docs.ros2.org/latest/api/rmw/validate__node__name_8h.html#a5690a285aed9735f89ef11950b6e39e3">rmw_validate_node_name()</a> function for rules.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>TODO(wjwwood): node name uniqueness is no yet enforced</dd></dl>
<p>The name of the node cannot coincide with another node of the same name. If a node of the same name is already in the domain, it will be shutdown.</p>
<p>The namespace of the node should not be NULL and should also pass the <a class="elRef" doxygen="/home/dhood/ros2_beta3/doxygen_tag_files/rmw.tag:http://docs.ros2.org/latest/api/rmw/" href="http://docs.ros2.org/latest/api/rmw/validate__namespace_8h.html#a043f17d240cf13df01321b19a469ee49">rmw_validate_namespace()</a> function's rules.</p>
<p>Additionally this function allows namespaces which lack a leading forward slash. Because there is no notion of a relative namespace, there is no difference between a namespace which lacks a forward and the same namespace with a leasing forward slash. Therefore, a namespace like <code>"foo/bar"</code> is automatically changed to <code>"/foo/bar"</code> by this function. Similarly, the namespace <code>""</code> will implicitly become <code>"/"</code> which is a valid namespace.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>TODO(wjwwood): Parameter infrastructure is currently initialized in the language specific client library, e.g. rclcpp for C++, but will be initialized here in the future. When that happens there will be an option to avoid parameter infrastructure with an option in the <a class="el" href="structrcl__node__options__t.html" title="Structure which encapsulates the options for creating a rcl_node_t. ">rcl_node_options_t</a> struct.</dd></dl>
<p>A node contains infrastructure for ROS parameters, which include advertising publishers and service servers. This function will create those external parameter interfaces even if parameters are not used later.</p>
<p>The <a class="el" href="structrcl__node__t.html" title="Structure which encapsulates a ROS Node. ">rcl_node_t</a> given must be allocated and zero initialized. Passing an <a class="el" href="structrcl__node__t.html" title="Structure which encapsulates a ROS Node. ">rcl_node_t</a> which has already had this function called on it, more recently than rcl_node_fini, will fail. An allocated <a class="el" href="structrcl__node__t.html" title="Structure which encapsulates a ROS Node. ">rcl_node_t</a> with uninitialized memory is undefined behavior.</p>
<p>Expected usage:</p>
<div class="fragment"><div class="line"><a class="code" href="structrcl__node__t.html">rcl_node_t</a> node = <a class="code" href="node_8h.html#a81df2a24fd74f87d520fba94297eb583">rcl_get_zero_initialized_node</a>();</div><div class="line"><a class="code" href="structrcl__node__options__t.html">rcl_node_options_t</a> node_ops = <a class="code" href="node_8h.html#a6391b8a89bd72f8e69113a471c005c3c">rcl_node_get_default_options</a>();</div><div class="line"><span class="comment">// ... node options customization</span></div><div class="line"><a class="code" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> ret = <a class="code" href="node_8h.html#abbf1d973c1bffeced9659892e14926a2">rcl_node_init</a>(&amp;node, <span class="stringliteral">&quot;node_name&quot;</span>, <span class="stringliteral">&quot;/node_ns&quot;</span>, &amp;node_ops);</div><div class="line"><span class="comment">// ... error handling and then use the node, but eventually deinitialize it:</span></div><div class="line">ret = <a class="code" href="node_8h.html#a00d2a1a7959d7b2db49a3653235d414c">rcl_node_fini</a>(&amp;node);</div><div class="line"><span class="comment">// ... error handling for rcl_node_fini()</span></div></div><!-- fragment --><hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>Yes </td></tr>
<tr>
<td>Thread-Safe </td><td>No </td></tr>
<tr>
<td>Uses Atomics </td><td>Yes </td></tr>
<tr>
<td>Lock-Free </td><td>Yes [1] </td></tr>
</table>
<p><em>[1] if <code>atomic_is_lock_free()</code> returns true for <code>atomic_uint_least64_t</code></em></p>
<dl class="section pre"><dt>Precondition</dt><dd>the node handle must be allocated, zero initialized, and invalid </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>the node handle is valid and can be used in other <code>rcl_*</code> functions</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">node</td><td>a preallocated <a class="el" href="structrcl__node__t.html" title="Structure which encapsulates a ROS Node. ">rcl_node_t</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>the name of the node, must be a valid c-string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">namespace_</td><td>the namespace of the node, must be a valid c-string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>the node options </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RCL_RET_OK</code> if the node was initialized successfully, or </dd>
<dd>
<code>RCL_RET_ALREADY_INIT</code> if the node has already be initialized, or </dd>
<dd>
<code>RCL_RET_INVALID_ARGUMENT</code> if any arguments are invalid, or </dd>
<dd>
<code>RCL_RET_BAD_ALLOC</code> if allocating memory failed, or </dd>
<dd>
<code>RCL_RET_NODE_INVALID_NAME</code> if the name is invalid, or </dd>
<dd>
<code>RCL_RET_NODE_INVALID_NAMESPACE</code> if the namespace_ is invalid, or </dd>
<dd>
<code>RCL_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a id="a00d2a1a7959d7b2db49a3653235d414c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d2a1a7959d7b2db49a3653235d414c">&#9670;&nbsp;</a></span>rcl_node_fini()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> rcl_node_fini </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__node__t.html">rcl_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalized a <a class="el" href="structrcl__node__t.html" title="Structure which encapsulates a ROS Node. ">rcl_node_t</a>. </p>
<p>Destroys any automatically created infrastructure and deallocates memory. After calling, the <a class="el" href="structrcl__node__t.html" title="Structure which encapsulates a ROS Node. ">rcl_node_t</a> can be safely deallocated.</p>
<p>Any middleware primitives created by the user, e.g. publishers, services, etc., are invalid after deinitialization.</p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>Yes </td></tr>
<tr>
<td>Thread-Safe </td><td>No </td></tr>
<tr>
<td>Uses Atomics </td><td>Yes </td></tr>
<tr>
<td>Lock-Free </td><td>Yes [1] </td></tr>
</table>
<p><em>[1] if <code>atomic_is_lock_free()</code> returns true for <code>atomic_uint_least64_t</code></em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td><a class="el" href="structrcl__node__t.html" title="Structure which encapsulates a ROS Node. ">rcl_node_t</a> to be finalized </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RCL_RET_OK</code> if node was finalized successfully, or </dd>
<dd>
<code>RCL_RET_INVALID_ARGUMENT</code> if any arguments are invalid, or </dd>
<dd>
<code>RCL_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a id="a6391b8a89bd72f8e69113a471c005c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6391b8a89bd72f8e69113a471c005c3c">&#9670;&nbsp;</a></span>rcl_node_get_default_options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrcl__node__options__t.html">rcl_node_options_t</a> rcl_node_get_default_options </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the default node options in a <a class="el" href="structrcl__node__options__t.html" title="Structure which encapsulates the options for creating a rcl_node_t. ">rcl_node_options_t</a>. </p>
<p>The default values are:</p>
<ul>
<li>domain_id = RCL_NODE_OPTIONS_DEFAULT_DOMAIN_ID</li>
<li>allocator = <a class="el" href="allocator_8h.html#a2546f065f55387ed642d455a55ba7602">rcl_get_default_allocator()</a> </li>
</ul>

</div>
</div>
<a id="a45ca79d13d9386492f01cbd1b8f1e462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45ca79d13d9386492f01cbd1b8f1e462">&#9670;&nbsp;</a></span>rcl_node_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rcl_node_is_valid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrcl__node__t.html">rcl_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>true</code> if the node is valid, else <code>false</code>. </p>
<p>Also return <code>false</code> if the node pointer is <code>NULL</code>.</p>
<p>A node is invalid if:</p><ul>
<li>the implementation is <code>NULL</code> (rcl_node_init not called or failed)</li>
<li>rcl_shutdown has been called since the node has been initialized</li>
<li>the node has been finalized with rcl_node_fini</li>
</ul>
<p>There is a possible validity race condition.</p>
<p>Consider:</p>
<div class="fragment"><div class="line">assert(<a class="code" href="node_8h.html#a45ca79d13d9386492f01cbd1b8f1e462">rcl_node_is_valid</a>(node));  <span class="comment">// &lt;-- thread 1</span></div><div class="line"><a class="code" href="rcl_8h.html#a974908de798dda844c7205ca2af11e7f">rcl_shutdown</a>();                   <span class="comment">// &lt;-- thread 2</span></div><div class="line"><span class="comment">// use node as if valid           // &lt;-- thread 1</span></div></div><!-- fragment --><p>In the third line the node is now invalid, even though on the previous line of thread 1 it was checked to be valid. This is why this function is considered not thread-safe.</p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>No </td></tr>
<tr>
<td>Thread-Safe </td><td>No </td></tr>
<tr>
<td>Uses Atomics </td><td>Yes </td></tr>
<tr>
<td>Lock-Free </td><td>Yes [1] </td></tr>
</table>
<p><em>[1] if <code>atomic_is_lock_free()</code> returns true for <code>atomic_uint_least64_t</code></em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td><a class="el" href="structrcl__node__t.html" title="Structure which encapsulates a ROS Node. ">rcl_node_t</a> to be validated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the node is valid, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a905967814f810ea932571e8fc7a2b361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a905967814f810ea932571e8fc7a2b361">&#9670;&nbsp;</a></span>rcl_node_get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rcl_node_get_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrcl__node__t.html">rcl_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the name of the node. </p>
<p>This function returns the node's internal name string. This function can fail, and therefore return <code>NULL</code>, if:</p><ul>
<li>node is <code>NULL</code></li>
<li>node has not been initialized (the implementation is invalid)</li>
</ul>
<p>The returned string is only valid as long as the given <a class="el" href="structrcl__node__t.html" title="Structure which encapsulates a ROS Node. ">rcl_node_t</a> is valid. The value of the string may change if the value in the <a class="el" href="structrcl__node__t.html" title="Structure which encapsulates a ROS Node. ">rcl_node_t</a> changes, and therefore copying the string is recommended if this is a concern.</p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>No </td></tr>
<tr>
<td>Thread-Safe </td><td>No </td></tr>
<tr>
<td>Uses Atomics </td><td>No </td></tr>
<tr>
<td>Lock-Free </td><td>Yes </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>pointer to the node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>name string if successful, otherwise <code>NULL</code> </dd></dl>

</div>
</div>
<a id="a3e59f116c9c3e5e0ba66164e07a0257c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e59f116c9c3e5e0ba66164e07a0257c">&#9670;&nbsp;</a></span>rcl_node_get_namespace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rcl_node_get_namespace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrcl__node__t.html">rcl_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the namespace of the node. </p>
<p>This function returns the node's internal namespace string. This function can fail, and therefore return <code>NULL</code>, if:</p><ul>
<li>node is <code>NULL</code></li>
<li>node has not been initialized (the implementation is invalid)</li>
</ul>
<p>The returned string is only valid as long as the given <a class="el" href="structrcl__node__t.html" title="Structure which encapsulates a ROS Node. ">rcl_node_t</a> is valid. The value of the string may change if the value in the <a class="el" href="structrcl__node__t.html" title="Structure which encapsulates a ROS Node. ">rcl_node_t</a> changes, and therefore copying the string is recommended if this is a concern.</p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>No </td></tr>
<tr>
<td>Thread-Safe </td><td>No </td></tr>
<tr>
<td>Uses Atomics </td><td>No </td></tr>
<tr>
<td>Lock-Free </td><td>Yes </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>pointer to the node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>name string if successful, otherwise <code>NULL</code> </dd></dl>

</div>
</div>
<a id="a2003915c35630138561fa1685e6d5b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2003915c35630138561fa1685e6d5b4d">&#9670;&nbsp;</a></span>rcl_node_get_options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structrcl__node__options__t.html">rcl_node_options_t</a>* rcl_node_get_options </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrcl__node__t.html">rcl_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the rcl node options. </p>
<p>This function returns the node's internal options struct. This function can fail, and therefore return <code>NULL</code>, if:</p><ul>
<li>node is <code>NULL</code></li>
<li>node has not been initialized (the implementation is invalid)</li>
</ul>
<p>The returned struct is only valid as long as the given <a class="el" href="structrcl__node__t.html" title="Structure which encapsulates a ROS Node. ">rcl_node_t</a> is valid. The values in the struct may change if the options of the <a class="el" href="structrcl__node__t.html" title="Structure which encapsulates a ROS Node. ">rcl_node_t</a> changes, and therefore copying the struct is recommended if this is a concern.</p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>No </td></tr>
<tr>
<td>Thread-Safe </td><td>No </td></tr>
<tr>
<td>Uses Atomics </td><td>No </td></tr>
<tr>
<td>Lock-Free </td><td>Yes </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>pointer to the node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>options struct if successful, otherwise <code>NULL</code> </dd></dl>

</div>
</div>
<a id="a82d42413e6bc60595465f84fbe29a3dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82d42413e6bc60595465f84fbe29a3dc">&#9670;&nbsp;</a></span>rcl_node_get_domain_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> rcl_node_get_domain_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrcl__node__t.html">rcl_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>domain_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the ROS domain ID that the node is using. </p>
<p>This function returns the ROS domain ID that the node is in.</p>
<p>This function should be used to determine what <code>domain_id</code> was used rather than checking the domin_id field in the node options, because if <code>RCL_NODE_OPTIONS_DEFAULT_DOMAIN_ID</code> is used when creating the node then it is not changed after creation, but this function will return the actual <code>domain_id</code> used.</p>
<p>The <code>domain_id</code> field must point to an allocated <code>size_t</code> object to which the ROS domain ID will be written.</p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>No </td></tr>
<tr>
<td>Thread-Safe </td><td>No </td></tr>
<tr>
<td>Uses Atomics </td><td>No </td></tr>
<tr>
<td>Lock-Free </td><td>Yes </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>the handle to the node being queried </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">domain_id</td><td>storage for the domain id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RCL_RET_OK</code> if node the domain ID was retrieved successfully, or </dd>
<dd>
<code>RCL_RET_NODE_INVALID</code> if the node is invalid, or </dd>
<dd>
<code>RCL_RET_INVALID_ARGUMENT</code> if any arguments are invalid, or </dd>
<dd>
<code>RCL_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a id="aeb0178170356c99b3991b09dde56c290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb0178170356c99b3991b09dde56c290">&#9670;&nbsp;</a></span>rcl_node_get_rmw_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/home/dhood/ros2_beta3/doxygen_tag_files/rmw.tag:http://docs.ros2.org/latest/api/rmw/" href="http://docs.ros2.org/latest/api/rmw/structrmw__node__t.html">rmw_node_t</a>* rcl_node_get_rmw_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrcl__node__t.html">rcl_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the rmw node handle. </p>
<p>The handle returned is a pointer to the internally held rmw handle. This function can fail, and therefore return <code>NULL</code>, if:</p><ul>
<li>node is <code>NULL</code></li>
<li>node has not been initialized (the implementation is invalid)</li>
</ul>
<p>The returned handle is made invalid if the node is finalized or if <a class="el" href="rcl_8h.html#a974908de798dda844c7205ca2af11e7f" title="Signal global shutdown of rcl. ">rcl_shutdown()</a> is called. The returned handle is not guaranteed to be valid for the life time of the node as it may be finalized and recreated itself. Therefore it is recommended to get the handle from the node using this function each time it is needed and avoid use of the handle concurrently with functions that might change it.</p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>No </td></tr>
<tr>
<td>Thread-Safe </td><td>No </td></tr>
<tr>
<td>Uses Atomics </td><td>No </td></tr>
<tr>
<td>Lock-Free </td><td>Yes </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>pointer to the rcl node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rmw node handle if successful, otherwise <code>NULL</code> </dd></dl>

</div>
</div>
<a id="a1f37990c0cbf01bb2eb381a71d679f32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f37990c0cbf01bb2eb381a71d679f32">&#9670;&nbsp;</a></span>rcl_node_get_rcl_instance_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t rcl_node_get_rcl_instance_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrcl__node__t.html">rcl_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the associated rcl instance id. </p>
<p>This id is stored when rcl_node_init is called and can be compared with the value returned by <a class="el" href="rcl_8h.html#ad19410cc82f7a57362134626facd4d00" title="Returns an uint64_t number that is unique for the latest rcl_init call. ">rcl_get_instance_id()</a> to check if this node was created in the current rcl context (since the latest call to <a class="el" href="rcl_8h.html#a6abc5188c50b3a4a5fc41b357b49d6e5" title="Global initialization of rcl. ">rcl_init()</a>.</p>
<p>This function can fail, and therefore return <code>0</code>, if:</p><ul>
<li>node is <code>NULL</code></li>
<li>node has not been initialized (the implementation is invalid)</li>
</ul>
<p>This function will succeed even if <a class="el" href="rcl_8h.html#a974908de798dda844c7205ca2af11e7f" title="Signal global shutdown of rcl. ">rcl_shutdown()</a> has been called since the node was created.</p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>No </td></tr>
<tr>
<td>Thread-Safe </td><td>No </td></tr>
<tr>
<td>Uses Atomics </td><td>No </td></tr>
<tr>
<td>Lock-Free </td><td>Yes </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>pointer to the rcl node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rcl instance id captured during node init or <code>0</code> on error </dd></dl>

</div>
</div>
<a id="ac0e19802da544266e87a3fdad345c86f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e19802da544266e87a3fdad345c86f">&#9670;&nbsp;</a></span>rcl_node_get_graph_guard_condition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structrcl__guard__condition__t.html">rcl_guard_condition_t</a>* rcl_node_get_graph_guard_condition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrcl__node__t.html">rcl_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a guard condition which is triggered when the ROS graph changes. </p>
<p>The handle returned is a pointer to an internally held rcl guard condition. This function can fail, and therefore return <code>NULL</code>, if:</p><ul>
<li>node is <code>NULL</code></li>
<li>node is invalid</li>
</ul>
<p>The returned handle is made invalid if the node is finialized or if <a class="el" href="rcl_8h.html#a974908de798dda844c7205ca2af11e7f" title="Signal global shutdown of rcl. ">rcl_shutdown()</a> is called.</p>
<p>The guard condition will be triggered anytime a change to the ROS graph occurs. A ROS graph change includes things like (but not limited to) a new publisher advertises, a new subscription is created, a new service becomes available, a subscription is canceled, etc.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>TODO(wjwwood): link to exhaustive list of graph events</dd></dl>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>No </td></tr>
<tr>
<td>Thread-Safe </td><td>No </td></tr>
<tr>
<td>Uses Atomics </td><td>No </td></tr>
<tr>
<td>Lock-Free </td><td>Yes </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>pointer to the rcl node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rcl guard condition handle if successful, otherwise <code>NULL</code> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
