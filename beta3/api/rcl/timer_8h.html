<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rcl: include/rcl/timer.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rcl
   &#160;<span id="projectnumber">master</span>
   </div>
   <div id="projectbrief">C API providing common ROS client library functionality.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_283a3917c54ce6b1b3757c2d5b61678e.html">rcl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">timer.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &quot;<a class="el" href="allocator_8h_source.html">rcl/allocator.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="macros_8h_source.html">rcl/macros.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="time_8h_source.html">rcl/time.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="types_8h_source.html">rcl/types.h</a>&quot;</code><br />
<code>#include &quot;<a class="elRef" doxygen="/home/dhood/ros2_beta3/doxygen_tag_files/rmw.tag:http://docs.ros2.org/latest/api/rmw/" href="http://docs.ros2.org/latest/api/rmw/rmw_8h.html">rmw/rmw.h</a>&quot;</code><br />
</div>
<p><a href="timer_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrcl__timer__t.html">rcl_timer_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure which encapsulates a ROS Timer.  <a href="structrcl__timer__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:acb790eb8af6591a23d3cb751252112d2"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structrcl__timer__t.html">rcl_timer_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="timer_8h.html#acb790eb8af6591a23d3cb751252112d2">rcl_timer_t</a></td></tr>
<tr class="memdesc:acb790eb8af6591a23d3cb751252112d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure which encapsulates a ROS Timer.  <a href="#acb790eb8af6591a23d3cb751252112d2">More...</a><br /></td></tr>
<tr class="separator:acb790eb8af6591a23d3cb751252112d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18cf5baf35642f49df647b0899d14568"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="timer_8h.html#a18cf5baf35642f49df647b0899d14568">rcl_timer_callback_t</a>) (<a class="el" href="structrcl__timer__t.html">rcl_timer_t</a> *, uint64_t)</td></tr>
<tr class="memdesc:a18cf5baf35642f49df647b0899d14568"><td class="mdescLeft">&#160;</td><td class="mdescRight">User callback signature for timers.  <a href="#a18cf5baf35642f49df647b0899d14568">More...</a><br /></td></tr>
<tr class="separator:a18cf5baf35642f49df647b0899d14568"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abbd34abec964c5eaeaedad6bd259d64f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrcl__timer__t.html">rcl_timer_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="timer_8h.html#abbd34abec964c5eaeaedad6bd259d64f">rcl_get_zero_initialized_timer</a> (void)</td></tr>
<tr class="memdesc:abbd34abec964c5eaeaedad6bd259d64f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a zero initialized timer.  <a href="#abbd34abec964c5eaeaedad6bd259d64f">More...</a><br /></td></tr>
<tr class="separator:abbd34abec964c5eaeaedad6bd259d64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad978ffc534394607f2cc198022d732f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="timer_8h.html#ad978ffc534394607f2cc198022d732f7">rcl_timer_init</a> (<a class="el" href="structrcl__timer__t.html">rcl_timer_t</a> *timer, uint64_t period, const <a class="el" href="timer_8h.html#a18cf5baf35642f49df647b0899d14568">rcl_timer_callback_t</a> callback, <a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a> allocator)</td></tr>
<tr class="memdesc:ad978ffc534394607f2cc198022d732f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a timer.  <a href="#ad978ffc534394607f2cc198022d732f7">More...</a><br /></td></tr>
<tr class="separator:ad978ffc534394607f2cc198022d732f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1244817fc476604487b572392cd9b487"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="timer_8h.html#a1244817fc476604487b572392cd9b487">rcl_timer_fini</a> (<a class="el" href="structrcl__timer__t.html">rcl_timer_t</a> *timer)</td></tr>
<tr class="memdesc:a1244817fc476604487b572392cd9b487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a timer.  <a href="#a1244817fc476604487b572392cd9b487">More...</a><br /></td></tr>
<tr class="separator:a1244817fc476604487b572392cd9b487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3604512300b10c1a262ddc87007d22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="timer_8h.html#aaf3604512300b10c1a262ddc87007d22">rcl_timer_call</a> (<a class="el" href="structrcl__timer__t.html">rcl_timer_t</a> *timer)</td></tr>
<tr class="memdesc:aaf3604512300b10c1a262ddc87007d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the timer's callback and set the last call time.  <a href="#aaf3604512300b10c1a262ddc87007d22">More...</a><br /></td></tr>
<tr class="separator:aaf3604512300b10c1a262ddc87007d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88d5e72b48c08b5b4acf96dcf1eb598"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="timer_8h.html#ad88d5e72b48c08b5b4acf96dcf1eb598">rcl_timer_is_ready</a> (const <a class="el" href="structrcl__timer__t.html">rcl_timer_t</a> *timer, bool *is_ready)</td></tr>
<tr class="memdesc:ad88d5e72b48c08b5b4acf96dcf1eb598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates whether or not the timer should be called.  <a href="#ad88d5e72b48c08b5b4acf96dcf1eb598">More...</a><br /></td></tr>
<tr class="separator:ad88d5e72b48c08b5b4acf96dcf1eb598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb62d18168856da802727c6eba4bc41e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="timer_8h.html#adb62d18168856da802727c6eba4bc41e">rcl_timer_get_time_until_next_call</a> (const <a class="el" href="structrcl__timer__t.html">rcl_timer_t</a> *timer, int64_t *time_until_next_call)</td></tr>
<tr class="memdesc:adb62d18168856da802727c6eba4bc41e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate and retrieve the time until the next call in nanoseconds.  <a href="#adb62d18168856da802727c6eba4bc41e">More...</a><br /></td></tr>
<tr class="separator:adb62d18168856da802727c6eba4bc41e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee2dc09bd811e1f4fc161b3dcbafc1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="timer_8h.html#aaee2dc09bd811e1f4fc161b3dcbafc1c">rcl_timer_get_time_since_last_call</a> (const <a class="el" href="structrcl__timer__t.html">rcl_timer_t</a> *timer, uint64_t *time_since_last_call)</td></tr>
<tr class="memdesc:aaee2dc09bd811e1f4fc161b3dcbafc1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the time since the previous call to <a class="el" href="timer_8h.html#aaf3604512300b10c1a262ddc87007d22" title="Call the timer&#39;s callback and set the last call time. ">rcl_timer_call()</a> occurred.  <a href="#aaee2dc09bd811e1f4fc161b3dcbafc1c">More...</a><br /></td></tr>
<tr class="separator:aaee2dc09bd811e1f4fc161b3dcbafc1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecea137c0982bf484b642f95911062e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="timer_8h.html#aecea137c0982bf484b642f95911062e9">rcl_timer_get_period</a> (const <a class="el" href="structrcl__timer__t.html">rcl_timer_t</a> *timer, uint64_t *period)</td></tr>
<tr class="memdesc:aecea137c0982bf484b642f95911062e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the period of the timer.  <a href="#aecea137c0982bf484b642f95911062e9">More...</a><br /></td></tr>
<tr class="separator:aecea137c0982bf484b642f95911062e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb737a3f62dc6ad413aee1f054b698f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="timer_8h.html#adeb737a3f62dc6ad413aee1f054b698f">rcl_timer_exchange_period</a> (const <a class="el" href="structrcl__timer__t.html">rcl_timer_t</a> *timer, uint64_t new_period, uint64_t *old_period)</td></tr>
<tr class="memdesc:adeb737a3f62dc6ad413aee1f054b698f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchange the period of the timer and return the previous period.  <a href="#adeb737a3f62dc6ad413aee1f054b698f">More...</a><br /></td></tr>
<tr class="separator:adeb737a3f62dc6ad413aee1f054b698f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50891a7769cec152d5bff366b46117c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="timer_8h.html#a18cf5baf35642f49df647b0899d14568">rcl_timer_callback_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="timer_8h.html#ac50891a7769cec152d5bff366b46117c">rcl_timer_get_callback</a> (const <a class="el" href="structrcl__timer__t.html">rcl_timer_t</a> *timer)</td></tr>
<tr class="memdesc:ac50891a7769cec152d5bff366b46117c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current timer callback.  <a href="#ac50891a7769cec152d5bff366b46117c">More...</a><br /></td></tr>
<tr class="separator:ac50891a7769cec152d5bff366b46117c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba665ea920768fcb03d756d2edddbc73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="timer_8h.html#a18cf5baf35642f49df647b0899d14568">rcl_timer_callback_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="timer_8h.html#aba665ea920768fcb03d756d2edddbc73">rcl_timer_exchange_callback</a> (<a class="el" href="structrcl__timer__t.html">rcl_timer_t</a> *timer, const <a class="el" href="timer_8h.html#a18cf5baf35642f49df647b0899d14568">rcl_timer_callback_t</a> new_callback)</td></tr>
<tr class="memdesc:aba665ea920768fcb03d756d2edddbc73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchange the current timer callback and return the current callback.  <a href="#aba665ea920768fcb03d756d2edddbc73">More...</a><br /></td></tr>
<tr class="separator:aba665ea920768fcb03d756d2edddbc73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128c09cd9077c18194c24f14f77dc83e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="timer_8h.html#a128c09cd9077c18194c24f14f77dc83e">rcl_timer_cancel</a> (<a class="el" href="structrcl__timer__t.html">rcl_timer_t</a> *timer)</td></tr>
<tr class="memdesc:a128c09cd9077c18194c24f14f77dc83e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel a timer.  <a href="#a128c09cd9077c18194c24f14f77dc83e">More...</a><br /></td></tr>
<tr class="separator:a128c09cd9077c18194c24f14f77dc83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae4d03691b385b7d7e3033719539e85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="timer_8h.html#a2ae4d03691b385b7d7e3033719539e85">rcl_timer_is_canceled</a> (const <a class="el" href="structrcl__timer__t.html">rcl_timer_t</a> *timer, bool *is_canceled)</td></tr>
<tr class="memdesc:a2ae4d03691b385b7d7e3033719539e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the canceled state of a timer.  <a href="#a2ae4d03691b385b7d7e3033719539e85">More...</a><br /></td></tr>
<tr class="separator:a2ae4d03691b385b7d7e3033719539e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae798ac5204198c83a20ee5a0cd5e3a17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="timer_8h.html#ae798ac5204198c83a20ee5a0cd5e3a17">rcl_timer_reset</a> (<a class="el" href="structrcl__timer__t.html">rcl_timer_t</a> *timer)</td></tr>
<tr class="memdesc:ae798ac5204198c83a20ee5a0cd5e3a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset a timer.  <a href="#ae798ac5204198c83a20ee5a0cd5e3a17">More...</a><br /></td></tr>
<tr class="separator:ae798ac5204198c83a20ee5a0cd5e3a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab772bd917feb04005eef2515948f8d64"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="timer_8h.html#ab772bd917feb04005eef2515948f8d64">rcl_timer_get_allocator</a> (const <a class="el" href="structrcl__timer__t.html">rcl_timer_t</a> *timer)</td></tr>
<tr class="memdesc:ab772bd917feb04005eef2515948f8d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the allocator for the timer.  <a href="#ab772bd917feb04005eef2515948f8d64">More...</a><br /></td></tr>
<tr class="separator:ab772bd917feb04005eef2515948f8d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="acb790eb8af6591a23d3cb751252112d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb790eb8af6591a23d3cb751252112d2">&#9670;&nbsp;</a></span>rcl_timer_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structrcl__timer__t.html">rcl_timer_t</a>  <a class="el" href="structrcl__timer__t.html">rcl_timer_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Structure which encapsulates a ROS Timer. </p>

</div>
</div>
<a id="a18cf5baf35642f49df647b0899d14568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18cf5baf35642f49df647b0899d14568">&#9670;&nbsp;</a></span>rcl_timer_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(*  rcl_timer_callback_t) (<a class="el" href="structrcl__timer__t.html">rcl_timer_t</a> *, uint64_t)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User callback signature for timers. </p>
<p>The first argument the callback gets is a pointer to the timer. This can be used to cancel the timer, query the time until the next timer callback, exchange the callback with a different one, etc.</p>
<p>The only caveat is that the function <a class="el" href="timer_8h.html#aaee2dc09bd811e1f4fc161b3dcbafc1c" title="Retrieve the time since the previous call to rcl_timer_call() occurred. ">rcl_timer_get_time_since_last_call()</a> will return the time since just before this callback was called, not the previous call. Therefore the second argument given is the time since the previous callback was called, because that information is no longer accessible via the timer. The time since the last callback call is given in nanoseconds. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="abbd34abec964c5eaeaedad6bd259d64f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd34abec964c5eaeaedad6bd259d64f">&#9670;&nbsp;</a></span>rcl_get_zero_initialized_timer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrcl__timer__t.html">rcl_timer_t</a> rcl_get_zero_initialized_timer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a zero initialized timer. </p>

</div>
</div>
<a id="ad978ffc534394607f2cc198022d732f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad978ffc534394607f2cc198022d732f7">&#9670;&nbsp;</a></span>rcl_timer_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> rcl_timer_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__timer__t.html">rcl_timer_t</a> *&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="timer_8h.html#a18cf5baf35642f49df647b0899d14568">rcl_timer_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a>&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a timer. </p>
<p>A timer consists of a callback function and a period. A timer can be added to a wait set and waited on, such that the wait set will wake up when a timer is ready to be executed.</p>
<p>A timer simply holds state and does not automatically call callbacks. It does not create any threads, register interrupts, or consume signals. For blocking behavior it can be used in conjunction with a wait set and <a class="el" href="wait_8h.html#a732278988c802fe2c9d8ec24752f9dd9" title="Block until the wait set is ready or until the timeout has been exceeded. ">rcl_wait()</a>. When <a class="el" href="timer_8h.html#ad88d5e72b48c08b5b4acf96dcf1eb598" title="Calculates whether or not the timer should be called. ">rcl_timer_is_ready()</a> returns true, the timer must still be called explicitly using <a class="el" href="timer_8h.html#aaf3604512300b10c1a262ddc87007d22" title="Call the timer&#39;s callback and set the last call time. ">rcl_timer_call()</a>.</p>
<p>The timer handle must be a pointer to an allocated and zero initialized <a class="el" href="structrcl__timer__t.html" title="Structure which encapsulates a ROS Timer. ">rcl_timer_t</a> struct. Calling this function on an already initialized timer will fail. Calling this function on a timer struct which has been allocated but not zero initialized is undefined behavior.</p>
<p>The period is a duration (rather an absolute time in the future). If the period is <code>0</code> then it will always be ready.</p>
<p>The callback is an optional argument. Valid inputs are either a pointer to the function callback, or <code>NULL</code> to indicate that no callback will be stored in rcl. If the callback is <code>NULL</code>, the caller client library is responsible for firing the timer callback. Else, it must be a function which returns void and takes two arguments, the first being a pointer to the associated timer, and the second a uint64_t which is the time since the previous call, or since the timer was created if it is the first call to the callback.</p>
<p>Expected usage:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="rcl_8h.html">rcl/rcl.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> my_timer_callback(<a class="code" href="structrcl__timer__t.html">rcl_timer_t</a> * timer, uint64_t last_call_time)</div><div class="line">{</div><div class="line">  <span class="comment">// Do timer work...</span></div><div class="line">  <span class="comment">// Optionally reconfigure, cancel, or reset the timer...</span></div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="structrcl__timer__t.html">rcl_timer_t</a> timer = <a class="code" href="timer_8h.html#abbd34abec964c5eaeaedad6bd259d64f">rcl_get_zero_initialized_timer</a>();</div><div class="line"><a class="code" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> ret = <a class="code" href="timer_8h.html#ad978ffc534394607f2cc198022d732f7">rcl_timer_init</a>(</div><div class="line">  &amp;timer, <a class="code" href="time_8h.html#a2b6c1f35e2df71ebccae0921ffae7e6b">RCL_MS_TO_NS</a>(100), my_timer_callback, <a class="code" href="allocator_8h.html#a2546f065f55387ed642d455a55ba7602">rcl_get_default_allocator</a>());</div><div class="line"><span class="comment">// ... error handling, use the timer with a wait set, or poll it manually, then cleanup</span></div><div class="line">ret = <a class="code" href="timer_8h.html#a1244817fc476604487b572392cd9b487">rcl_timer_fini</a>(&amp;timer);</div><div class="line"><span class="comment">// ... error handling</span></div></div><!-- fragment --><hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>Yes </td></tr>
<tr>
<td>Thread-Safe </td><td>No </td></tr>
<tr>
<td>Uses Atomics </td><td>Yes </td></tr>
<tr>
<td>Lock-Free </td><td>Yes [1][2][3] </td></tr>
</table>
<p><em>[1] if <code>atomic_is_lock_free()</code> returns true for <code>atomic_uintptr_t</code></em></p>
<p><em>[2] if <code>atomic_is_lock_free()</code> returns true for <code>atomic_uint_least64_t</code></em></p>
<p><em>[3] if <code>atomic_is_lock_free()</code> returns true for <code>atomic_bool</code></em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">timer</td><td>the timer handle to be initialized </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">period</td><td>the duration between calls to the callback in nanoseconds </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>the user defined function to be called every period </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>the allocator to use for allocations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RCL_RET_OK</code> if the timer was initialized successfully, or </dd>
<dd>
<code>RCL_RET_INVALID_ARGUMENT</code> if any arguments are invalid, or </dd>
<dd>
<code>RCL_RET_ALREADY_INIT</code> if the timer was already initialized, or </dd>
<dd>
<code>RCL_RET_BAD_ALLOC</code> if allocating memory failed, or </dd>
<dd>
<code>RCL_RET_ERROR</code> an unspecified error occur. </dd></dl>

</div>
</div>
<a id="a1244817fc476604487b572392cd9b487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1244817fc476604487b572392cd9b487">&#9670;&nbsp;</a></span>rcl_timer_fini()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> rcl_timer_fini </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__timer__t.html">rcl_timer_t</a> *&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a timer. </p>
<p>This function will deallocate any memory and make the timer invalid.</p>
<p>A timer that is already invalid (zero initialized) or <code>NULL</code> will not fail.</p>
<p>This function is not thread-safe with any rcl_timer_* functions used on the same timer object.</p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>Yes </td></tr>
<tr>
<td>Thread-Safe </td><td>No </td></tr>
<tr>
<td>Uses Atomics </td><td>Yes </td></tr>
<tr>
<td>Lock-Free </td><td>Yes [1][2][3] </td></tr>
</table>
<p><em>[1] if <code>atomic_is_lock_free()</code> returns true for <code>atomic_uintptr_t</code></em></p>
<p><em>[2] if <code>atomic_is_lock_free()</code> returns true for <code>atomic_uint_least64_t</code></em></p>
<p><em>[3] if <code>atomic_is_lock_free()</code> returns true for <code>atomic_bool</code></em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">timer</td><td>the handle to the timer to be finalized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RCL_RET_OK</code> if the timer was finalized successfully, or </dd>
<dd>
<code>RCL_RET_ERROR</code> an unspecified error occur. </dd></dl>

</div>
</div>
<a id="aaf3604512300b10c1a262ddc87007d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf3604512300b10c1a262ddc87007d22">&#9670;&nbsp;</a></span>rcl_timer_call()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> rcl_timer_call </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__timer__t.html">rcl_timer_t</a> *&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call the timer's callback and set the last call time. </p>
<p>This function will call the callback and change the last call time even if the timer's period has not yet elapsed. It is up to the calling code to make sure the period has elapsed by first calling <a class="el" href="timer_8h.html#ad88d5e72b48c08b5b4acf96dcf1eb598" title="Calculates whether or not the timer should be called. ">rcl_timer_is_ready()</a>. If the callback pointer is <code>NULL</code> (either set in init or exchanged after initialized), no callback is fired. However, this function should still be called by the client library to update the state of the timer. The order of operations in this command are as follows:</p>
<ul>
<li>Ensure the timer has not been canceled.</li>
<li>Get the current time into a temporary rcl_steady_time_point_t.</li>
<li>Exchange the current time with the last call time of the timer.</li>
<li>Call the callback, passing this timer and the time since the last call.</li>
<li>Return after the callback has completed.</li>
</ul>
<p>During the callback the timer can be canceled or have its period and/or callback modified.</p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>No </td></tr>
<tr>
<td>Thread-Safe </td><td>Yes [1] </td></tr>
<tr>
<td>Uses Atomics </td><td>Yes </td></tr>
<tr>
<td>Lock-Free </td><td>Yes [2] </td></tr>
</table>
<p><em>[1] user callback might not be thread-safe</em></p>
<p><em>[2] if <code>atomic_is_lock_free()</code> returns true for <code>atomic_int_least64_t</code></em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">timer</td><td>the handle to the timer to call </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RCL_RET_OK</code> if the timer was called successfully, or </dd>
<dd>
<code>RCL_RET_INVALID_ARGUMENT</code> if any arguments are invalid, or </dd>
<dd>
<code>RCL_RET_TIMER_INVALID</code> if the timer is invalid, or </dd>
<dd>
<code>RCL_RET_TIMER_CANCELED</code> if the timer has been canceled, or </dd>
<dd>
<code>RCL_RET_ERROR</code> an unspecified error occur. </dd></dl>

</div>
</div>
<a id="ad88d5e72b48c08b5b4acf96dcf1eb598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad88d5e72b48c08b5b4acf96dcf1eb598">&#9670;&nbsp;</a></span>rcl_timer_is_ready()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> rcl_timer_is_ready </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrcl__timer__t.html">rcl_timer_t</a> *&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_ready</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates whether or not the timer should be called. </p>
<p>The result is true if the time until next call is less than, or equal to, 0 and the timer has not been canceled. Otherwise the result is false, indicating the timer should not be called.</p>
<p>The is_ready argument must point to an allocated bool object, as the result is copied into it.</p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>No </td></tr>
<tr>
<td>Thread-Safe </td><td>Yes </td></tr>
<tr>
<td>Uses Atomics </td><td>Yes </td></tr>
<tr>
<td>Lock-Free </td><td>Yes [1] </td></tr>
</table>
<p><em>[1] if <code>atomic_is_lock_free()</code> returns true for <code>atomic_int_least64_t</code></em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>the handle to the timer which is being checked </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_ready</td><td>the bool used to store the result of the calculation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RCL_RET_OK</code> if the last call time was retrieved successfully, or </dd>
<dd>
<code>RCL_RET_INVALID_ARGUMENT</code> if any arguments are invalid, or </dd>
<dd>
<code>RCL_RET_TIMER_INVALID</code> if the timer is invalid, or </dd>
<dd>
<code>RCL_RET_ERROR</code> an unspecified error occur. </dd></dl>

</div>
</div>
<a id="adb62d18168856da802727c6eba4bc41e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb62d18168856da802727c6eba4bc41e">&#9670;&nbsp;</a></span>rcl_timer_get_time_until_next_call()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> rcl_timer_get_time_until_next_call </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrcl__timer__t.html">rcl_timer_t</a> *&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>time_until_next_call</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate and retrieve the time until the next call in nanoseconds. </p>
<p>This function calculates the time until the next call by adding the timer's period to the last call time and subtracting that sum from the current time. The calculated time until the next call can be positive, indicating that it is not ready to be called as the period has not elapsed since the last call. The calculated time until the next call can also be 0 or negative, indicating that the period has elapsed since the last call and the timer should be called. A negative value indicates the timer call is overdue by that amount.</p>
<p>The <code>time_until_next_call</code> argument must point to an allocated int64_t, as the time until is copied into that instance.</p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>No </td></tr>
<tr>
<td>Thread-Safe </td><td>Yes </td></tr>
<tr>
<td>Uses Atomics </td><td>Yes </td></tr>
<tr>
<td>Lock-Free </td><td>Yes [1] </td></tr>
</table>
<p><em>[1] if <code>atomic_is_lock_free()</code> returns true for <code>atomic_int_least64_t</code></em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>the handle to the timer that is being queried </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">time_until_next_call</td><td>the output variable for the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RCL_RET_OK</code> if the timer until next call was successfully calculated, or </dd>
<dd>
<code>RCL_RET_INVALID_ARGUMENT</code> if any arguments are invalid, or </dd>
<dd>
<code>RCL_RET_TIMER_INVALID</code> if the timer is invalid, or </dd>
<dd>
<code>RCL_RET_ERROR</code> an unspecified error occur. </dd></dl>

</div>
</div>
<a id="aaee2dc09bd811e1f4fc161b3dcbafc1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee2dc09bd811e1f4fc161b3dcbafc1c">&#9670;&nbsp;</a></span>rcl_timer_get_time_since_last_call()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> rcl_timer_get_time_since_last_call </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrcl__timer__t.html">rcl_timer_t</a> *&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>time_since_last_call</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the time since the previous call to <a class="el" href="timer_8h.html#aaf3604512300b10c1a262ddc87007d22" title="Call the timer&#39;s callback and set the last call time. ">rcl_timer_call()</a> occurred. </p>
<p>This function calculates the time since the last call and copies it into the given uint64_t variable.</p>
<p>Calling this function within a callback will not return the time since the previous call but instead the time since the current callback was called.</p>
<p>The time_since_last_call argument must be a pointer to an already allocated uint64_t.</p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>No </td></tr>
<tr>
<td>Thread-Safe </td><td>Yes </td></tr>
<tr>
<td>Uses Atomics </td><td>Yes </td></tr>
<tr>
<td>Lock-Free </td><td>Yes [1] </td></tr>
</table>
<p><em>[1] if <code>atomic_is_lock_free()</code> returns true for <code>atomic_int_least64_t</code></em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>the handle to the timer which is being queried </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">time_since_last_call</td><td>the struct in which the time is stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RCL_RET_OK</code> if the last call time was retrieved successfully, or </dd>
<dd>
<code>RCL_RET_INVALID_ARGUMENT</code> if any arguments are invalid, or </dd>
<dd>
<code>RCL_RET_TIMER_INVALID</code> if the timer is invalid, or </dd>
<dd>
<code>RCL_RET_ERROR</code> an unspecified error occur. </dd></dl>

</div>
</div>
<a id="aecea137c0982bf484b642f95911062e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecea137c0982bf484b642f95911062e9">&#9670;&nbsp;</a></span>rcl_timer_get_period()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> rcl_timer_get_period </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrcl__timer__t.html">rcl_timer_t</a> *&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the period of the timer. </p>
<p>This function retrieves the period and copies it into the give variable.</p>
<p>The period argument must be a pointer to an already allocated uint64_t.</p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>No </td></tr>
<tr>
<td>Thread-Safe </td><td>Yes </td></tr>
<tr>
<td>Uses Atomics </td><td>Yes </td></tr>
<tr>
<td>Lock-Free </td><td>Yes [1] </td></tr>
</table>
<p><em>[1] if <code>atomic_is_lock_free()</code> returns true for <code>atomic_int_least64_t</code></em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>the handle to the timer which is being queried </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">period</td><td>the uint64_t in which the period is stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RCL_RET_OK</code> if the period was retrieved successfully, or </dd>
<dd>
<code>RCL_RET_INVALID_ARGUMENT</code> if any arguments are invalid, or </dd>
<dd>
<code>RCL_RET_TIMER_INVALID</code> if the timer is invalid, or </dd>
<dd>
<code>RCL_RET_ERROR</code> an unspecified error occur. </dd></dl>

</div>
</div>
<a id="adeb737a3f62dc6ad413aee1f054b698f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeb737a3f62dc6ad413aee1f054b698f">&#9670;&nbsp;</a></span>rcl_timer_exchange_period()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> rcl_timer_exchange_period </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrcl__timer__t.html">rcl_timer_t</a> *&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>new_period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>old_period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exchange the period of the timer and return the previous period. </p>
<p>This function exchanges the period in the timer and copies the old one into the give variable.</p>
<p>Exchanging (changing) the period will not affect already waiting wait sets.</p>
<p>The old_period argument must be a pointer to an already allocated uint64_t.</p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>No </td></tr>
<tr>
<td>Thread-Safe </td><td>Yes </td></tr>
<tr>
<td>Uses Atomics </td><td>Yes </td></tr>
<tr>
<td>Lock-Free </td><td>Yes [1] </td></tr>
</table>
<p><em>[1] if <code>atomic_is_lock_free()</code> returns true for <code>atomic_int_least64_t</code></em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>the handle to the timer which is being modified </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">new_period</td><td>the uint64_t to exchange into the timer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">old_period</td><td>the uint64_t in which the previous period is stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RCL_RET_OK</code> if the period was retrieved successfully, or </dd>
<dd>
<code>RCL_RET_INVALID_ARGUMENT</code> if any arguments are invalid, or </dd>
<dd>
<code>RCL_RET_TIMER_INVALID</code> if the timer is invalid, or </dd>
<dd>
<code>RCL_RET_ERROR</code> an unspecified error occur. </dd></dl>

</div>
</div>
<a id="ac50891a7769cec152d5bff366b46117c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac50891a7769cec152d5bff366b46117c">&#9670;&nbsp;</a></span>rcl_timer_get_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer_8h.html#a18cf5baf35642f49df647b0899d14568">rcl_timer_callback_t</a> rcl_timer_get_callback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrcl__timer__t.html">rcl_timer_t</a> *&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the current timer callback. </p>
<p>This function can fail, and therefore return <code>NULL</code>, if:</p><ul>
<li>timer is <code>NULL</code></li>
<li>timer has not been initialized (the implementation is invalid)</li>
</ul>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>No </td></tr>
<tr>
<td>Thread-Safe </td><td>Yes </td></tr>
<tr>
<td>Uses Atomics </td><td>Yes </td></tr>
<tr>
<td>Lock-Free </td><td>Yes [1] </td></tr>
</table>
<p><em>[1] if <code>atomic_is_lock_free()</code> returns true for <code>atomic_int_least64_t</code></em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>handle to the timer from the callback should be returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>function pointer to the callback, or <code>NULL</code> if an error occurred </dd></dl>

</div>
</div>
<a id="aba665ea920768fcb03d756d2edddbc73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba665ea920768fcb03d756d2edddbc73">&#9670;&nbsp;</a></span>rcl_timer_exchange_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="timer_8h.html#a18cf5baf35642f49df647b0899d14568">rcl_timer_callback_t</a> rcl_timer_exchange_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__timer__t.html">rcl_timer_t</a> *&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="timer_8h.html#a18cf5baf35642f49df647b0899d14568">rcl_timer_callback_t</a>&#160;</td>
          <td class="paramname"><em>new_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exchange the current timer callback and return the current callback. </p>
<p>This function can fail, and therefore return <code>NULL</code>, if:</p><ul>
<li>timer is <code>NULL</code></li>
<li>timer has not been initialized (the implementation is invalid)</li>
</ul>
<p>This function can set callback to <code>NULL</code>, in which case the callback is ignored when rcl_timer_call is called.</p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>No </td></tr>
<tr>
<td>Thread-Safe </td><td>Yes </td></tr>
<tr>
<td>Uses Atomics </td><td>Yes </td></tr>
<tr>
<td>Lock-Free </td><td>Yes [1] </td></tr>
</table>
<p><em>[1] if <code>atomic_is_lock_free()</code> returns true for <code>atomic_int_least64_t</code></em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">timer</td><td>handle to the timer from the callback should be exchanged </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_callback</td><td>the callback to be exchanged into the timer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>function pointer to the old callback, or <code>NULL</code> if an error occurred </dd></dl>

</div>
</div>
<a id="a128c09cd9077c18194c24f14f77dc83e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a128c09cd9077c18194c24f14f77dc83e">&#9670;&nbsp;</a></span>rcl_timer_cancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> rcl_timer_cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__timer__t.html">rcl_timer_t</a> *&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel a timer. </p>
<p>When a timer is canceled, <a class="el" href="timer_8h.html#ad88d5e72b48c08b5b4acf96dcf1eb598" title="Calculates whether or not the timer should be called. ">rcl_timer_is_ready()</a> will return false for that timer, and <a class="el" href="timer_8h.html#aaf3604512300b10c1a262ddc87007d22" title="Call the timer&#39;s callback and set the last call time. ">rcl_timer_call()</a> will fail with RCL_RET_TIMER_CANCELED.</p>
<p>A canceled timer can be reset with <a class="el" href="timer_8h.html#ae798ac5204198c83a20ee5a0cd5e3a17" title="Reset a timer. ">rcl_timer_reset()</a>, and then used again. Calling this function on an already canceled timer will succeed.</p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>No </td></tr>
<tr>
<td>Thread-Safe </td><td>Yes </td></tr>
<tr>
<td>Uses Atomics </td><td>Yes </td></tr>
<tr>
<td>Lock-Free </td><td>Yes [1] </td></tr>
</table>
<p><em>[1] if <code>atomic_is_lock_free()</code> returns true for <code>atomic_int_least64_t</code></em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">timer</td><td>the timer to be canceled </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RCL_RET_OK</code> if the last call time was retrieved successfully, or </dd>
<dd>
<code>RCL_RET_INVALID_ARGUMENT</code> if any arguments are invalid, or </dd>
<dd>
<code>RCL_RET_TIMER_INVALID</code> if the timer is invalid, or </dd>
<dd>
<code>RCL_RET_ERROR</code> an unspecified error occur. </dd></dl>

</div>
</div>
<a id="a2ae4d03691b385b7d7e3033719539e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae4d03691b385b7d7e3033719539e85">&#9670;&nbsp;</a></span>rcl_timer_is_canceled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> rcl_timer_is_canceled </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrcl__timer__t.html">rcl_timer_t</a> *&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_canceled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the canceled state of a timer. </p>
<p>If the timer is canceled true will be stored in the is_canceled argument. Otherwise false will be stored in the is_canceled argument.</p>
<p>The is_canceled argument must point to an allocated bool, as the result is copied into this variable.</p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>No </td></tr>
<tr>
<td>Thread-Safe </td><td>Yes </td></tr>
<tr>
<td>Uses Atomics </td><td>Yes </td></tr>
<tr>
<td>Lock-Free </td><td>Yes [1] </td></tr>
</table>
<p><em>[1] if <code>atomic_is_lock_free()</code> returns true for <code>atomic_bool</code></em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>the timer to be queried </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_canceled</td><td>storage for the is canceled bool </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RCL_RET_OK</code> if the last call time was retrieved successfully, or </dd>
<dd>
<code>RCL_RET_INVALID_ARGUMENT</code> if any arguments are invalid, or </dd>
<dd>
<code>RCL_RET_TIMER_INVALID</code> if the timer is invalid, or </dd>
<dd>
<code>RCL_RET_ERROR</code> an unspecified error occur. </dd></dl>

</div>
</div>
<a id="ae798ac5204198c83a20ee5a0cd5e3a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae798ac5204198c83a20ee5a0cd5e3a17">&#9670;&nbsp;</a></span>rcl_timer_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af66ec2e20118b821dbf3f9b0067e8796">rcl_ret_t</a> rcl_timer_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrcl__timer__t.html">rcl_timer_t</a> *&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset a timer. </p>
<p>This function can be called on a timer, canceled or not. For all timers it will reset the last call time to now. For canceled timers it will additionally make the timer not canceled.</p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>No </td></tr>
<tr>
<td>Thread-Safe </td><td>Yes </td></tr>
<tr>
<td>Uses Atomics </td><td>Yes </td></tr>
<tr>
<td>Lock-Free </td><td>Yes [1] </td></tr>
</table>
<p><em>[1] if <code>atomic_is_lock_free()</code> returns true for <code>atomic_int_least64_t</code></em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">timer</td><td>the timer to be reset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RCL_RET_OK</code> if the last call time was retrieved successfully, or </dd>
<dd>
<code>RCL_RET_INVALID_ARGUMENT</code> if any arguments are invalid, or </dd>
<dd>
<code>RCL_RET_TIMER_INVALID</code> if the timer is invalid, or </dd>
<dd>
<code>RCL_RET_ERROR</code> an unspecified error occur. </dd></dl>

</div>
</div>
<a id="ab772bd917feb04005eef2515948f8d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab772bd917feb04005eef2515948f8d64">&#9670;&nbsp;</a></span>rcl_timer_get_allocator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="allocator_8h.html#ac7146d98a03ca836efa0d0d77c78984c">rcl_allocator_t</a>* rcl_timer_get_allocator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrcl__timer__t.html">rcl_timer_t</a> *&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the allocator for the timer. </p>
<p>This function can fail, and therefore return <code>NULL</code>, if:</p><ul>
<li>timer is <code>NULL</code></li>
<li>timer has not been initialized (the implementation is invalid)</li>
</ul>
<p>The returned pointer is only valid as long as the timer object is valid.</p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>No </td></tr>
<tr>
<td>Thread-Safe </td><td>Yes </td></tr>
<tr>
<td>Uses Atomics </td><td>No </td></tr>
<tr>
<td>Lock-Free </td><td>Yes </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">timer</td><td>handle to the timer object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the allocator, or <code>NULL</code> if an error occurred </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
