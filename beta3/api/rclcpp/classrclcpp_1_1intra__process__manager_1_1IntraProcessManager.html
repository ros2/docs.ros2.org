<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rclcpp: rclcpp::intra_process_manager::IntraProcessManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rclcpp
   &#160;<span id="projectnumber">master</span>
   </div>
   <div id="projectbrief">C++ ROS Client Library API</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacerclcpp.html">rclcpp</a></li><li class="navelem"><a class="el" href="namespacerclcpp_1_1intra__process__manager.html">intra_process_manager</a></li><li class="navelem"><a class="el" href="classrclcpp_1_1intra__process__manager_1_1IntraProcessManager.html">IntraProcessManager</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classrclcpp_1_1intra__process__manager_1_1IntraProcessManager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rclcpp::intra_process_manager::IntraProcessManager Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class facilitates intra process communication between nodes.  
 <a href="classrclcpp_1_1intra__process__manager_1_1IntraProcessManager.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="intra__process__manager_8hpp_source.html">intra_process_manager.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a88a695ff7af5743df873e7d96145d39b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1intra__process__manager_1_1IntraProcessManager.html#a88a695ff7af5743df873e7d96145d39b">IntraProcessManager</a> (IntraProcessManagerImplBase::SharedPtr state=<a class="el" href="namespacerclcpp_1_1intra__process__manager.html#a446e57ef21f3d206c534bfa603fb490d">create_default_impl</a>())</td></tr>
<tr class="separator:a88a695ff7af5743df873e7d96145d39b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad287ed1fe0f7a021404dd1ba3b20f851"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1intra__process__manager_1_1IntraProcessManager.html#ad287ed1fe0f7a021404dd1ba3b20f851">~IntraProcessManager</a> ()</td></tr>
<tr class="separator:ad287ed1fe0f7a021404dd1ba3b20f851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea83c290d04b40985a6c9f53889362ae"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1intra__process__manager_1_1IntraProcessManager.html#aea83c290d04b40985a6c9f53889362ae">add_subscription</a> (subscription::SubscriptionBase::SharedPtr subscription)</td></tr>
<tr class="memdesc:aea83c290d04b40985a6c9f53889362ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a subscription with the manager, returns subscriptions unique id.  <a href="#aea83c290d04b40985a6c9f53889362ae">More...</a><br /></td></tr>
<tr class="separator:aea83c290d04b40985a6c9f53889362ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa4d89defdb3e6ed1ab0f0e20bdf577"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1intra__process__manager_1_1IntraProcessManager.html#a9fa4d89defdb3e6ed1ab0f0e20bdf577">remove_subscription</a> (uint64_t intra_process_subscription_id)</td></tr>
<tr class="memdesc:a9fa4d89defdb3e6ed1ab0f0e20bdf577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister a subscription using the subscription's unique id.  <a href="#a9fa4d89defdb3e6ed1ab0f0e20bdf577">More...</a><br /></td></tr>
<tr class="separator:a9fa4d89defdb3e6ed1ab0f0e20bdf577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7e48ed639f110aa1826f8a9a434bb8"><td class="memTemplParams" colspan="2">template&lt;typename MessageT , typename Alloc &gt; </td></tr>
<tr class="memitem:a2c7e48ed639f110aa1826f8a9a434bb8"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1intra__process__manager_1_1IntraProcessManager.html#a2c7e48ed639f110aa1826f8a9a434bb8">add_publisher</a> (typename <a class="el" href="classrclcpp_1_1publisher_1_1Publisher.html">publisher::Publisher</a>&lt; MessageT, Alloc &gt;::SharedPtr publisher, size_t buffer_size=0)</td></tr>
<tr class="memdesc:a2c7e48ed639f110aa1826f8a9a434bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a publisher with the manager, returns the publisher unique id.  <a href="#a2c7e48ed639f110aa1826f8a9a434bb8">More...</a><br /></td></tr>
<tr class="separator:a2c7e48ed639f110aa1826f8a9a434bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f0a7369cfd653f8e911f54c446349e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1intra__process__manager_1_1IntraProcessManager.html#ac1f0a7369cfd653f8e911f54c446349e">remove_publisher</a> (uint64_t intra_process_publisher_id)</td></tr>
<tr class="memdesc:ac1f0a7369cfd653f8e911f54c446349e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister a publisher using the publisher's unique id.  <a href="#ac1f0a7369cfd653f8e911f54c446349e">More...</a><br /></td></tr>
<tr class="separator:ac1f0a7369cfd653f8e911f54c446349e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa42b0837e4a64a209de4346427abb963"><td class="memTemplParams" colspan="2">template&lt;typename MessageT , typename Alloc  = std::allocator&lt;void&gt;, typename Deleter  = std::default_delete&lt;MessageT&gt;&gt; </td></tr>
<tr class="memitem:aa42b0837e4a64a209de4346427abb963"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1intra__process__manager_1_1IntraProcessManager.html#aa42b0837e4a64a209de4346427abb963">store_intra_process_message</a> (uint64_t intra_process_publisher_id, std::unique_ptr&lt; MessageT, Deleter &gt; &amp;message)</td></tr>
<tr class="memdesc:aa42b0837e4a64a209de4346427abb963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a message in the manager, and return the message sequence number.  <a href="#aa42b0837e4a64a209de4346427abb963">More...</a><br /></td></tr>
<tr class="separator:aa42b0837e4a64a209de4346427abb963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90043fdd6adc11315d538fe3042503dd"><td class="memTemplParams" colspan="2">template&lt;typename MessageT , typename Alloc  = std::allocator&lt;void&gt;, typename Deleter  = std::default_delete&lt;MessageT&gt;&gt; </td></tr>
<tr class="memitem:a90043fdd6adc11315d538fe3042503dd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1intra__process__manager_1_1IntraProcessManager.html#a90043fdd6adc11315d538fe3042503dd">take_intra_process_message</a> (uint64_t intra_process_publisher_id, uint64_t message_sequence_number, uint64_t requesting_subscriptions_intra_process_id, std::unique_ptr&lt; MessageT, Deleter &gt; &amp;message)</td></tr>
<tr class="memdesc:a90043fdd6adc11315d538fe3042503dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take an intra process message.  <a href="#a90043fdd6adc11315d538fe3042503dd">More...</a><br /></td></tr>
<tr class="separator:a90043fdd6adc11315d538fe3042503dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89b60b173fba4034878578c5a0cc075"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1intra__process__manager_1_1IntraProcessManager.html#ad89b60b173fba4034878578c5a0cc075">matches_any_publishers</a> (const rmw_gid_t *id) const</td></tr>
<tr class="memdesc:ad89b60b173fba4034878578c5a0cc075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given rmw_gid_t matches any stored Publishers.  <a href="#ad89b60b173fba4034878578c5a0cc075">More...</a><br /></td></tr>
<tr class="separator:ad89b60b173fba4034878578c5a0cc075"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class facilitates intra process communication between nodes. </p>
<p>This class is used in the creation of publishers and subscriptions. A singleton instance of this class is owned by a rclcpp::Context and a rclcpp::Node can use an associated Context to get an instance of this class. Nodes which do not have a common Context will not exchange intra process messages because they will not share access to an instance of this class.</p>
<p>When a Node creates a publisher or subscription, it will register them with this class. The node will also hook into the publisher's publish call in order to do intra process related work.</p>
<p>When a publisher is created, it advertises on the topic the user provided, as well as a "shadowing" topic of type rcl_interfaces/IntraProcessMessage. For instance, if the user specified the topic '/namespace/chatter', then the corresponding intra process topic might be '/namespace/chatter/_intra'. The publisher is also allocated an id which is unique among all publishers and subscriptions in this process. Additionally, when registered with this class a ring buffer is created and owned by this class as a temporary place to hold messages destined for intra process subscriptions.</p>
<p>When a subscription is created, it subscribes to the topic provided by the user as well as to the corresponding intra process topic. It is also gets a unique id from the singleton instance of this class which is unique among publishers and subscriptions.</p>
<p>When the user publishes a message, the message is stored by calling store_intra_process_message on this class. The instance of that message is uniquely identified by a publisher id and a message sequence number. The publisher id, message sequence pair is unique with in the process. At that point a list of the id's of intra process subscriptions which have been registered with the singleton instance of this class are stored with the message instance so that delivery is only made to those subscriptions. Then an instance of rcl_interfaces/IntraProcessMessage is published to the intra process topic which is specific to the topic specified by the user.</p>
<p>When an instance of rcl_interfaces/IntraProcessMessage is received by a subscription, then it is handled by calling take_intra_process_message on a singleton of this class. The subscription passes a publisher id, message sequence pair which uniquely identifies the message instance it was suppose to receive as well as the subscriptions unique id. If the message is still being held by this class and the subscription's id is in the list of intended subscriptions then the message is returned. If either of those predicates are not satisfied then the message is not returned and the subscription does not call the users callback.</p>
<p>Since the publisher builds a list of destined subscriptions on publish, and other requests are ignored, this class knows how many times a message instance should be requested. The final time a message is requested, the ownership is passed out of this class and passed to the final subscription, effectively freeing space in this class's internal storage.</p>
<p>Since a topic is being used to ferry notifications about new intra process messages between publishers and subscriptions, it is possible for that notification to be lost. It is also possible that a subscription which was available when publish was called will no longer exist once the notification gets posted. In both cases this might result in a message instance getting requested fewer times than expected. This is why the internal storage of this class is a ring buffer. That way if a message is orphaned it will eventually be dropped from storage when a new message instance is stored and will not result in a memory leak.</p>
<p>However, since the storage system is finite, this also means that a message instance might get displaced by an incoming message instance before all interested parties have called take_intra_process_message. Because of this the size of the internal storage should be carefully considered.</p>
<p>/TODO(wjwwood): update to include information about handling latching. /TODO(wjwwood): consider thread safety of the class.</p>
<p>This class is neither CopyConstructable nor CopyAssignable. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a88a695ff7af5743df873e7d96145d39b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a695ff7af5743df873e7d96145d39b">&#9670;&nbsp;</a></span>IntraProcessManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rclcpp::intra_process_manager::IntraProcessManager::IntraProcessManager </td>
          <td>(</td>
          <td class="paramtype">IntraProcessManagerImplBase::SharedPtr&#160;</td>
          <td class="paramname"><em>state</em> = <code><a class="el" href="namespacerclcpp_1_1intra__process__manager.html#a446e57ef21f3d206c534bfa603fb490d">create_default_impl</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad287ed1fe0f7a021404dd1ba3b20f851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad287ed1fe0f7a021404dd1ba3b20f851">&#9670;&nbsp;</a></span>~IntraProcessManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual rclcpp::intra_process_manager::IntraProcessManager::~IntraProcessManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aea83c290d04b40985a6c9f53889362ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea83c290d04b40985a6c9f53889362ae">&#9670;&nbsp;</a></span>add_subscription()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t rclcpp::intra_process_manager::IntraProcessManager::add_subscription </td>
          <td>(</td>
          <td class="paramtype">subscription::SubscriptionBase::SharedPtr&#160;</td>
          <td class="paramname"><em>subscription</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a subscription with the manager, returns subscriptions unique id. </p>
<p>In addition to generating a unique intra process id for the subscription, this method also stores the topic name of the subscription.</p>
<p>This method is normally called during the creation of a subscription, but after it creates the internal intra process rmw_subscription_t.</p>
<p>This method will allocate memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subscription</td><td>the Subscription to register. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an unsigned 64-bit integer which is the subscription's unique id. </dd></dl>

</div>
</div>
<a id="a9fa4d89defdb3e6ed1ab0f0e20bdf577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa4d89defdb3e6ed1ab0f0e20bdf577">&#9670;&nbsp;</a></span>remove_subscription()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::intra_process_manager::IntraProcessManager::remove_subscription </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>intra_process_subscription_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister a subscription using the subscription's unique id. </p>
<p>This method does not allocate memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intra_process_subscription_id</td><td>id of the subscription to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c7e48ed639f110aa1826f8a9a434bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c7e48ed639f110aa1826f8a9a434bb8">&#9670;&nbsp;</a></span>add_publisher()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MessageT , typename Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t rclcpp::intra_process_manager::IntraProcessManager::add_publisher </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classrclcpp_1_1publisher_1_1Publisher.html">publisher::Publisher</a>&lt; MessageT, Alloc &gt;::SharedPtr&#160;</td>
          <td class="paramname"><em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a publisher with the manager, returns the publisher unique id. </p>
<p>In addition to generating and returning a unique id for the publisher, this method creates internal ring buffer storage for "in-flight" intra process messages which are stored when store_intra_process_message is called with this publisher's unique id.</p>
<p>The buffer_size must be less than or equal to the max uint64_t value. If the buffer_size is 0 then a buffer size is calculated using the publisher's QoS settings. The default is to use the depth field of the publisher's QoS. TODO(wjwwood): Consider doing depth *= 1.2, round up, or similar. TODO(wjwwood): Consider what to do for keep all.</p>
<p>This method is templated on the publisher's message type so that internal storage of the same type can be allocated.</p>
<p>This method will allocate memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">publisher</td><td>publisher to be registered with the manager. </td></tr>
    <tr><td class="paramname">buffer_size</td><td>if 0 (default) a size is calculated based on the QoS. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an unsigned 64-bit integer which is the publisher's unique id. </dd></dl>

</div>
</div>
<a id="ac1f0a7369cfd653f8e911f54c446349e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f0a7369cfd653f8e911f54c446349e">&#9670;&nbsp;</a></span>remove_publisher()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::intra_process_manager::IntraProcessManager::remove_publisher </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>intra_process_publisher_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister a publisher using the publisher's unique id. </p>
<p>This method does not allocate memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intra_process_publisher_id</td><td>id of the publisher to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa42b0837e4a64a209de4346427abb963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa42b0837e4a64a209de4346427abb963">&#9670;&nbsp;</a></span>store_intra_process_message()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MessageT , typename Alloc  = std::allocator&lt;void&gt;, typename Deleter  = std::default_delete&lt;MessageT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t rclcpp::intra_process_manager::IntraProcessManager::store_intra_process_message </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>intra_process_publisher_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; MessageT, Deleter &gt; &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store a message in the manager, and return the message sequence number. </p>
<p>The given message is stored in internal storage using the given publisher id and the newly generated message sequence, which is also returned. The combination of publisher id and message sequence number can later be used with a subscription id to retrieve the message by calling take_intra_process_message. The number of times take_intra_process_message can be called with this unique pair of id's is determined by the number of subscriptions currently subscribed to the same topic and which share the same Context, i.e. once for each subscription which should receive the intra process message.</p>
<p>The ownership of the incoming message is transfered to the internal storage in order to avoid copying the message data. Therefore, the message parameter will no longer contain the original message after calling this method. Instead it will either be a nullptr or it will contain the ownership of the message instance which was displaced. If the message parameter is not equal to nullptr after calling this method then a message was prematurely displaced, i.e. take_intra_process_message had not been called on it as many times as was expected.</p>
<p>This method can throw an exception if the publisher id is not found or if the publisher shared_ptr given to add_publisher has gone out of scope.</p>
<p>This method does allocate memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intra_process_publisher_id</td><td>the id of the publisher of this message. </td></tr>
    <tr><td class="paramname">message</td><td>the message that is being stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the message sequence number. </dd></dl>

</div>
</div>
<a id="a90043fdd6adc11315d538fe3042503dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90043fdd6adc11315d538fe3042503dd">&#9670;&nbsp;</a></span>take_intra_process_message()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MessageT , typename Alloc  = std::allocator&lt;void&gt;, typename Deleter  = std::default_delete&lt;MessageT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::intra_process_manager::IntraProcessManager::take_intra_process_message </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>intra_process_publisher_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>message_sequence_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>requesting_subscriptions_intra_process_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; MessageT, Deleter &gt; &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Take an intra process message. </p>
<p>The intra_process_publisher_id and message_sequence_number parameters uniquely identify a message instance, which should be taken.</p>
<p>The requesting_subscriptions_intra_process_id parameter is used to make sure the requesting subscription was intended to receive this message instance. This check is made because it could happen that the requester comes up after the publish event, so it still receives the notification of a new intra process message, but it wasn't registered with the manager at the time of publishing, causing it to take when it wasn't intended. This should be avioded unless latching-like behavior is involved.</p>
<p>The message parameter is used to store the taken message. On the last expected call to this method, the ownership is transfered out of internal storage and into the message parameter. On all previous calls a copy of the internally stored message is made and the ownership of the copy is transfered to the message parameter. TODO(wjwwood): update this documentation when latching is supported.</p>
<p>The message parameter can be set to nullptr if:</p>
<ul>
<li>The publisher id is not found.</li>
<li>The message sequence is not found for the given publisher id.</li>
<li>The requesting subscription's id is not in the list of intended takers.</li>
<li>The requesting subscription's id has been used before with this message.</li>
</ul>
<p>This method may allocate memory to copy the stored message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intra_process_publisher_id</td><td>the id of the message's publisher. </td></tr>
    <tr><td class="paramname">message_sequence_number</td><td>the sequence number of the message. </td></tr>
    <tr><td class="paramname">requesting_subscriptions_intra_process_id</td><td>the subscription's id. </td></tr>
    <tr><td class="paramname">message</td><td>the message typed unique_ptr used to return the message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad89b60b173fba4034878578c5a0cc075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad89b60b173fba4034878578c5a0cc075">&#9670;&nbsp;</a></span>matches_any_publishers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rclcpp::intra_process_manager::IntraProcessManager::matches_any_publishers </td>
          <td>(</td>
          <td class="paramtype">const rmw_gid_t *&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the given rmw_gid_t matches any stored Publishers. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/rclcpp/<a class="el" href="intra__process__manager_8hpp_source.html">intra_process_manager.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
