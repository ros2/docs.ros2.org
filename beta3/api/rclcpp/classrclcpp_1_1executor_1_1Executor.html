<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>rclcpp: rclcpp::executor::Executor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rclcpp
   &#160;<span id="projectnumber">master</span>
   </div>
   <div id="projectbrief">C++ ROS Client Library API</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacerclcpp.html">rclcpp</a></li><li class="navelem"><a class="el" href="namespacerclcpp_1_1executor.html">executor</a></li><li class="navelem"><a class="el" href="classrclcpp_1_1executor_1_1Executor.html">Executor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classrclcpp_1_1executor_1_1Executor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rclcpp::executor::Executor Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Coordinate the order and timing of available communication tasks.  
 <a href="classrclcpp_1_1executor_1_1Executor.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="executor_8hpp_source.html">executor.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for rclcpp::executor::Executor:</div>
<div class="dyncontent">
<div class="center"><img src="classrclcpp_1_1executor_1_1Executor__inherit__graph.png" border="0" usemap="#rclcpp_1_1executor_1_1Executor_inherit__map" alt="Inheritance graph"/></div>
<map name="rclcpp_1_1executor_1_1Executor_inherit__map" id="rclcpp_1_1executor_1_1Executor_inherit__map">
<area shape="rect" id="node2" href="classrclcpp_1_1executors_1_1multi__threaded__executor_1_1MultiThreadedExecutor.html" title="rclcpp::executors::\lmulti_threaded_executor\l::MultiThreadedExecutor" alt="" coords="232,5,396,61"/>
<area shape="rect" id="node3" href="classrclcpp_1_1executors_1_1single__threaded__executor_1_1SingleThreadedExecutor.html" title="Single&#45;threaded executor implementation. " alt="" coords="228,85,400,141"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9410bbfe9b26d9a60035f326dbe962c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executor_1_1Executor.html#a9410bbfe9b26d9a60035f326dbe962c2">Executor</a> (const <a class="el" href="structrclcpp_1_1executor_1_1ExecutorArgs.html">ExecutorArgs</a> &amp;args=create_default_executor_arguments())</td></tr>
<tr class="memdesc:a9410bbfe9b26d9a60035f326dbe962c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a9410bbfe9b26d9a60035f326dbe962c2">More...</a><br /></td></tr>
<tr class="separator:a9410bbfe9b26d9a60035f326dbe962c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba498c4af4b65da3eca01068861c65c5"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executor_1_1Executor.html#aba498c4af4b65da3eca01068861c65c5">~Executor</a> ()</td></tr>
<tr class="memdesc:aba498c4af4b65da3eca01068861c65c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor.  <a href="#aba498c4af4b65da3eca01068861c65c5">More...</a><br /></td></tr>
<tr class="separator:aba498c4af4b65da3eca01068861c65c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34509baf643c9a7f88bf0b7f4a983955"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executor_1_1Executor.html#a34509baf643c9a7f88bf0b7f4a983955">spin</a> ()=0</td></tr>
<tr class="memdesc:a34509baf643c9a7f88bf0b7f4a983955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do work periodically as it becomes available to us. Blocking call, may block indefinitely.  <a href="#a34509baf643c9a7f88bf0b7f4a983955">More...</a><br /></td></tr>
<tr class="separator:a34509baf643c9a7f88bf0b7f4a983955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363491ae55c619db310861a3ef4cc4b0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executor_1_1Executor.html#a363491ae55c619db310861a3ef4cc4b0">add_node</a> (rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node_ptr, bool notify=true)</td></tr>
<tr class="memdesc:a363491ae55c619db310861a3ef4cc4b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a node to the executor.  <a href="#a363491ae55c619db310861a3ef4cc4b0">More...</a><br /></td></tr>
<tr class="separator:a363491ae55c619db310861a3ef4cc4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5919b4736199688fafb02497d01cad35"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executor_1_1Executor.html#a5919b4736199688fafb02497d01cad35">add_node</a> (std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1node_1_1Node.html">rclcpp::node::Node</a> &gt; node_ptr, bool notify=true)</td></tr>
<tr class="memdesc:a5919b4736199688fafb02497d01cad35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function which takes Node and forwards NodeBaseInterface.  <a href="#a5919b4736199688fafb02497d01cad35">More...</a><br /></td></tr>
<tr class="separator:a5919b4736199688fafb02497d01cad35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ebe21baa5b23f22d7b7055e4bd1186"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executor_1_1Executor.html#a96ebe21baa5b23f22d7b7055e4bd1186">remove_node</a> (rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node_ptr, bool notify=true)</td></tr>
<tr class="memdesc:a96ebe21baa5b23f22d7b7055e4bd1186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a node from the executor.  <a href="#a96ebe21baa5b23f22d7b7055e4bd1186">More...</a><br /></td></tr>
<tr class="separator:a96ebe21baa5b23f22d7b7055e4bd1186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71fff5dac6072c86426217639439131e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executor_1_1Executor.html#a71fff5dac6072c86426217639439131e">remove_node</a> (std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1node_1_1Node.html">rclcpp::node::Node</a> &gt; node_ptr, bool notify=true)</td></tr>
<tr class="memdesc:a71fff5dac6072c86426217639439131e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function which takes Node and forwards NodeBaseInterface.  <a href="#a71fff5dac6072c86426217639439131e">More...</a><br /></td></tr>
<tr class="separator:a71fff5dac6072c86426217639439131e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990f711caca8274d3e61cde959a9ec22"><td class="memTemplParams" colspan="2">template&lt;typename T  = std::milli&gt; </td></tr>
<tr class="memitem:a990f711caca8274d3e61cde959a9ec22"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executor_1_1Executor.html#a990f711caca8274d3e61cde959a9ec22">spin_node_once</a> (rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node, std::chrono::duration&lt; int64_t, T &gt; timeout=std::chrono::duration&lt; int64_t, T &gt;(-1))</td></tr>
<tr class="memdesc:a990f711caca8274d3e61cde959a9ec22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a node to executor, execute the next available unit of work, and remove the node.  <a href="#a990f711caca8274d3e61cde959a9ec22">More...</a><br /></td></tr>
<tr class="separator:a990f711caca8274d3e61cde959a9ec22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f0e4ef31e588789fb4c17ca9001d7e"><td class="memTemplParams" colspan="2">template&lt;typename NodeT  = rclcpp::node::Node, typename T  = std::milli&gt; </td></tr>
<tr class="memitem:aa5f0e4ef31e588789fb4c17ca9001d7e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executor_1_1Executor.html#aa5f0e4ef31e588789fb4c17ca9001d7e">spin_node_once</a> (std::shared_ptr&lt; NodeT &gt; node, std::chrono::duration&lt; int64_t, T &gt; timeout=std::chrono::duration&lt; int64_t, T &gt;(-1))</td></tr>
<tr class="memdesc:aa5f0e4ef31e588789fb4c17ca9001d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function which takes Node and forwards NodeBaseInterface.  <a href="#aa5f0e4ef31e588789fb4c17ca9001d7e">More...</a><br /></td></tr>
<tr class="separator:aa5f0e4ef31e588789fb4c17ca9001d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeccc9ee445a31f7facafbd81e650a37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executor_1_1Executor.html#adeccc9ee445a31f7facafbd81e650a37">spin_node_some</a> (rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node)</td></tr>
<tr class="memdesc:adeccc9ee445a31f7facafbd81e650a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a node, complete all immediately available work, and remove the node.  <a href="#adeccc9ee445a31f7facafbd81e650a37">More...</a><br /></td></tr>
<tr class="separator:adeccc9ee445a31f7facafbd81e650a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e531df5734e1772083dfa9db4ca33d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executor_1_1Executor.html#a7e531df5734e1772083dfa9db4ca33d8">spin_node_some</a> (std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1node_1_1Node.html">rclcpp::node::Node</a> &gt; node)</td></tr>
<tr class="memdesc:a7e531df5734e1772083dfa9db4ca33d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function which takes Node and forwards NodeBaseInterface.  <a href="#a7e531df5734e1772083dfa9db4ca33d8">More...</a><br /></td></tr>
<tr class="separator:a7e531df5734e1772083dfa9db4ca33d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb1fa384d7113d2e93659e4583c5fd1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executor_1_1Executor.html#abeb1fa384d7113d2e93659e4583c5fd1">spin_some</a> ()</td></tr>
<tr class="memdesc:abeb1fa384d7113d2e93659e4583c5fd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete all available queued work without blocking.  <a href="#abeb1fa384d7113d2e93659e4583c5fd1">More...</a><br /></td></tr>
<tr class="separator:abeb1fa384d7113d2e93659e4583c5fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2ce2abdc1a1be9cad2e481830feb9f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executor_1_1Executor.html#aba2ce2abdc1a1be9cad2e481830feb9f">spin_once</a> (std::chrono::nanoseconds timeout=std::chrono::nanoseconds(-1))</td></tr>
<tr class="separator:aba2ce2abdc1a1be9cad2e481830feb9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef288c02dcbf229d34a4ee91313b0ef9"><td class="memTemplParams" colspan="2">template&lt;typename ResponseT , typename TimeT  = std::milli&gt; </td></tr>
<tr class="memitem:aef288c02dcbf229d34a4ee91313b0ef9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacerclcpp_1_1executor.html#a3114c96743c4a4d68e739a7e43642347">FutureReturnCode</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executor_1_1Executor.html#aef288c02dcbf229d34a4ee91313b0ef9">spin_until_future_complete</a> (std::shared_future&lt; ResponseT &gt; &amp;future, std::chrono::duration&lt; int64_t, TimeT &gt; timeout=std::chrono::duration&lt; int64_t, TimeT &gt;(-1))</td></tr>
<tr class="memdesc:aef288c02dcbf229d34a4ee91313b0ef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spin (blocking) until the future is complete, it times out waiting, or rclcpp is interrupted.  <a href="#aef288c02dcbf229d34a4ee91313b0ef9">More...</a><br /></td></tr>
<tr class="separator:aef288c02dcbf229d34a4ee91313b0ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7496f96836709f72f9a7cd69b5966c2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executor_1_1Executor.html#a7496f96836709f72f9a7cd69b5966c2b">cancel</a> ()</td></tr>
<tr class="memdesc:a7496f96836709f72f9a7cd69b5966c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel any running spin* function, causing it to return.  <a href="#a7496f96836709f72f9a7cd69b5966c2b">More...</a><br /></td></tr>
<tr class="separator:a7496f96836709f72f9a7cd69b5966c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba6022ab18de85e549b9c2c51e81cbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executor_1_1Executor.html#a7ba6022ab18de85e549b9c2c51e81cbe">set_memory_strategy</a> (memory_strategy::MemoryStrategy::SharedPtr memory_strategy)</td></tr>
<tr class="memdesc:a7ba6022ab18de85e549b9c2c51e81cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support dynamic switching of the memory strategy.  <a href="#a7ba6022ab18de85e549b9c2c51e81cbe">More...</a><br /></td></tr>
<tr class="separator:a7ba6022ab18de85e549b9c2c51e81cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a0e1ac67fe0e978dadf53ce67033f0f10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executor_1_1Executor.html#a0e1ac67fe0e978dadf53ce67033f0f10">spin_node_once_nanoseconds</a> (rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node, std::chrono::nanoseconds timeout)</td></tr>
<tr class="separator:a0e1ac67fe0e978dadf53ce67033f0f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e5a869e141b1fc694853f232d8dd207"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executor_1_1Executor.html#a6e5a869e141b1fc694853f232d8dd207">execute_any_executable</a> (AnyExecutable::SharedPtr any_exec)</td></tr>
<tr class="memdesc:a6e5a869e141b1fc694853f232d8dd207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the next available executable and do the work associated with it.  <a href="#a6e5a869e141b1fc694853f232d8dd207">More...</a><br /></td></tr>
<tr class="separator:a6e5a869e141b1fc694853f232d8dd207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb8a7dddb0badb4a1ba995a48fa19f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executor_1_1Executor.html#adcb8a7dddb0badb4a1ba995a48fa19f1">wait_for_work</a> (std::chrono::nanoseconds timeout=std::chrono::nanoseconds(-1))</td></tr>
<tr class="separator:adcb8a7dddb0badb4a1ba995a48fa19f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab397cc465da65a5fd58a3e5e044938b2"><td class="memItemLeft" align="right" valign="top">rclcpp::node_interfaces::NodeBaseInterface::SharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executor_1_1Executor.html#ab397cc465da65a5fd58a3e5e044938b2">get_node_by_group</a> (rclcpp::callback_group::CallbackGroup::SharedPtr group)</td></tr>
<tr class="separator:ab397cc465da65a5fd58a3e5e044938b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5815fb9bd5dea48fdc7c2480be556c"><td class="memItemLeft" align="right" valign="top">rclcpp::callback_group::CallbackGroup::SharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executor_1_1Executor.html#a0f5815fb9bd5dea48fdc7c2480be556c">get_group_by_timer</a> (rclcpp::timer::TimerBase::SharedPtr timer)</td></tr>
<tr class="separator:a0f5815fb9bd5dea48fdc7c2480be556c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1987e10bc8bd4859c4b730a64b0ccd3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executor_1_1Executor.html#a1987e10bc8bd4859c4b730a64b0ccd3c">get_next_timer</a> (AnyExecutable::SharedPtr any_exec)</td></tr>
<tr class="separator:a1987e10bc8bd4859c4b730a64b0ccd3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7650a6160ff5ec592b2a89d60d84076"><td class="memItemLeft" align="right" valign="top">AnyExecutable::SharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executor_1_1Executor.html#ab7650a6160ff5ec592b2a89d60d84076">get_next_ready_executable</a> ()</td></tr>
<tr class="separator:ab7650a6160ff5ec592b2a89d60d84076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5948a7f6f9818c4610898d752e0da3c"><td class="memItemLeft" align="right" valign="top">AnyExecutable::SharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executor_1_1Executor.html#ad5948a7f6f9818c4610898d752e0da3c">get_next_executable</a> (std::chrono::nanoseconds timeout=std::chrono::nanoseconds(-1))</td></tr>
<tr class="separator:ad5948a7f6f9818c4610898d752e0da3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:ac5197c0a602bcb4474a524fc0d3cc1f3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executor_1_1Executor.html#ac5197c0a602bcb4474a524fc0d3cc1f3">execute_subscription</a> (rclcpp::subscription::SubscriptionBase::SharedPtr subscription)</td></tr>
<tr class="separator:ac5197c0a602bcb4474a524fc0d3cc1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe61e1d94c19f504e7fb21780a953825"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executor_1_1Executor.html#abe61e1d94c19f504e7fb21780a953825">execute_intra_process_subscription</a> (rclcpp::subscription::SubscriptionBase::SharedPtr subscription)</td></tr>
<tr class="separator:abe61e1d94c19f504e7fb21780a953825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580d5718812abd68063e365d1d903899"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executor_1_1Executor.html#a580d5718812abd68063e365d1d903899">execute_timer</a> (rclcpp::timer::TimerBase::SharedPtr timer)</td></tr>
<tr class="separator:a580d5718812abd68063e365d1d903899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9345a99ccc00887bc54394724f983400"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executor_1_1Executor.html#a9345a99ccc00887bc54394724f983400">execute_service</a> (rclcpp::service::ServiceBase::SharedPtr service)</td></tr>
<tr class="separator:a9345a99ccc00887bc54394724f983400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6947d3209d3850ce810b80cddac0098"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executor_1_1Executor.html#ac6947d3209d3850ce810b80cddac0098">execute_client</a> (rclcpp::client::ClientBase::SharedPtr client)</td></tr>
<tr class="separator:ac6947d3209d3850ce810b80cddac0098"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a5e0e8e417745489419845b01d062c199"><td class="memItemLeft" align="right" valign="top">std::atomic_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executor_1_1Executor.html#a5e0e8e417745489419845b01d062c199">spinning</a></td></tr>
<tr class="memdesc:a5e0e8e417745489419845b01d062c199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spinning state, used to prevent multi threaded calls to spin and to cancel blocking spins.  <a href="#a5e0e8e417745489419845b01d062c199">More...</a><br /></td></tr>
<tr class="separator:a5e0e8e417745489419845b01d062c199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4b4abaada22c32a6a891c255b07785"><td class="memItemLeft" align="right" valign="top">rcl_guard_condition_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executor_1_1Executor.html#a7d4b4abaada22c32a6a891c255b07785">interrupt_guard_condition_</a> = rcl_get_zero_initialized_guard_condition()</td></tr>
<tr class="memdesc:a7d4b4abaada22c32a6a891c255b07785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guard condition for signaling the rmw layer to wake up for special events.  <a href="#a7d4b4abaada22c32a6a891c255b07785">More...</a><br /></td></tr>
<tr class="separator:a7d4b4abaada22c32a6a891c255b07785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75dddd896cbfb268f8cd95e0143b3f45"><td class="memItemLeft" align="right" valign="top">rcl_wait_set_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executor_1_1Executor.html#a75dddd896cbfb268f8cd95e0143b3f45">waitset_</a> = rcl_get_zero_initialized_wait_set()</td></tr>
<tr class="memdesc:a75dddd896cbfb268f8cd95e0143b3f45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waitset for managing entities that the rmw layer waits on.  <a href="#a75dddd896cbfb268f8cd95e0143b3f45">More...</a><br /></td></tr>
<tr class="separator:a75dddd896cbfb268f8cd95e0143b3f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ebeafb12ab052ce2675b260ca231751"><td class="memItemLeft" align="right" valign="top">memory_strategy::MemoryStrategy::SharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1executor_1_1Executor.html#a5ebeafb12ab052ce2675b260ca231751">memory_strategy_</a></td></tr>
<tr class="memdesc:a5ebeafb12ab052ce2675b260ca231751"><td class="mdescLeft">&#160;</td><td class="mdescRight">The memory strategy: an interface for handling user-defined memory allocation strategies.  <a href="#a5ebeafb12ab052ce2675b260ca231751">More...</a><br /></td></tr>
<tr class="separator:a5ebeafb12ab052ce2675b260ca231751"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Coordinate the order and timing of available communication tasks. </p>
<p><a class="el" href="classrclcpp_1_1executor_1_1Executor.html" title="Coordinate the order and timing of available communication tasks. ">Executor</a> provides spin functions (including spin_node_once and spin_some). It coordinates the nodes and callback groups by looking for available work and completing it, based on the threading or concurrency scheme provided by the subclass implementation. An example of available work is executing a subscription callback, or a timer callback. The executor structure allows for a decoupling of the communication graph and the execution model. See SingleThreadedExecutor and MultiThreadedExecutor for examples of execution paradigms. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9410bbfe9b26d9a60035f326dbe962c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rclcpp::executor::Executor::Executor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrclcpp_1_1executor_1_1ExecutorArgs.html">ExecutorArgs</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em> = <code>create_default_executor_arguments()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>

</div>
</div>
<a class="anchor" id="aba498c4af4b65da3eca01068861c65c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual rclcpp::executor::Executor::~Executor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a34509baf643c9a7f88bf0b7f4a983955"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rclcpp::executor::Executor::spin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do work periodically as it becomes available to us. Blocking call, may block indefinitely. </p>

<p>Implemented in <a class="el" href="classrclcpp_1_1executors_1_1single__threaded__executor_1_1SingleThreadedExecutor.html#ada5310fcb80483c174d855ec5c5646ae">rclcpp::executors::single_threaded_executor::SingleThreadedExecutor</a>, and <a class="el" href="classrclcpp_1_1executors_1_1multi__threaded__executor_1_1MultiThreadedExecutor.html#ac82b0d01f97121ed59fd6cea15c534d8">rclcpp::executors::multi_threaded_executor::MultiThreadedExecutor</a>.</p>

</div>
</div>
<a class="anchor" id="a363491ae55c619db310861a3ef4cc4b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rclcpp::executor::Executor::add_node </td>
          <td>(</td>
          <td class="paramtype">rclcpp::node_interfaces::NodeBaseInterface::SharedPtr&#160;</td>
          <td class="paramname"><em>node_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>notify</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a node to the executor. </p>
<p>An executor can have zero or more nodes which provide work during <code>spin</code> functions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_ptr</td><td>Shared pointer to the node to be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">notify</td><td>True to trigger the interrupt guard condition during this function. If the executor is blocked at the rmw layer while waiting for work and it is notified that a new node was added, it will wake up. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5919b4736199688fafb02497d01cad35"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rclcpp::executor::Executor::add_node </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1node_1_1Node.html">rclcpp::node::Node</a> &gt;&#160;</td>
          <td class="paramname"><em>node_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>notify</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function which takes Node and forwards NodeBaseInterface. </p>

</div>
</div>
<a class="anchor" id="a96ebe21baa5b23f22d7b7055e4bd1186"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rclcpp::executor::Executor::remove_node </td>
          <td>(</td>
          <td class="paramtype">rclcpp::node_interfaces::NodeBaseInterface::SharedPtr&#160;</td>
          <td class="paramname"><em>node_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>notify</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a node from the executor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_ptr</td><td>Shared pointer to the node to remove. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">notify</td><td>True to trigger the interrupt guard condition and wake up the executor. This is useful if the last node was removed from the executor while the executor was blocked waiting for work in another thread, because otherwise the executor would never be notified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a71fff5dac6072c86426217639439131e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rclcpp::executor::Executor::remove_node </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1node_1_1Node.html">rclcpp::node::Node</a> &gt;&#160;</td>
          <td class="paramname"><em>node_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>notify</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function which takes Node and forwards NodeBaseInterface. </p>

</div>
</div>
<a class="anchor" id="a990f711caca8274d3e61cde959a9ec22"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = std::milli&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::executor::Executor::spin_node_once </td>
          <td>(</td>
          <td class="paramtype">rclcpp::node_interfaces::NodeBaseInterface::SharedPtr&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::duration&lt; int64_t, T &gt;&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::chrono::duration&lt;int64_t,&#160;T&gt;(-1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a node to executor, execute the next available unit of work, and remove the node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Shared pointer to the node to add. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>How long to wait for work to become available. Negative values cause spin_node_once to block indefinitely (the default behavior). A timeout of 0 causes this function to be non-blocking. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa5f0e4ef31e588789fb4c17ca9001d7e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeT  = rclcpp::node::Node, typename T  = std::milli&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::executor::Executor::spin_node_once </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; NodeT &gt;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::duration&lt; int64_t, T &gt;&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::chrono::duration&lt;int64_t,&#160;T&gt;(-1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function which takes Node and forwards NodeBaseInterface. </p>

</div>
</div>
<a class="anchor" id="adeccc9ee445a31f7facafbd81e650a37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::executor::Executor::spin_node_some </td>
          <td>(</td>
          <td class="paramtype">rclcpp::node_interfaces::NodeBaseInterface::SharedPtr&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a node, complete all immediately available work, and remove the node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Shared pointer to the node to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7e531df5734e1772083dfa9db4ca33d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::executor::Executor::spin_node_some </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classrclcpp_1_1node_1_1Node.html">rclcpp::node::Node</a> &gt;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function which takes Node and forwards NodeBaseInterface. </p>

</div>
</div>
<a class="anchor" id="abeb1fa384d7113d2e93659e4583c5fd1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rclcpp::executor::Executor::spin_some </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Complete all available queued work without blocking. </p>
<p>This function can be overridden. The default implementation is suitable for a single-threaded model of execution. Adding subscriptions, timers, services, etc. with blocking callbacks will cause this function to block (which may have unintended consequences). </p>

</div>
</div>
<a class="anchor" id="aba2ce2abdc1a1be9cad2e481830feb9f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rclcpp::executor::Executor::spin_once </td>
          <td>(</td>
          <td class="paramtype">std::chrono::nanoseconds&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::chrono::nanoseconds(-1)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aef288c02dcbf229d34a4ee91313b0ef9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResponseT , typename TimeT  = std::milli&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacerclcpp_1_1executor.html#a3114c96743c4a4d68e739a7e43642347">FutureReturnCode</a> rclcpp::executor::Executor::spin_until_future_complete </td>
          <td>(</td>
          <td class="paramtype">std::shared_future&lt; ResponseT &gt; &amp;&#160;</td>
          <td class="paramname"><em>future</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::duration&lt; int64_t, TimeT &gt;&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::chrono::duration&lt;int64_t,&#160;TimeT&gt;(-1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Spin (blocking) until the future is complete, it times out waiting, or rclcpp is interrupted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">future</td><td>The future to wait on. If SUCCESS, the future is safe to access after this function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Optional timeout parameter, which gets passed to <a class="el" href="classrclcpp_1_1executor_1_1Executor.html#a990f711caca8274d3e61cde959a9ec22" title="Add a node to executor, execute the next available unit of work, and remove the node. ">Executor::spin_node_once</a>. <code>-1</code> is block forever, <code>0</code> is non-blocking. If the time spent inside the blocking loop exceeds this timeout, return a TIMEOUT return code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return code, one of <code>SUCCESS</code>, <code>INTERRUPTED</code>, or <code>TIMEOUT</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a7496f96836709f72f9a7cd69b5966c2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::executor::Executor::cancel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel any running spin* function, causing it to return. </p>

</div>
</div>
<a class="anchor" id="a7ba6022ab18de85e549b9c2c51e81cbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::executor::Executor::set_memory_strategy </td>
          <td>(</td>
          <td class="paramtype">memory_strategy::MemoryStrategy::SharedPtr&#160;</td>
          <td class="paramname"><em>memory_strategy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Support dynamic switching of the memory strategy. </p>
<p>Switching the memory strategy while the executor is spinning in another threading could have unintended consequences. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="namespacerclcpp_1_1memory__strategy.html">memory_strategy</a></td><td>Shared pointer to the memory strategy to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0e1ac67fe0e978dadf53ce67033f0f10"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::executor::Executor::spin_node_once_nanoseconds </td>
          <td>(</td>
          <td class="paramtype">rclcpp::node_interfaces::NodeBaseInterface::SharedPtr&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::nanoseconds&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6e5a869e141b1fc694853f232d8dd207"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::executor::Executor::execute_any_executable </td>
          <td>(</td>
          <td class="paramtype">AnyExecutable::SharedPtr&#160;</td>
          <td class="paramname"><em>any_exec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the next available executable and do the work associated with it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">any_exec</td><td>Union structure that can hold any executable type (timer, subscription, service, client). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac5197c0a602bcb4474a524fc0d3cc1f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rclcpp::executor::Executor::execute_subscription </td>
          <td>(</td>
          <td class="paramtype">rclcpp::subscription::SubscriptionBase::SharedPtr&#160;</td>
          <td class="paramname"><em>subscription</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abe61e1d94c19f504e7fb21780a953825"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rclcpp::executor::Executor::execute_intra_process_subscription </td>
          <td>(</td>
          <td class="paramtype">rclcpp::subscription::SubscriptionBase::SharedPtr&#160;</td>
          <td class="paramname"><em>subscription</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a580d5718812abd68063e365d1d903899"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rclcpp::executor::Executor::execute_timer </td>
          <td>(</td>
          <td class="paramtype">rclcpp::timer::TimerBase::SharedPtr&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9345a99ccc00887bc54394724f983400"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rclcpp::executor::Executor::execute_service </td>
          <td>(</td>
          <td class="paramtype">rclcpp::service::ServiceBase::SharedPtr&#160;</td>
          <td class="paramname"><em>service</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac6947d3209d3850ce810b80cddac0098"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rclcpp::executor::Executor::execute_client </td>
          <td>(</td>
          <td class="paramtype">rclcpp::client::ClientBase::SharedPtr&#160;</td>
          <td class="paramname"><em>client</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adcb8a7dddb0badb4a1ba995a48fa19f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::executor::Executor::wait_for_work </td>
          <td>(</td>
          <td class="paramtype">std::chrono::nanoseconds&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::chrono::nanoseconds(-1)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab397cc465da65a5fd58a3e5e044938b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rclcpp::node_interfaces::NodeBaseInterface::SharedPtr rclcpp::executor::Executor::get_node_by_group </td>
          <td>(</td>
          <td class="paramtype">rclcpp::callback_group::CallbackGroup::SharedPtr&#160;</td>
          <td class="paramname"><em>group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0f5815fb9bd5dea48fdc7c2480be556c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rclcpp::callback_group::CallbackGroup::SharedPtr rclcpp::executor::Executor::get_group_by_timer </td>
          <td>(</td>
          <td class="paramtype">rclcpp::timer::TimerBase::SharedPtr&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1987e10bc8bd4859c4b730a64b0ccd3c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rclcpp::executor::Executor::get_next_timer </td>
          <td>(</td>
          <td class="paramtype">AnyExecutable::SharedPtr&#160;</td>
          <td class="paramname"><em>any_exec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab7650a6160ff5ec592b2a89d60d84076"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AnyExecutable::SharedPtr rclcpp::executor::Executor::get_next_ready_executable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad5948a7f6f9818c4610898d752e0da3c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AnyExecutable::SharedPtr rclcpp::executor::Executor::get_next_executable </td>
          <td>(</td>
          <td class="paramtype">std::chrono::nanoseconds&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::chrono::nanoseconds(-1)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a5e0e8e417745489419845b01d062c199"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic_bool rclcpp::executor::Executor::spinning</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Spinning state, used to prevent multi threaded calls to spin and to cancel blocking spins. </p>

</div>
</div>
<a class="anchor" id="a7d4b4abaada22c32a6a891c255b07785"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rcl_guard_condition_t rclcpp::executor::Executor::interrupt_guard_condition_ = rcl_get_zero_initialized_guard_condition()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Guard condition for signaling the rmw layer to wake up for special events. </p>

</div>
</div>
<a class="anchor" id="a75dddd896cbfb268f8cd95e0143b3f45"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rcl_wait_set_t rclcpp::executor::Executor::waitset_ = rcl_get_zero_initialized_wait_set()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waitset for managing entities that the rmw layer waits on. </p>

</div>
</div>
<a class="anchor" id="a5ebeafb12ab052ce2675b260ca231751"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">memory_strategy::MemoryStrategy::SharedPtr rclcpp::executor::Executor::memory_strategy_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The memory strategy: an interface for handling user-defined memory allocation strategies. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/rclcpp/<a class="el" href="executor_8hpp_source.html">executor.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
