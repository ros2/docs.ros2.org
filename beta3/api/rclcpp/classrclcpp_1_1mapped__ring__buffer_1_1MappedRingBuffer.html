<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rclcpp: rclcpp::mapped_ring_buffer::MappedRingBuffer&lt; T, Alloc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rclcpp
   &#160;<span id="projectnumber">master</span>
   </div>
   <div id="projectbrief">C++ ROS Client Library API</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacerclcpp.html">rclcpp</a></li><li class="navelem"><a class="el" href="namespacerclcpp_1_1mapped__ring__buffer.html">mapped_ring_buffer</a></li><li class="navelem"><a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html">MappedRingBuffer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rclcpp::mapped_ring_buffer::MappedRingBuffer&lt; T, Alloc &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Ring buffer container of unique_ptr's of T, which can be accessed by a key.  
 <a href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mapped__ring__buffer_8hpp_source.html">mapped_ring_buffer.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for rclcpp::mapped_ring_buffer::MappedRingBuffer&lt; T, Alloc &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.png" usemap="#rclcpp::mapped_5Fring_5Fbuffer::MappedRingBuffer_3C_20T_2C_20Alloc_20_3E_map" alt=""/>
  <map id="rclcpp::mapped_5Fring_5Fbuffer::MappedRingBuffer_3C_20T_2C_20Alloc_20_3E_map" name="rclcpp::mapped_5Fring_5Fbuffer::MappedRingBuffer_3C_20T_2C_20Alloc_20_3E_map">
<area href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBufferBase.html" alt="rclcpp::mapped_ring_buffer::MappedRingBufferBase" shape="rect" coords="0,0,349,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8025658f213836eb8980e8cfc5279c36"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#a8025658f213836eb8980e8cfc5279c36">ElemAllocTraits</a> = <a class="el" href="namespacerclcpp_1_1allocator.html#a89c84a2945dc1cea1d6dfd4fa72a9dcd">allocator::AllocRebind</a>&lt; T, Alloc &gt;</td></tr>
<tr class="separator:a8025658f213836eb8980e8cfc5279c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10db6b24f0fe51e5cf28d739b49097c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#ae10db6b24f0fe51e5cf28d739b49097c">ElemAlloc</a> = typename ElemAllocTraits::allocator_type</td></tr>
<tr class="separator:ae10db6b24f0fe51e5cf28d739b49097c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b6b98ba3a3046b3a39dff98bab7d97"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#a21b6b98ba3a3046b3a39dff98bab7d97">ElemDeleter</a> = <a class="el" href="namespacerclcpp_1_1allocator.html#a885f50f2cbbab914f65ef687a0edd61b">allocator::Deleter</a>&lt; <a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#ae10db6b24f0fe51e5cf28d739b49097c">ElemAlloc</a>, T &gt;</td></tr>
<tr class="separator:a21b6b98ba3a3046b3a39dff98bab7d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada14be27bb3a40e30bdeb12a01c6abdb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#ada14be27bb3a40e30bdeb12a01c6abdb">ElemUniquePtr</a> = <a class="elRef" doxygen="/home/dhood/ros2_beta3/doxygen_tag_files/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; T, <a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#a21b6b98ba3a3046b3a39dff98bab7d97">ElemDeleter</a> &gt;</td></tr>
<tr class="separator:ada14be27bb3a40e30bdeb12a01c6abdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2736f1b2c51b6f0acbd8d2b9e39e9037"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#a2736f1b2c51b6f0acbd8d2b9e39e9037">MappedRingBuffer</a> (size_t size, <a class="elRef" doxygen="/home/dhood/ros2_beta3/doxygen_tag_files/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; Alloc &gt; allocator=nullptr)</td></tr>
<tr class="memdesc:a2736f1b2c51b6f0acbd8d2b9e39e9037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a2736f1b2c51b6f0acbd8d2b9e39e9037">More...</a><br /></td></tr>
<tr class="separator:a2736f1b2c51b6f0acbd8d2b9e39e9037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d85597642e946e8aa8d339eac6089c"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#a49d85597642e946e8aa8d339eac6089c">~MappedRingBuffer</a> ()</td></tr>
<tr class="separator:a49d85597642e946e8aa8d339eac6089c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb47fc0a40038c7832b516a8ae59d0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#a6bb47fc0a40038c7832b516a8ae59d0b">get_copy_at_key</a> (uint64_t key, <a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#ada14be27bb3a40e30bdeb12a01c6abdb">ElemUniquePtr</a> &amp;value)</td></tr>
<tr class="memdesc:a6bb47fc0a40038c7832b516a8ae59d0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the value stored in the ring buffer at the given key.  <a href="#a6bb47fc0a40038c7832b516a8ae59d0b">More...</a><br /></td></tr>
<tr class="separator:a6bb47fc0a40038c7832b516a8ae59d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ab459629a933cd08a1f1d81b6b418b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#a86ab459629a933cd08a1f1d81b6b418b">get_ownership_at_key</a> (uint64_t key, <a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#ada14be27bb3a40e30bdeb12a01c6abdb">ElemUniquePtr</a> &amp;value)</td></tr>
<tr class="memdesc:a86ab459629a933cd08a1f1d81b6b418b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return ownership of the value stored in the ring buffer, leaving a copy.  <a href="#a86ab459629a933cd08a1f1d81b6b418b">More...</a><br /></td></tr>
<tr class="separator:a86ab459629a933cd08a1f1d81b6b418b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07827798af14a55118b5d9684136ae97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#a07827798af14a55118b5d9684136ae97">pop_at_key</a> (uint64_t key, <a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#ada14be27bb3a40e30bdeb12a01c6abdb">ElemUniquePtr</a> &amp;value)</td></tr>
<tr class="memdesc:a07827798af14a55118b5d9684136ae97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return ownership of the value stored in the ring buffer at the given key.  <a href="#a07827798af14a55118b5d9684136ae97">More...</a><br /></td></tr>
<tr class="separator:a07827798af14a55118b5d9684136ae97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93556cf3050494dc5f789da623ae105e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#a93556cf3050494dc5f789da623ae105e">push_and_replace</a> (uint64_t key, <a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#ada14be27bb3a40e30bdeb12a01c6abdb">ElemUniquePtr</a> &amp;value)</td></tr>
<tr class="memdesc:a93556cf3050494dc5f789da623ae105e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a key-value pair, displacing an existing pair if necessary.  <a href="#a93556cf3050494dc5f789da623ae105e">More...</a><br /></td></tr>
<tr class="separator:a93556cf3050494dc5f789da623ae105e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711e7624eb18dbef2c99870621efe092"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#a711e7624eb18dbef2c99870621efe092">push_and_replace</a> (uint64_t key, <a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#ada14be27bb3a40e30bdeb12a01c6abdb">ElemUniquePtr</a> &amp;&amp;value)</td></tr>
<tr class="separator:a711e7624eb18dbef2c99870621efe092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b417e8bfaa257f9d357d0a7a854f58"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#a10b417e8bfaa257f9d357d0a7a854f58">has_key</a> (uint64_t key)</td></tr>
<tr class="memdesc:a10b417e8bfaa257f9d357d0a7a854f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the key is found in the ring buffer, otherwise false.  <a href="#a10b417e8bfaa257f9d357d0a7a854f58">More...</a><br /></td></tr>
<tr class="separator:a10b417e8bfaa257f9d357d0a7a854f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename Alloc = std::allocator&lt;void&gt;&gt;<br />
class rclcpp::mapped_ring_buffer::MappedRingBuffer&lt; T, Alloc &gt;</h3>

<p>Ring buffer container of unique_ptr's of T, which can be accessed by a key. </p>
<p>T must be a CopyConstructable and CopyAssignable. This class can be used in a container by using the base class <a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBufferBase.html">MappedRingBufferBase</a>. This class must have a positive, non-zero size. This class cannot be resized nor can it reserve additional space after construction. This class is not CopyConstructable nor CopyAssignable.</p>
<p>The key's are not guaranteed to be unique because push_and_replace does not check for colliding keys. It is up to the user to only use unique keys. A side effect of this is that when get_copy_at_key or pop_at_key are called, they return the first encountered instance of the key. But iteration does not begin with the ring buffer's head, and therefore there is no guarantee on which value is returned if a key is used multiple times. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a8025658f213836eb8980e8cfc5279c36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8025658f213836eb8980e8cfc5279c36">&#9670;&nbsp;</a></span>ElemAllocTraits</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html">rclcpp::mapped_ring_buffer::MappedRingBuffer</a>&lt; T, Alloc &gt;::<a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#a8025658f213836eb8980e8cfc5279c36">ElemAllocTraits</a> =  <a class="el" href="namespacerclcpp_1_1allocator.html#a89c84a2945dc1cea1d6dfd4fa72a9dcd">allocator::AllocRebind</a>&lt;T, Alloc&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae10db6b24f0fe51e5cf28d739b49097c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae10db6b24f0fe51e5cf28d739b49097c">&#9670;&nbsp;</a></span>ElemAlloc</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html">rclcpp::mapped_ring_buffer::MappedRingBuffer</a>&lt; T, Alloc &gt;::<a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#ae10db6b24f0fe51e5cf28d739b49097c">ElemAlloc</a> =  typename ElemAllocTraits::allocator_type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a21b6b98ba3a3046b3a39dff98bab7d97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21b6b98ba3a3046b3a39dff98bab7d97">&#9670;&nbsp;</a></span>ElemDeleter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html">rclcpp::mapped_ring_buffer::MappedRingBuffer</a>&lt; T, Alloc &gt;::<a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#a21b6b98ba3a3046b3a39dff98bab7d97">ElemDeleter</a> =  <a class="el" href="namespacerclcpp_1_1allocator.html#a885f50f2cbbab914f65ef687a0edd61b">allocator::Deleter</a>&lt;<a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#ae10db6b24f0fe51e5cf28d739b49097c">ElemAlloc</a>, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ada14be27bb3a40e30bdeb12a01c6abdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada14be27bb3a40e30bdeb12a01c6abdb">&#9670;&nbsp;</a></span>ElemUniquePtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html">rclcpp::mapped_ring_buffer::MappedRingBuffer</a>&lt; T, Alloc &gt;::<a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#ada14be27bb3a40e30bdeb12a01c6abdb">ElemUniquePtr</a> =  <a class="elRef" doxygen="/home/dhood/ros2_beta3/doxygen_tag_files/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt;T, <a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#a21b6b98ba3a3046b3a39dff98bab7d97">ElemDeleter</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2736f1b2c51b6f0acbd8d2b9e39e9037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2736f1b2c51b6f0acbd8d2b9e39e9037">&#9670;&nbsp;</a></span>MappedRingBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html">rclcpp::mapped_ring_buffer::MappedRingBuffer</a>&lt; T, Alloc &gt;::<a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html">MappedRingBuffer</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="/home/dhood/ros2_beta3/doxygen_tag_files/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; Alloc &gt;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>The constructor will allocate memory while reserving space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>size of the ring buffer; must be positive and non-zero. </td></tr>
    <tr><td class="paramname">allocator</td><td>optional custom allocator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49d85597642e946e8aa8d339eac6089c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49d85597642e946e8aa8d339eac6089c">&#9670;&nbsp;</a></span>~MappedRingBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html">rclcpp::mapped_ring_buffer::MappedRingBuffer</a>&lt; T, Alloc &gt;::~<a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html">MappedRingBuffer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6bb47fc0a40038c7832b516a8ae59d0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bb47fc0a40038c7832b516a8ae59d0b">&#9670;&nbsp;</a></span>get_copy_at_key()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html">rclcpp::mapped_ring_buffer::MappedRingBuffer</a>&lt; T, Alloc &gt;::get_copy_at_key </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#ada14be27bb3a40e30bdeb12a01c6abdb">ElemUniquePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a copy of the value stored in the ring buffer at the given key. </p>
<p>The key is matched if an element in the ring buffer has a matching key. This method will allocate in order to return a copy.</p>
<p>The key is not guaranteed to be unique, see the class docs for more.</p>
<p>The contents of value before the method is called are discarded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key associated with the stored value </td></tr>
    <tr><td class="paramname">value</td><td>if the key is found, the value is stored in this parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86ab459629a933cd08a1f1d81b6b418b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86ab459629a933cd08a1f1d81b6b418b">&#9670;&nbsp;</a></span>get_ownership_at_key()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html">rclcpp::mapped_ring_buffer::MappedRingBuffer</a>&lt; T, Alloc &gt;::get_ownership_at_key </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#ada14be27bb3a40e30bdeb12a01c6abdb">ElemUniquePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return ownership of the value stored in the ring buffer, leaving a copy. </p>
<p>The key is matched if an element in the ring bufer has a matching key. This method will allocate in order to store a copy.</p>
<p>The key is not guaranteed to be unique, see the class docs for more.</p>
<p>The ownership of the currently stored object is returned, but a copy is made and stored in its place. This means that multiple calls to this function for a particular element will result in returning the copied and stored object not the original. This also means that later calls to pop_at_key will not return the originally stored object, since it was returned by the first call to this method.</p>
<p>The contents of value before the method is called are discarded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key associated with the stored value </td></tr>
    <tr><td class="paramname">value</td><td>if the key is found, the value is stored in this parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07827798af14a55118b5d9684136ae97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07827798af14a55118b5d9684136ae97">&#9670;&nbsp;</a></span>pop_at_key()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html">rclcpp::mapped_ring_buffer::MappedRingBuffer</a>&lt; T, Alloc &gt;::pop_at_key </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#ada14be27bb3a40e30bdeb12a01c6abdb">ElemUniquePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return ownership of the value stored in the ring buffer at the given key. </p>
<p>The key is matched if an element in the ring buffer has a matching key.</p>
<p>The key is not guaranteed to be unique, see the class docs for more.</p>
<p>The contents of value before the method is called are discarded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key associated with the stored value </td></tr>
    <tr><td class="paramname">value</td><td>if the key is found, the value is stored in this parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93556cf3050494dc5f789da623ae105e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93556cf3050494dc5f789da623ae105e">&#9670;&nbsp;</a></span>push_and_replace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html">rclcpp::mapped_ring_buffer::MappedRingBuffer</a>&lt; T, Alloc &gt;::push_and_replace </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#ada14be27bb3a40e30bdeb12a01c6abdb">ElemUniquePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a key-value pair, displacing an existing pair if necessary. </p>
<p>The key's uniqueness is not checked on insertion. It is up to the user to ensure the key is unique. This method should not allocate memory.</p>
<p>After insertion, if a pair was replaced, then value will contain ownership of that displaced value. Otherwise it will be a nullptr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key associated with the value to be stored </td></tr>
    <tr><td class="paramname">value</td><td>the value to store, and optionally the value displaced </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a711e7624eb18dbef2c99870621efe092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a711e7624eb18dbef2c99870621efe092">&#9670;&nbsp;</a></span>push_and_replace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html">rclcpp::mapped_ring_buffer::MappedRingBuffer</a>&lt; T, Alloc &gt;::push_and_replace </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#ada14be27bb3a40e30bdeb12a01c6abdb">ElemUniquePtr</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a10b417e8bfaa257f9d357d0a7a854f58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b417e8bfaa257f9d357d0a7a854f58">&#9670;&nbsp;</a></span>has_key()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html">rclcpp::mapped_ring_buffer::MappedRingBuffer</a>&lt; T, Alloc &gt;::has_key </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the key is found in the ring buffer, otherwise false. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/rclcpp/<a class="el" href="mapped__ring__buffer_8hpp_source.html">mapped_ring_buffer.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
