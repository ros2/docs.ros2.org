<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rosidl_runtime_cpp: rosidl_runtime_cpp::BoundedVector&lt; Tp, UpperBound, Alloc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rosidl_runtime_cpp
   &#160;<span id="projectnumber">master</span>
   </div>
   <div id="projectbrief">Generate the rosidl interfaces in C++.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacerosidl__runtime__cpp.html">rosidl_runtime_cpp</a></li><li class="navelem"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classrosidl__runtime__cpp_1_1BoundedVector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rosidl_runtime_cpp::BoundedVector&lt; Tp, UpperBound, Alloc &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A container based on <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> but with an upper bound.  
 <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="bounded__vector_8hpp_source.html">bounded_vector.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for rosidl_runtime_cpp::BoundedVector&lt; Tp, UpperBound, Alloc &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classrosidl__runtime__cpp_1_1BoundedVector__inherit__graph.png" border="0" usemap="#rosidl__runtime__cpp_1_1BoundedVector_3_01Tp_00_01UpperBound_00_01Alloc_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="rosidl__runtime__cpp_1_1BoundedVector_3_01Tp_00_01UpperBound_00_01Alloc_01_4_inherit__map" id="rosidl__runtime__cpp_1_1BoundedVector_3_01Tp_00_01UpperBound_00_01Alloc_01_4_inherit__map">
<area shape="rect" title="A container based on std::vector but with an upper bound." alt="" coords="5,95,169,151"/>
<area shape="rect" href="http://en.cppreference.com/w/cpp/container/vector.html" title=" " alt="" coords="12,5,163,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for rosidl_runtime_cpp::BoundedVector&lt; Tp, UpperBound, Alloc &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classrosidl__runtime__cpp_1_1BoundedVector__coll__graph.png" border="0" usemap="#rosidl__runtime__cpp_1_1BoundedVector_3_01Tp_00_01UpperBound_00_01Alloc_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="rosidl__runtime__cpp_1_1BoundedVector_3_01Tp_00_01UpperBound_00_01Alloc_01_4_coll__map" id="rosidl__runtime__cpp_1_1BoundedVector_3_01Tp_00_01UpperBound_00_01Alloc_01_4_coll__map">
<area shape="rect" title="A container based on std::vector but with an upper bound." alt="" coords="5,95,169,151"/>
<area shape="rect" href="http://en.cppreference.com/w/cpp/container/vector.html" title=" " alt="" coords="12,5,163,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab9331f3a51bd09e65260df33e5ac66ed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#ab9331f3a51bd09e65260df33e5ac66ed">BoundedVector</a> () noexcept(<a class="elRef" href="http://en.cppreference.com/w/cpp/types/is_default_constructible.html">std::is_nothrow_default_constructible</a>&lt; Alloc &gt;::value)</td></tr>
<tr class="memdesc:ab9331f3a51bd09e65260df33e5ac66ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a BoundedVector with no elements.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#ab9331f3a51bd09e65260df33e5ac66ed">More...</a><br /></td></tr>
<tr class="separator:ab9331f3a51bd09e65260df33e5ac66ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac46c7faa8553c3555f6d5969cda9ac31"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#ac46c7faa8553c3555f6d5969cda9ac31">BoundedVector</a> (const typename Base::allocator_type &amp;a) noexcept</td></tr>
<tr class="memdesc:ac46c7faa8553c3555f6d5969cda9ac31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a BoundedVector with no elements.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#ac46c7faa8553c3555f6d5969cda9ac31">More...</a><br /></td></tr>
<tr class="separator:ac46c7faa8553c3555f6d5969cda9ac31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a814c4f85ccde1ded2b383871a6d9e569"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a814c4f85ccde1ded2b383871a6d9e569">BoundedVector</a> (typename Base::size_type n, const typename Base::allocator_type &amp;a=allocator_type())</td></tr>
<tr class="memdesc:a814c4f85ccde1ded2b383871a6d9e569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a BoundedVector with default constructed elements.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#a814c4f85ccde1ded2b383871a6d9e569">More...</a><br /></td></tr>
<tr class="separator:a814c4f85ccde1ded2b383871a6d9e569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47cc7c7f0643e2abd1a2b178e0dddf2a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a47cc7c7f0643e2abd1a2b178e0dddf2a">BoundedVector</a> (typename Base::size_type n, const typename Base::value_type &amp;value, const typename Base::allocator_type &amp;a=allocator_type())</td></tr>
<tr class="memdesc:a47cc7c7f0643e2abd1a2b178e0dddf2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a BoundedVector with copies of an exemplar element.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#a47cc7c7f0643e2abd1a2b178e0dddf2a">More...</a><br /></td></tr>
<tr class="separator:a47cc7c7f0643e2abd1a2b178e0dddf2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3745ed2d6ff42c46fa8dcc1424678636"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a3745ed2d6ff42c46fa8dcc1424678636">BoundedVector</a> (const <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> &amp;x)</td></tr>
<tr class="memdesc:a3745ed2d6ff42c46fa8dcc1424678636"><td class="mdescLeft">&#160;</td><td class="mdescRight">BoundedVector copy constructor.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#a3745ed2d6ff42c46fa8dcc1424678636">More...</a><br /></td></tr>
<tr class="separator:a3745ed2d6ff42c46fa8dcc1424678636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa248f6ddcc0b71f3c61f6acb0e151f69"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#aa248f6ddcc0b71f3c61f6acb0e151f69">BoundedVector</a> (<a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> &amp;&amp;x) noexcept</td></tr>
<tr class="memdesc:aa248f6ddcc0b71f3c61f6acb0e151f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">BoundedVector move constructor.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#aa248f6ddcc0b71f3c61f6acb0e151f69">More...</a><br /></td></tr>
<tr class="separator:aa248f6ddcc0b71f3c61f6acb0e151f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821180c052b75b62bcd3931198b4502a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a821180c052b75b62bcd3931198b4502a">BoundedVector</a> (const <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> &amp;x, const typename Base::allocator_type &amp;a)</td></tr>
<tr class="memdesc:a821180c052b75b62bcd3931198b4502a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor with alternative allocator.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#a821180c052b75b62bcd3931198b4502a">More...</a><br /></td></tr>
<tr class="separator:a821180c052b75b62bcd3931198b4502a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40c76d58bb20ab0bb1d8bf1c40e046e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#ac40c76d58bb20ab0bb1d8bf1c40e046e">BoundedVector</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; typename Base::value_type &gt; l, const typename Base::allocator_type &amp;a=typename Base::allocator_type())</td></tr>
<tr class="memdesc:ac40c76d58bb20ab0bb1d8bf1c40e046e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a BoundedVector from an initializer list.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#ac40c76d58bb20ab0bb1d8bf1c40e046e">More...</a><br /></td></tr>
<tr class="separator:ac40c76d58bb20ab0bb1d8bf1c40e046e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320adb7d045a8cae901d4f05ac4862ca"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a320adb7d045a8cae901d4f05ac4862ca"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a320adb7d045a8cae901d4f05ac4862ca">BoundedVector</a> (InputIterator first, InputIterator last, const typename Base::allocator_type &amp;a=allocator_type())</td></tr>
<tr class="memdesc:a320adb7d045a8cae901d4f05ac4862ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a BoundedVector from a range.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#a320adb7d045a8cae901d4f05ac4862ca">More...</a><br /></td></tr>
<tr class="separator:a320adb7d045a8cae901d4f05ac4862ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde94b3030db56169ab7e30b4c4d149d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#abde94b3030db56169ab7e30b4c4d149d">~BoundedVector</a> () noexcept</td></tr>
<tr class="memdesc:abde94b3030db56169ab7e30b4c4d149d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The dtor only erases the elements.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#abde94b3030db56169ab7e30b4c4d149d">More...</a><br /></td></tr>
<tr class="separator:abde94b3030db56169ab7e30b4c4d149d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a255e00543a40a11f61cf459358734bc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a255e00543a40a11f61cf459358734bc8">operator=</a> (const <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> &amp;x)</td></tr>
<tr class="memdesc:a255e00543a40a11f61cf459358734bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">BoundedVector assignment operator.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#a255e00543a40a11f61cf459358734bc8">More...</a><br /></td></tr>
<tr class="separator:a255e00543a40a11f61cf459358734bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d6b23a19dc2302b3b76b256e0c42a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a88d6b23a19dc2302b3b76b256e0c42a4">operator=</a> (<a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> &amp;&amp;x)</td></tr>
<tr class="memdesc:a88d6b23a19dc2302b3b76b256e0c42a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">BoundedVector move assignment operator  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#a88d6b23a19dc2302b3b76b256e0c42a4">More...</a><br /></td></tr>
<tr class="separator:a88d6b23a19dc2302b3b76b256e0c42a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addfdc3e482ed1b50e73d61f01ba710b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#addfdc3e482ed1b50e73d61f01ba710b6">operator=</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; typename Base::value_type &gt; l)</td></tr>
<tr class="memdesc:addfdc3e482ed1b50e73d61f01ba710b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">BoundedVector list assignment operator.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#addfdc3e482ed1b50e73d61f01ba710b6">More...</a><br /></td></tr>
<tr class="separator:addfdc3e482ed1b50e73d61f01ba710b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90df04bd71b7d3315980f55f279a5c8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a90df04bd71b7d3315980f55f279a5c8b">assign</a> (typename Base::size_type n, const typename Base::value_type &amp;val)</td></tr>
<tr class="memdesc:a90df04bd71b7d3315980f55f279a5c8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a given value to a BoundedVector.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#a90df04bd71b7d3315980f55f279a5c8b">More...</a><br /></td></tr>
<tr class="separator:a90df04bd71b7d3315980f55f279a5c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba239d395f69b550d7ce28410a2def8a"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:aba239d395f69b550d7ce28410a2def8a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#aba239d395f69b550d7ce28410a2def8a">assign</a> (InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:aba239d395f69b550d7ce28410a2def8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a range to a BoundedVector.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#aba239d395f69b550d7ce28410a2def8a">More...</a><br /></td></tr>
<tr class="separator:aba239d395f69b550d7ce28410a2def8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0816830c758d50e06b48c5aab2108c5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a0816830c758d50e06b48c5aab2108c5e">assign</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; typename Base::value_type &gt; l)</td></tr>
<tr class="memdesc:a0816830c758d50e06b48c5aab2108c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign an initializer list to a BoundedVector.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#a0816830c758d50e06b48c5aab2108c5e">More...</a><br /></td></tr>
<tr class="separator:a0816830c758d50e06b48c5aab2108c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ed8d079ecef6368678e83a4437f5ba"><td class="memItemLeft" align="right" valign="top">Base::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a81ed8d079ecef6368678e83a4437f5ba">max_size</a> () const noexcept</td></tr>
<tr class="separator:a81ed8d079ecef6368678e83a4437f5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6718877fe7bffcc0a65e70e57bc384e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#ae6718877fe7bffcc0a65e70e57bc384e">resize</a> (typename Base::size_type new_size)</td></tr>
<tr class="memdesc:ae6718877fe7bffcc0a65e70e57bc384e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the BoundedVector to the specified number of elements.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#ae6718877fe7bffcc0a65e70e57bc384e">More...</a><br /></td></tr>
<tr class="separator:ae6718877fe7bffcc0a65e70e57bc384e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a36f74c0fce03f66a6c4a800dc9097d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a7a36f74c0fce03f66a6c4a800dc9097d">resize</a> (typename Base::size_type new_size, const typename Base::value_type &amp;x)</td></tr>
<tr class="memdesc:a7a36f74c0fce03f66a6c4a800dc9097d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the BoundedVector to the specified number of elements.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#a7a36f74c0fce03f66a6c4a800dc9097d">More...</a><br /></td></tr>
<tr class="separator:a7a36f74c0fce03f66a6c4a800dc9097d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac591d75572f317b53ecade24aa5f450b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#ac591d75572f317b53ecade24aa5f450b">reserve</a> (typename Base::size_type n)</td></tr>
<tr class="memdesc:ac591d75572f317b53ecade24aa5f450b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to preallocate enough memory for specified number of elements.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#ac591d75572f317b53ecade24aa5f450b">More...</a><br /></td></tr>
<tr class="separator:ac591d75572f317b53ecade24aa5f450b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a82f8b9e002fd30b29a92f99f55ecd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; !std::is_same&lt; T, Tp &gt;::value &amp;&amp;!std::is_same&lt; T, bool &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a93a82f8b9e002fd30b29a92f99f55ecd"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a93a82f8b9e002fd30b29a92f99f55ecd">data</a> () noexcept</td></tr>
<tr class="memdesc:a93a82f8b9e002fd30b29a92f99f55ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer such that [<a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a93a82f8b9e002fd30b29a92f99f55ecd" title="Return a pointer such that [data(), data() + size()) is a valid range.">data()</a>, <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a93a82f8b9e002fd30b29a92f99f55ecd" title="Return a pointer such that [data(), data() + size()) is a valid range.">data()</a> + <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/size.html">size()</a>) is a valid range.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#a93a82f8b9e002fd30b29a92f99f55ecd">More...</a><br /></td></tr>
<tr class="separator:a93a82f8b9e002fd30b29a92f99f55ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ad6ef46c33901cc441db1ce0b86bc4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; !std::is_same&lt; T, Tp &gt;::value &amp;&amp;!std::is_same&lt; T, bool &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a81ad6ef46c33901cc441db1ce0b86bc4"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a81ad6ef46c33901cc441db1ce0b86bc4">data</a> () const noexcept</td></tr>
<tr class="separator:a81ad6ef46c33901cc441db1ce0b86bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9801c4c6b3e809e5bd9c54f8d8b56185"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a9801c4c6b3e809e5bd9c54f8d8b56185">push_back</a> (const typename Base::value_type &amp;x)</td></tr>
<tr class="memdesc:a9801c4c6b3e809e5bd9c54f8d8b56185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add data to the end of the BoundedVector.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#a9801c4c6b3e809e5bd9c54f8d8b56185">More...</a><br /></td></tr>
<tr class="separator:a9801c4c6b3e809e5bd9c54f8d8b56185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a55ffd624a11dca10fde90193749f9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a2a55ffd624a11dca10fde90193749f9e">push_back</a> (typename Base::value_type &amp;&amp;x)</td></tr>
<tr class="separator:a2a55ffd624a11dca10fde90193749f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88ce04fa7c848836bf8d5a7d979f9b8"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:aa88ce04fa7c848836bf8d5a7d979f9b8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#aa88ce04fa7c848836bf8d5a7d979f9b8">emplace_back</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aa88ce04fa7c848836bf8d5a7d979f9b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add data to the end of the BoundedVector.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#aa88ce04fa7c848836bf8d5a7d979f9b8">More...</a><br /></td></tr>
<tr class="separator:aa88ce04fa7c848836bf8d5a7d979f9b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16ff880be951cc5a2395a45c10dc51d"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:aa16ff880be951cc5a2395a45c10dc51d"><td class="memTemplItemLeft" align="right" valign="top">Base::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#aa16ff880be951cc5a2395a45c10dc51d">emplace</a> (typename Base::const_iterator position, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aa16ff880be951cc5a2395a45c10dc51d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an object in BoundedVector before specified iterator.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#aa16ff880be951cc5a2395a45c10dc51d">More...</a><br /></td></tr>
<tr class="separator:aa16ff880be951cc5a2395a45c10dc51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d1c8ea10d9be6b50e4b7e597b5d627"><td class="memItemLeft" align="right" valign="top">Base::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#af7d1c8ea10d9be6b50e4b7e597b5d627">insert</a> (typename Base::const_iterator position, const typename Base::value_type &amp;x)</td></tr>
<tr class="memdesc:af7d1c8ea10d9be6b50e4b7e597b5d627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert given value into BoundedVector before specified iterator.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#af7d1c8ea10d9be6b50e4b7e597b5d627">More...</a><br /></td></tr>
<tr class="separator:af7d1c8ea10d9be6b50e4b7e597b5d627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a0f842de1dd010e5e860b56f29d2ac"><td class="memItemLeft" align="right" valign="top">Base::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a49a0f842de1dd010e5e860b56f29d2ac">insert</a> (typename Base::const_iterator position, typename Base::value_type &amp;&amp;x)</td></tr>
<tr class="memdesc:a49a0f842de1dd010e5e860b56f29d2ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert given rvalue into BoundedVector before specified iterator.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#a49a0f842de1dd010e5e860b56f29d2ac">More...</a><br /></td></tr>
<tr class="separator:a49a0f842de1dd010e5e860b56f29d2ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9484ba049354985b2a8e4aeb77a305"><td class="memItemLeft" align="right" valign="top">Base::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a4d9484ba049354985b2a8e4aeb77a305">insert</a> (typename Base::const_iterator position, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; typename Base::value_type &gt; l)</td></tr>
<tr class="memdesc:a4d9484ba049354985b2a8e4aeb77a305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an initializer_list into the BoundedVector.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#a4d9484ba049354985b2a8e4aeb77a305">More...</a><br /></td></tr>
<tr class="separator:a4d9484ba049354985b2a8e4aeb77a305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f1b2b5be86e0a18e1f7309a3df99a43"><td class="memItemLeft" align="right" valign="top">Base::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a3f1b2b5be86e0a18e1f7309a3df99a43">insert</a> (typename Base::const_iterator position, typename Base::size_type n, const typename Base::value_type &amp;x)</td></tr>
<tr class="memdesc:a3f1b2b5be86e0a18e1f7309a3df99a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a number of copies of given data into the BoundedVector.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#a3f1b2b5be86e0a18e1f7309a3df99a43">More...</a><br /></td></tr>
<tr class="separator:a3f1b2b5be86e0a18e1f7309a3df99a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ebb96c6f3d1ff71bff4df9a63650fc"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:ae7ebb96c6f3d1ff71bff4df9a63650fc"><td class="memTemplItemLeft" align="right" valign="top">Base::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#ae7ebb96c6f3d1ff71bff4df9a63650fc">insert</a> (typename Base::const_iterator position, InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:ae7ebb96c6f3d1ff71bff4df9a63650fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a range into the BoundedVector.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#ae7ebb96c6f3d1ff71bff4df9a63650fc">More...</a><br /></td></tr>
<tr class="separator:ae7ebb96c6f3d1ff71bff4df9a63650fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e8f2d175c16626b8f7b53181869e84"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a14e8f2d175c16626b8f7b53181869e84">begin</a> (T... args)</td></tr>
<tr class="separator:a14e8f2d175c16626b8f7b53181869e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6bd27b48c751a5e89e0668ac3eb02a"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#afb6bd27b48c751a5e89e0668ac3eb02a">end</a> (T... args)</td></tr>
<tr class="separator:afb6bd27b48c751a5e89e0668ac3eb02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a194ec1357ce59783e86b83dce1717"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a04a194ec1357ce59783e86b83dce1717">rbegin</a> (T... args)</td></tr>
<tr class="separator:a04a194ec1357ce59783e86b83dce1717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c96e076b274af1b741fd9ce2ac5c195"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a9c96e076b274af1b741fd9ce2ac5c195">rend</a> (T... args)</td></tr>
<tr class="separator:a9c96e076b274af1b741fd9ce2ac5c195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba5d999ac2845947393d26283187ee7"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a4ba5d999ac2845947393d26283187ee7">cbegin</a> (T... args)</td></tr>
<tr class="separator:a4ba5d999ac2845947393d26283187ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd0e50811872f1a65c0d76e658b0ff3"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a8dd0e50811872f1a65c0d76e658b0ff3">cend</a> (T... args)</td></tr>
<tr class="separator:a8dd0e50811872f1a65c0d76e658b0ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0553a9ef1ca894fa3d85a8f04f1dbacd"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a0553a9ef1ca894fa3d85a8f04f1dbacd">crbegin</a> (T... args)</td></tr>
<tr class="separator:a0553a9ef1ca894fa3d85a8f04f1dbacd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064c6d2fbdd17b27574046a752c30c4d"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a064c6d2fbdd17b27574046a752c30c4d">crend</a> (T... args)</td></tr>
<tr class="separator:a064c6d2fbdd17b27574046a752c30c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0e76f395798203bbb2782c93d7af4a"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a3b0e76f395798203bbb2782c93d7af4a">size</a> (T... args)</td></tr>
<tr class="separator:a3b0e76f395798203bbb2782c93d7af4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3261d5c883854f7e35855fe0d1fe8eaf"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a3261d5c883854f7e35855fe0d1fe8eaf">shrink_to_fit</a> (T... args)</td></tr>
<tr class="separator:a3261d5c883854f7e35855fe0d1fe8eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c29aac53279ec8610284fade71d6a2"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a14c29aac53279ec8610284fade71d6a2">capacity</a> (T... args)</td></tr>
<tr class="separator:a14c29aac53279ec8610284fade71d6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cafefaa48c3676ac9c161fa9ea61834"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a4cafefaa48c3676ac9c161fa9ea61834">empty</a> (T... args)</td></tr>
<tr class="separator:a4cafefaa48c3676ac9c161fa9ea61834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9bfdae866d3ba31330c9c72221a32c9"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#ad9bfdae866d3ba31330c9c72221a32c9">at</a> (T... args)</td></tr>
<tr class="separator:ad9bfdae866d3ba31330c9c72221a32c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662637ebbbe02726abf936c26463a491"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a662637ebbbe02726abf936c26463a491">front</a> (T... args)</td></tr>
<tr class="separator:a662637ebbbe02726abf936c26463a491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fedc1c55807d10373890b936506f198"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a4fedc1c55807d10373890b936506f198">back</a> (T... args)</td></tr>
<tr class="separator:a4fedc1c55807d10373890b936506f198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a0b5b15a24542d3385f0a7f9a83dd7"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a48a0b5b15a24542d3385f0a7f9a83dd7">erase</a> (T... args)</td></tr>
<tr class="separator:a48a0b5b15a24542d3385f0a7f9a83dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2a11c70415cbc183f87c231ef07d49"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a9e2a11c70415cbc183f87c231ef07d49">pop_back</a> (T... args)</td></tr>
<tr class="separator:a9e2a11c70415cbc183f87c231ef07d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c8492c8d8d7a436f6592799046963c"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#ad4c8492c8d8d7a436f6592799046963c">clear</a> (T... args)</td></tr>
<tr class="separator:ad4c8492c8d8d7a436f6592799046963c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a649f6923ec9080a3d0016abe5baf9df5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a649f6923ec9080a3d0016abe5baf9df5">operator==</a> (const <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> &amp;x, const <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> &amp;y)</td></tr>
<tr class="memdesc:a649f6923ec9080a3d0016abe5baf9df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector equality comparison.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#a649f6923ec9080a3d0016abe5baf9df5">More...</a><br /></td></tr>
<tr class="separator:a649f6923ec9080a3d0016abe5baf9df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbdee2c4656ad1ff54057a63467cbd87"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#adbdee2c4656ad1ff54057a63467cbd87">operator&lt;</a> (const <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> &amp;x, const <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> &amp;y)</td></tr>
<tr class="memdesc:adbdee2c4656ad1ff54057a63467cbd87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector ordering relation.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#adbdee2c4656ad1ff54057a63467cbd87">More...</a><br /></td></tr>
<tr class="separator:adbdee2c4656ad1ff54057a63467cbd87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299f6f3743ea949c83fd20659c2718f4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a299f6f3743ea949c83fd20659c2718f4">operator!=</a> (const <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> &amp;x, const <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> &amp;y)</td></tr>
<tr class="memdesc:a299f6f3743ea949c83fd20659c2718f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Based on operator==.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#a299f6f3743ea949c83fd20659c2718f4">More...</a><br /></td></tr>
<tr class="separator:a299f6f3743ea949c83fd20659c2718f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f54f5c55192476765922ef71d099561"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a5f54f5c55192476765922ef71d099561">operator&gt;</a> (const <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> &amp;x, const <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> &amp;y)</td></tr>
<tr class="memdesc:a5f54f5c55192476765922ef71d099561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Based on operator&lt;.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#a5f54f5c55192476765922ef71d099561">More...</a><br /></td></tr>
<tr class="separator:a5f54f5c55192476765922ef71d099561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf9b1f3013aeda8987a99f7413bb392"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a0bf9b1f3013aeda8987a99f7413bb392">operator&lt;=</a> (const <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> &amp;x, const <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> &amp;y)</td></tr>
<tr class="memdesc:a0bf9b1f3013aeda8987a99f7413bb392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Based on operator&lt;.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#a0bf9b1f3013aeda8987a99f7413bb392">More...</a><br /></td></tr>
<tr class="separator:a0bf9b1f3013aeda8987a99f7413bb392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac969b2a9afe3dc7a2a72972d65ff85ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#ac969b2a9afe3dc7a2a72972d65ff85ad">operator&gt;=</a> (const <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> &amp;x, const <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> &amp;y)</td></tr>
<tr class="memdesc:ac969b2a9afe3dc7a2a72972d65ff85ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Based on operator&lt;.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#ac969b2a9afe3dc7a2a72972d65ff85ad">More...</a><br /></td></tr>
<tr class="separator:ac969b2a9afe3dc7a2a72972d65ff85ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_vector"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_vector')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el"  href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt; Tp, std::allocator&lt; Tp &gt; &gt;</a></td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/push_back.html">push_back</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/rbegin.html">crbegin</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/erase.html">erase</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/data.html">data</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/insert.html">insert</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/pop_back.html">pop_back</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/shrink_to_fit.html">shrink_to_fit</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/back.html">back</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/end.html">end</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/resize.html">resize</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/emplace_back.html">emplace_back</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/size.html">size</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/begin.html">cbegin</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/front.html">front</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/~vector.html">~vector</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/rbegin.html">rbegin</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/rend.html">crend</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/assign.html">assign</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/operator=.html">operator=</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/vector.html">vector</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/reserve.html">reserve</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/capacity.html">capacity</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/empty.html">empty</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/end.html">cend</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/swap.html">swap</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/max_size.html">max_size</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/rend.html">rend</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/get_allocator.html">get_allocator</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/clear.html">clear</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/at.html">at</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/emplace.html">emplace</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/operator_at.html">operator[]</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/begin.html">begin</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Tp, std::size_t UpperBound, typename Alloc = std::allocator&lt;Tp&gt;&gt;<br />
class rosidl_runtime_cpp::BoundedVector&lt; Tp, UpperBound, Alloc &gt;</h3>

<p>A container based on <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> but with an upper bound. </p>
<p>Meets the same requirements as <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Tp</td><td>Type of element </td></tr>
    <tr><td class="paramname">UpperBound</td><td>The upper bound for the number of elements </td></tr>
    <tr><td class="paramname">Alloc</td><td>Allocator type, defaults to std::allocator&lt;Tp&gt; </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab9331f3a51bd09e65260df33e5ac66ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9331f3a51bd09e65260df33e5ac66ed">&#9670;&nbsp;</a></span>BoundedVector() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt;::<a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a BoundedVector with no elements. </p>

</div>
</div>
<a id="ac46c7faa8553c3555f6d5969cda9ac31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac46c7faa8553c3555f6d5969cda9ac31">&#9670;&nbsp;</a></span>BoundedVector() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt;::<a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> </td>
          <td>(</td>
          <td class="paramtype">const typename Base::allocator_type &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a BoundedVector with no elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>An allocator object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a814c4f85ccde1ded2b383871a6d9e569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a814c4f85ccde1ded2b383871a6d9e569">&#9670;&nbsp;</a></span>BoundedVector() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt;::<a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> </td>
          <td>(</td>
          <td class="paramtype">typename Base::size_type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Base::allocator_type &amp;&#160;</td>
          <td class="paramname"><em>a</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a BoundedVector with default constructed elements. </p>
<p>This constructor fills the BoundedVector with <em>n</em> default constructed elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of elements to initially create </td></tr>
    <tr><td class="paramname">a</td><td>An allocator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47cc7c7f0643e2abd1a2b178e0dddf2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47cc7c7f0643e2abd1a2b178e0dddf2a">&#9670;&nbsp;</a></span>BoundedVector() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt;::<a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> </td>
          <td>(</td>
          <td class="paramtype">typename Base::size_type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Base::value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Base::allocator_type &amp;&#160;</td>
          <td class="paramname"><em>a</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a BoundedVector with copies of an exemplar element. </p>
<p>This constructor fills the BoundedVector with <em>n</em> copies of <em>value</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of elements to initially create </td></tr>
    <tr><td class="paramname">value</td><td>An element to copy </td></tr>
    <tr><td class="paramname">a</td><td>An allocator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3745ed2d6ff42c46fa8dcc1424678636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3745ed2d6ff42c46fa8dcc1424678636">&#9670;&nbsp;</a></span>BoundedVector() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt;::<a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>BoundedVector copy constructor. </p>
<p>The newly-created BoundedVector uses a copy of the allocation object used by <em>x</em>. All the elements of <em>x</em> are copied, but any extra memory in <em>x</em> (for fast expansion) will not be copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A BoundedVector of identical element and allocator types </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa248f6ddcc0b71f3c61f6acb0e151f69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa248f6ddcc0b71f3c61f6acb0e151f69">&#9670;&nbsp;</a></span>BoundedVector() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt;::<a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>BoundedVector move constructor. </p>
<p>The newly-created BoundedVector contains the exact contents of <em>x</em>. The contents of <em>x</em> are a valid, but unspecified BoundedVector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A BoundedVector of identical element and allocator types </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a821180c052b75b62bcd3931198b4502a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a821180c052b75b62bcd3931198b4502a">&#9670;&nbsp;</a></span>BoundedVector() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt;::<a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Base::allocator_type &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor with alternative allocator. </p>

</div>
</div>
<a id="ac40c76d58bb20ab0bb1d8bf1c40e046e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac40c76d58bb20ab0bb1d8bf1c40e046e">&#9670;&nbsp;</a></span>BoundedVector() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt;::<a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; typename Base::value_type &gt;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Base::allocator_type &amp;&#160;</td>
          <td class="paramname"><em>a</em> = <code>typename&#160;Base::allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build a BoundedVector from an initializer list. </p>
<p>Create a BoundedVector consisting of copies of the elements in the initializer_list <em>l</em>.</p>
<p>This will call the element type's copy constructor N times (where N is <em>l.size()</em>) and do no memory reallocation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>An initializer_list </td></tr>
    <tr><td class="paramname">a</td><td>An allocator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a320adb7d045a8cae901d4f05ac4862ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a320adb7d045a8cae901d4f05ac4862ca">&#9670;&nbsp;</a></span>BoundedVector() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt;::<a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Base::allocator_type &amp;&#160;</td>
          <td class="paramname"><em>a</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build a BoundedVector from a range. </p>
<p>Create a BoundedVector consisting of copies of the elements from [first,last).</p>
<p>If the iterators are forward, bidirectional, or random-access, then this will call the elements' copy constructor N times (where N is distance(first,last)) and do no memory reallocation. But if only input iterators are used, then this will do at most 2N calls to the copy constructor, and logN memory reallocations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An input iterator </td></tr>
    <tr><td class="paramname">last</td><td>An input iterator </td></tr>
    <tr><td class="paramname">a</td><td>An allocator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abde94b3030db56169ab7e30b4c4d149d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abde94b3030db56169ab7e30b4c4d149d">&#9670;&nbsp;</a></span>~BoundedVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt;::~<a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The dtor only erases the elements. </p>
<p>Note that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a255e00543a40a11f61cf459358734bc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a255e00543a40a11f61cf459358734bc8">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a>&amp; <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>BoundedVector assignment operator. </p>
<p>All the elements of <em>x</em> are copied, but any extra memory in <em>x</em> (for fast expansion) will not be copied. Unlike the copy constructor, the allocator object is not copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A BoundedVector of identical element and allocator types </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88d6b23a19dc2302b3b76b256e0c42a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88d6b23a19dc2302b3b76b256e0c42a4">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a>&amp; <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>BoundedVector move assignment operator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A BoundedVector of identical element and allocator types. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="addfdc3e482ed1b50e73d61f01ba710b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addfdc3e482ed1b50e73d61f01ba710b6">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a>&amp; <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; typename Base::value_type &gt;&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>BoundedVector list assignment operator. </p>
<p>This function fills a BoundedVector with copies of the elements in the initializer list <em>l</em>.</p>
<p>Note that the assignment completely changes the BoundedVector and that the resulting BoundedVector's size is the same as the number of elements assigned. Old data may be lost.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>An initializer_list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90df04bd71b7d3315980f55f279a5c8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90df04bd71b7d3315980f55f279a5c8b">&#9670;&nbsp;</a></span>assign() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">typename Base::size_type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Base::value_type &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a given value to a BoundedVector. </p>
<p>This function fills a BoundedVector with <em>n</em> copies of the given value. Note that the assignment completely changes the BoundedVector and that the resulting BoundedVector's size is the same as the number of elements assigned. Old data may be lost.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of elements to be assigned </td></tr>
    <tr><td class="paramname">val</td><td>Value to be assigned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba239d395f69b550d7ce28410a2def8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba239d395f69b550d7ce28410a2def8a">&#9670;&nbsp;</a></span>assign() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a range to a BoundedVector. </p>
<p>This function fills a BoundedVector with copies of the elements in the range [first,last).</p>
<p>Note that the assignment completely changes the BoundedVector and that the resulting BoundedVector's size is the same as the number of elements assigned. Old data may be lost.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An input iterator </td></tr>
    <tr><td class="paramname">last</td><td>An input iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0816830c758d50e06b48c5aab2108c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0816830c758d50e06b48c5aab2108c5e">&#9670;&nbsp;</a></span>assign() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; typename Base::value_type &gt;&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign an initializer list to a BoundedVector. </p>
<p>This function fills a BoundedVector with copies of the elements in the initializer list <em>l</em>.</p>
<p>Note that the assignment completely changes the BoundedVector and that the resulting BoundedVector's size is the same as the number of elements assigned. Old data may be lost.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>An initializer_list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81ed8d079ecef6368678e83a4437f5ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81ed8d079ecef6368678e83a4437f5ba">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Base::size_type <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/size.html">size()</a> of the largest possible BoundedVector. <br  />
 </p>

</div>
</div>
<a id="ae6718877fe7bffcc0a65e70e57bc384e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6718877fe7bffcc0a65e70e57bc384e">&#9670;&nbsp;</a></span>resize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">typename Base::size_type&#160;</td>
          <td class="paramname"><em>new_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize the BoundedVector to the specified number of elements. </p>
<p>This function will resize the BoundedVector to the specified number of elements. If the number is smaller than the BoundedVector's current size the BoundedVector is truncated, otherwise default constructed elements are appended.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_size</td><td>Number of elements the BoundedVector should contain </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a36f74c0fce03f66a6c4a800dc9097d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a36f74c0fce03f66a6c4a800dc9097d">&#9670;&nbsp;</a></span>resize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">typename Base::size_type&#160;</td>
          <td class="paramname"><em>new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Base::value_type &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize the BoundedVector to the specified number of elements. </p>
<p>This function will resize the BoundedVector to the specified number of elements. If the number is smaller than the BoundedVector's current size the BoundedVector is truncated, otherwise the BoundedVector is extended and new elements are populated with given data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_size</td><td>Number of elements the BoundedVector should contain </td></tr>
    <tr><td class="paramname">x</td><td>Data with which new elements should be populated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac591d75572f317b53ecade24aa5f450b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac591d75572f317b53ecade24aa5f450b">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">typename Base::size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to preallocate enough memory for specified number of elements. </p>
<p>This function attempts to reserve enough memory for the BoundedVector to hold the specified number of elements. If the number requested is more than <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a81ed8d079ecef6368678e83a4437f5ba">max_size()</a>, length_error is thrown.</p>
<p>The advantage of this function is that if optimal code is a necessity and the user can determine the number of elements that will be required, the user can reserve the memory in advance, and thus prevent a possible reallocation of memory and copying of BoundedVector data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of elements required </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="elRef" href="http://en.cppreference.com/w/cpp/error/length_error.html">std::length_error</a></td><td>If <em>n</em> exceeds <code><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a81ed8d079ecef6368678e83a4437f5ba">max_size()</a></code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93a82f8b9e002fd30b29a92f99f55ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93a82f8b9e002fd30b29a92f99f55ecd">&#9670;&nbsp;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt; !std::is_same&lt; T, Tp &gt;::value &amp;&amp;!std::is_same&lt; T, bool &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer such that [<a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a93a82f8b9e002fd30b29a92f99f55ecd" title="Return a pointer such that [data(), data() + size()) is a valid range.">data()</a>, <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a93a82f8b9e002fd30b29a92f99f55ecd" title="Return a pointer such that [data(), data() + size()) is a valid range.">data()</a> + <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/size.html">size()</a>) is a valid range. </p>
<p>For a non-empty BoundedVector, <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a93a82f8b9e002fd30b29a92f99f55ecd" title="Return a pointer such that [data(), data() + size()) is a valid range.">data()</a> == &amp;<a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/front.html">front()</a>. </p>

</div>
</div>
<a id="a81ad6ef46c33901cc441db1ce0b86bc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81ad6ef46c33901cc441db1ce0b86bc4">&#9670;&nbsp;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt; !std::is_same&lt; T, Tp &gt;::value &amp;&amp;!std::is_same&lt; T, bool &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9801c4c6b3e809e5bd9c54f8d8b56185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9801c4c6b3e809e5bd9c54f8d8b56185">&#9670;&nbsp;</a></span>push_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const typename Base::value_type &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add data to the end of the BoundedVector. </p>
<p>This is a typical stack operation. The function creates an element at the end of the BoundedVector and assigns the given data to it. Due to the nature of a BoundedVector this operation can be done in constant time if the BoundedVector has preallocated space available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Data to be added </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a55ffd624a11dca10fde90193749f9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a55ffd624a11dca10fde90193749f9e">&#9670;&nbsp;</a></span>push_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">typename Base::value_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa88ce04fa7c848836bf8d5a7d979f9b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa88ce04fa7c848836bf8d5a7d979f9b8">&#9670;&nbsp;</a></span>emplace_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add data to the end of the BoundedVector. </p>
<p>This is a typical stack operation. The function creates an element at the end of the BoundedVector and assigns the given data to it. Due to the nature of a BoundedVector this operation can be done in constant time if the BoundedVector has preallocated space available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Arguments to be forwarded to the constructor of Tp </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa16ff880be951cc5a2395a45c10dc51d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16ff880be951cc5a2395a45c10dc51d">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Base::iterator <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">typename Base::const_iterator&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert an object in BoundedVector before specified iterator. </p>
<p>This function will insert an object of type T constructed with T(std::forward&lt;Args&gt;(args)...) before the specified location. Note that this kind of operation could be expensive for a BoundedVector and if it is frequently used the user should consider using <a class="elRef" href="http://en.cppreference.com/w/cpp/container/list.html">std::list</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>A const_iterator into the BoundedVector </td></tr>
    <tr><td class="paramname">args</td><td>Arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the inserted data </dd></dl>

</div>
</div>
<a id="af7d1c8ea10d9be6b50e4b7e597b5d627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7d1c8ea10d9be6b50e4b7e597b5d627">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Base::iterator <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">typename Base::const_iterator&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Base::value_type &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert given value into BoundedVector before specified iterator. </p>
<p>This function will insert a copy of the given value before the specified location. Note that this kind of operation could be expensive for a BoundedVector and if it is frequently used the user should consider using <a class="elRef" href="http://en.cppreference.com/w/cpp/container/list.html">std::list</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>A const_iterator into the BoundedVector </td></tr>
    <tr><td class="paramname">x</td><td>Data to be inserted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the inserted data </dd></dl>

</div>
</div>
<a id="a49a0f842de1dd010e5e860b56f29d2ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49a0f842de1dd010e5e860b56f29d2ac">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Base::iterator <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">typename Base::const_iterator&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Base::value_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert given rvalue into BoundedVector before specified iterator. </p>
<p>This function will insert a copy of the given rvalue before the specified location. Note that this kind of operation could be expensive for a BoundedVector and if it is frequently used the user should consider using <a class="elRef" href="http://en.cppreference.com/w/cpp/container/list.html">std::list</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>A const_iterator into the BoundedVector </td></tr>
    <tr><td class="paramname">x</td><td>Data to be inserted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the inserted data </dd></dl>

</div>
</div>
<a id="a4d9484ba049354985b2a8e4aeb77a305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d9484ba049354985b2a8e4aeb77a305">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Base::iterator <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">typename Base::const_iterator&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; typename Base::value_type &gt;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert an initializer_list into the BoundedVector. </p>
<p>This function will insert copies of the data in the initializer_list <em>l</em> into the BoundedVector before the location specified by <em>position</em>.</p>
<p>Note that this kind of operation could be expensive for a BoundedVector and if it is frequently used the user should consider using <a class="elRef" href="http://en.cppreference.com/w/cpp/container/list.html">std::list</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>An iterator into the BoundedVector </td></tr>
    <tr><td class="paramname">l</td><td>An initializer_list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f1b2b5be86e0a18e1f7309a3df99a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f1b2b5be86e0a18e1f7309a3df99a43">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Base::iterator <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">typename Base::const_iterator&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Base::size_type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Base::value_type &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a number of copies of given data into the BoundedVector. </p>
<p>This function will insert a specified number of copies of the given data before the location specified by <em>position</em>.</p>
<p>Note that this kind of operation could be expensive for a BoundedVector and if it is frequently used the user should consider using <a class="elRef" href="http://en.cppreference.com/w/cpp/container/list.html">std::list</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>A const_iterator into the BoundedVector </td></tr>
    <tr><td class="paramname">n</td><td>Number of elements to be inserted </td></tr>
    <tr><td class="paramname">x</td><td>Data to be inserted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the inserted data </dd></dl>

</div>
</div>
<a id="ae7ebb96c6f3d1ff71bff4df9a63650fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7ebb96c6f3d1ff71bff4df9a63650fc">&#9670;&nbsp;</a></span>insert() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Base::iterator <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">typename Base::const_iterator&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a range into the BoundedVector. </p>
<p>This function will insert copies of the data in the range [first,last) into the BoundedVector before the location specified by <em>pos</em>.</p>
<p>Note that this kind of operation could be expensive for a BoundedVector and if it is frequently used the user should consider using <a class="elRef" href="http://en.cppreference.com/w/cpp/container/list.html">std::list</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>A const_iterator into the BoundedVector </td></tr>
    <tr><td class="paramname">first</td><td>An input iterator </td></tr>
    <tr><td class="paramname">last</td><td>An input iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the inserted data </dd></dl>

</div>
</div>
<a id="a14e8f2d175c16626b8f7b53181869e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e8f2d175c16626b8f7b53181869e84">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T std::vector::begin</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afb6bd27b48c751a5e89e0668ac3eb02a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb6bd27b48c751a5e89e0668ac3eb02a">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T std::vector::end</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a04a194ec1357ce59783e86b83dce1717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04a194ec1357ce59783e86b83dce1717">&#9670;&nbsp;</a></span>rbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T std::vector::rbegin</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c96e076b274af1b741fd9ce2ac5c195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c96e076b274af1b741fd9ce2ac5c195">&#9670;&nbsp;</a></span>rend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T std::vector::rend</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ba5d999ac2845947393d26283187ee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ba5d999ac2845947393d26283187ee7">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T std::vector::cbegin</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8dd0e50811872f1a65c0d76e658b0ff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dd0e50811872f1a65c0d76e658b0ff3">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T std::vector::cend</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0553a9ef1ca894fa3d85a8f04f1dbacd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0553a9ef1ca894fa3d85a8f04f1dbacd">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T std::vector::crbegin</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a064c6d2fbdd17b27574046a752c30c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a064c6d2fbdd17b27574046a752c30c4d">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T std::vector::crend</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b0e76f395798203bbb2782c93d7af4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0e76f395798203bbb2782c93d7af4a">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T std::vector::size</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3261d5c883854f7e35855fe0d1fe8eaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3261d5c883854f7e35855fe0d1fe8eaf">&#9670;&nbsp;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T std::vector::shrink_to_fit</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a14c29aac53279ec8610284fade71d6a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14c29aac53279ec8610284fade71d6a2">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T std::vector::capacity</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4cafefaa48c3676ac9c161fa9ea61834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cafefaa48c3676ac9c161fa9ea61834">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T std::vector::empty</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad9bfdae866d3ba31330c9c72221a32c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9bfdae866d3ba31330c9c72221a32c9">&#9670;&nbsp;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T std::vector::at</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a662637ebbbe02726abf936c26463a491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a662637ebbbe02726abf936c26463a491">&#9670;&nbsp;</a></span>front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T std::vector::front</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4fedc1c55807d10373890b936506f198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fedc1c55807d10373890b936506f198">&#9670;&nbsp;</a></span>back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T std::vector::back</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a48a0b5b15a24542d3385f0a7f9a83dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a0b5b15a24542d3385f0a7f9a83dd7">&#9670;&nbsp;</a></span>erase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T std::vector::erase</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e2a11c70415cbc183f87c231ef07d49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e2a11c70415cbc183f87c231ef07d49">&#9670;&nbsp;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T std::vector::pop_back</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4c8492c8d8d7a436f6592799046963c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4c8492c8d8d7a436f6592799046963c">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T std::vector::clear</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a649f6923ec9080a3d0016abe5baf9df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a649f6923ec9080a3d0016abe5baf9df5">&#9670;&nbsp;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector equality comparison. </p>
<p>This is an equivalence relation. It is linear in the size of the vectors. Vectors are considered equivalent if their sizes are equal, and if corresponding elements compare equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A BoundedVector </td></tr>
    <tr><td class="paramname">y</td><td>A BoundedVector of the same type as <em>x</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the size and elements of the vectors are equal </dd></dl>

</div>
</div>
<a id="adbdee2c4656ad1ff54057a63467cbd87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbdee2c4656ad1ff54057a63467cbd87">&#9670;&nbsp;</a></span>operator&lt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector ordering relation. </p>
<p>This is a total ordering relation. It is linear in the size of the vectors. The elements must be comparable with <code>&lt;</code>.</p>
<p>See <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/lexicographical_compare.html">std::lexicographical_compare()</a> for how the determination is made.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A BoundedVector </td></tr>
    <tr><td class="paramname">y</td><td>A BoundedVector of the same type as <em>x</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>x</em> is lexicographically less than <em>y</em> </dd></dl>

</div>
</div>
<a id="a299f6f3743ea949c83fd20659c2718f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a299f6f3743ea949c83fd20659c2718f4">&#9670;&nbsp;</a></span>operator!=</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Based on operator==. </p>

</div>
</div>
<a id="a5f54f5c55192476765922ef71d099561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f54f5c55192476765922ef71d099561">&#9670;&nbsp;</a></span>operator&gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Based on operator&lt;. </p>

</div>
</div>
<a id="a0bf9b1f3013aeda8987a99f7413bb392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bf9b1f3013aeda8987a99f7413bb392">&#9670;&nbsp;</a></span>operator&lt;=</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Based on operator&lt;. </p>

</div>
</div>
<a id="ac969b2a9afe3dc7a2a72972d65ff85ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac969b2a9afe3dc7a2a72972d65ff85ad">&#9670;&nbsp;</a></span>operator&gt;=</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t UpperBound, typename Alloc  = std::allocator&lt;Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a>&lt; Tp, UpperBound, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Based on operator&lt;. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/rosidl_runtime_cpp/<a class="el" href="bounded__vector_8hpp_source.html">bounded_vector.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
