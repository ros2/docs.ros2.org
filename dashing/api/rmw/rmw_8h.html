<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rmw: include/rmw/rmw.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rmw
   &#160;<span id="projectnumber">master</span>
   </div>
   <div id="projectbrief">C API providing a middleware abstraction layer which is used to implement the rest of ROS.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_f1863b20b54cc3d25893e93314d6cb7b.html">rmw</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rmw.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &quot;<a class="elRef" doxygen="/home/jacob/ws/gendocs_ws/doxygen_tag_files/rcutils.tag:http://docs.ros2.org/dashing/api/rcutils/" href="http://docs.ros2.org/dashing/api/rcutils/types_8h.html">rcutils/types.h</a>&quot;</code><br />
<code>#include &quot;rosidl_generator_c/message_bounds_struct.h&quot;</code><br />
<code>#include &quot;rosidl_generator_c/message_type_support_struct.h&quot;</code><br />
<code>#include &quot;rosidl_generator_c/service_type_support_struct.h&quot;</code><br />
<code>#include &quot;<a class="el" href="init_8h_source.html">rmw/init.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="macros_8h_source.html">rmw/macros.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="qos__profiles_8h_source.html">rmw/qos_profiles.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="types_8h_source.html">rmw/types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="visibility__control_8h_source.html">rmw/visibility_control.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for rmw.h:</div>
<div class="dyncontent">
<div class="center"><img src="rmw_8h__incl.png" border="0" usemap="#include_2rmw_2rmw_8h" alt=""/></div>
<map name="include_2rmw_2rmw_8h" id="include_2rmw_2rmw_8h">
<area shape="rect" id="node5" doxygen="/home/jacob/ws/gendocs_ws/doxygen_tag_files/rcutils.tag:http://docs.ros2.org/dashing/api/rcutils/" href="http://docs.ros2.org/dashing/api/rcutils/types_8h.html" title="rcutils/types.h" alt="" coords="1813,408,1917,435"/>
<area shape="rect" id="node8" href="macros_8h.html" title="rcutils/macros.h" alt="" coords="773,654,888,681"/>
<area shape="rect" id="node11" href="visibility__control_8h.html" title="rcutils/visibility\l_control.h" alt="" coords="1055,647,1163,688"/>
<area shape="rect" id="node21" href="init_8h.html" title="rmw/init.h" alt="" coords="399,259,478,285"/>
<area shape="rect" id="node24" href="qos__profiles_8h.html" title="rmw/qos_profiles.h" alt="" coords="545,95,677,121"/>
<area shape="rect" id="node25" href="types_8h.html" title="rmw/types.h" alt="" coords="477,184,571,211"/>
<area shape="rect" id="node6" doxygen="/home/jacob/ws/gendocs_ws/doxygen_tag_files/rcutils.tag:http://docs.ros2.org/dashing/api/rcutils/" href="http://docs.ros2.org/dashing/api/rcutils/array__list_8h.html" title="rcutils/types/array\l_list.h" alt="" coords="1169,483,1295,524"/>
<area shape="rect" id="node10" doxygen="/home/jacob/ws/gendocs_ws/doxygen_tag_files/rcutils.tag:http://docs.ros2.org/dashing/api/rcutils/" href="http://docs.ros2.org/dashing/api/rcutils/rcutils__ret_8h.html" title="rcutils/types/rcutils\l_ret.h" alt="" coords="2163,647,2295,688"/>
<area shape="rect" id="node13" doxygen="/home/jacob/ws/gendocs_ws/doxygen_tag_files/rcutils.tag:http://docs.ros2.org/dashing/api/rcutils/" href="http://docs.ros2.org/dashing/api/rcutils/char__array_8h.html" title="rcutils/types/char\l_array.h" alt="" coords="1825,483,1948,524"/>
<area shape="rect" id="node14" doxygen="/home/jacob/ws/gendocs_ws/doxygen_tag_files/rcutils.tag:http://docs.ros2.org/dashing/api/rcutils/" href="http://docs.ros2.org/dashing/api/rcutils/hash__map_8h.html" title="rcutils/types/hash\l_map.h" alt="" coords="1991,483,2116,524"/>
<area shape="rect" id="node15" doxygen="/home/jacob/ws/gendocs_ws/doxygen_tag_files/rcutils.tag:http://docs.ros2.org/dashing/api/rcutils/" href="http://docs.ros2.org/dashing/api/rcutils/string__array_8h.html" title="rcutils/types/string\l_array.h" alt="" coords="2141,483,2270,524"/>
<area shape="rect" id="node16" doxygen="/home/jacob/ws/gendocs_ws/doxygen_tag_files/rcutils.tag:http://docs.ros2.org/dashing/api/rcutils/" href="http://docs.ros2.org/dashing/api/rcutils/string__map_8h.html" title="rcutils/types/string\l_map.h" alt="" coords="1015,483,1145,524"/>
<area shape="rect" id="node17" doxygen="/home/jacob/ws/gendocs_ws/doxygen_tag_files/rcutils.tag:http://docs.ros2.org/dashing/api/rcutils/" href="http://docs.ros2.org/dashing/api/rcutils/uint8__array_8h.html" title="rcutils/types/uint8\l_array.h" alt="" coords="1676,483,1801,524"/>
<area shape="rect" id="node7" doxygen="/home/jacob/ws/gendocs_ws/doxygen_tag_files/rcutils.tag:http://docs.ros2.org/dashing/api/rcutils/" href="http://docs.ros2.org/dashing/api/rcutils/allocator_8h.html" title="rcutils/allocator.h" alt="" coords="1590,572,1711,599"/>
<area shape="rect" id="node9" doxygen="/home/jacob/ws/gendocs_ws/doxygen_tag_files/rcutils.tag:http://docs.ros2.org/dashing/api/rcutils/" href="http://docs.ros2.org/dashing/api/rcutils/macros_8h.html" title="rcutils/macros.h" alt="" coords="1393,736,1508,763"/>
<area shape="rect" id="node12" doxygen="/home/jacob/ws/gendocs_ws/doxygen_tag_files/rcutils.tag:http://docs.ros2.org/dashing/api/rcutils/" href="http://docs.ros2.org/dashing/api/rcutils/visibility__control_8h.html" title="rcutils/visibility\l_control.h" alt="" coords="1847,647,1955,688"/>
<area shape="rect" id="node22" href="init__options_8h.html" title="rmw/init_options.h" alt="" coords="387,333,515,360"/>
<area shape="rect" id="node23" href="ret__types_8h.html" title="rmw/ret_types.h" alt="" coords="195,408,311,435"/>
<area shape="rect" id="node26" doxygen="/home/jacob/ws/gendocs_ws/doxygen_tag_files/rcutils.tag:http://docs.ros2.org/dashing/api/rcutils/" href="http://docs.ros2.org/dashing/api/rcutils/logging_8h.html" title="rcutils/logging.h" alt="" coords="1353,259,1466,285"/>
<area shape="rect" id="node31" href="serialized__message_8h.html" title="rmw/serialized_message.h" alt="" coords="1650,333,1827,360"/>
<area shape="rect" id="node27" href="error__handling_8h.html" title="rcutils/error_handling.h" alt="" coords="1473,333,1626,360"/>
<area shape="rect" id="node28" doxygen="/home/jacob/ws/gendocs_ws/doxygen_tag_files/rcutils.tag:http://docs.ros2.org/dashing/api/rcutils/" href="http://docs.ros2.org/dashing/api/rcutils/error__handling_8h.html" title="rcutils/error_handling.h" alt="" coords="1473,490,1626,517"/>
<area shape="rect" id="node30" doxygen="/home/jacob/ws/gendocs_ws/doxygen_tag_files/rcutils.tag:http://docs.ros2.org/dashing/api/rcutils/" href="http://docs.ros2.org/dashing/api/rcutils/time_8h.html" title="rcutils/time.h" alt="" coords="757,333,854,360"/>
<area shape="rect" id="node29" doxygen="/home/jacob/ws/gendocs_ws/doxygen_tag_files/rcutils.tag:http://docs.ros2.org/dashing/api/rcutils/" href="http://docs.ros2.org/dashing/api/rcutils/snprintf_8h.html" title="rcutils/snprintf.h" alt="" coords="1248,572,1363,599"/>
</map>
</div>
</div>
<p><a href="rmw_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6dfb314c4e5edf3c28b1fb1ffe992b0c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a6dfb314c4e5edf3c28b1fb1ffe992b0c">rmw_get_implementation_identifier</a> (void)</td></tr>
<tr class="separator:a6dfb314c4e5edf3c28b1fb1ffe992b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d6ce17ee198857a68292a73016f6a4"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a77d6ce17ee198857a68292a73016f6a4">rmw_get_serialization_format</a> (void)</td></tr>
<tr class="memdesc:a77d6ce17ee198857a68292a73016f6a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unique serialization format for this middleware.  <a href="#a77d6ce17ee198857a68292a73016f6a4">More...</a><br /></td></tr>
<tr class="separator:a77d6ce17ee198857a68292a73016f6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a535e951e3f996282be4044ac56cca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrmw__node__t.html">rmw_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a48a535e951e3f996282be4044ac56cca">rmw_create_node</a> (<a class="el" href="structrmw__context__t.html">rmw_context_t</a> *context, const char *name, const char *namespace_, size_t domain_id, const <a class="el" href="structrmw__node__security__options__t.html">rmw_node_security_options_t</a> *security_options)</td></tr>
<tr class="memdesc:a48a535e951e3f996282be4044ac56cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a node and return a handle to that node.  <a href="#a48a535e951e3f996282be4044ac56cca">More...</a><br /></td></tr>
<tr class="separator:a48a535e951e3f996282be4044ac56cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a2c3d9d51ebf753d6c531ab3b42253b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a0a2c3d9d51ebf753d6c531ab3b42253b">rmw_destroy_node</a> (<a class="el" href="structrmw__node__t.html">rmw_node_t</a> *node)</td></tr>
<tr class="memdesc:a0a2c3d9d51ebf753d6c531ab3b42253b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a given node handle, reclaim the resources, and deallocate the node handle.  <a href="#a0a2c3d9d51ebf753d6c531ab3b42253b">More...</a><br /></td></tr>
<tr class="separator:a0a2c3d9d51ebf753d6c531ab3b42253b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43ddabd6febd7b1ba0ea60a1a61498f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#ab43ddabd6febd7b1ba0ea60a1a61498f">rmw_node_assert_liveliness</a> (const <a class="el" href="structrmw__node__t.html">rmw_node_t</a> *node)</td></tr>
<tr class="memdesc:ab43ddabd6febd7b1ba0ea60a1a61498f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually assert that this node is alive (for RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_NODE)  <a href="#ab43ddabd6febd7b1ba0ea60a1a61498f">More...</a><br /></td></tr>
<tr class="separator:ab43ddabd6febd7b1ba0ea60a1a61498f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ca2bdd798c7b8f69da46d85e8d0fb9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structrmw__guard__condition__t.html">rmw_guard_condition_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a52ca2bdd798c7b8f69da46d85e8d0fb9">rmw_node_get_graph_guard_condition</a> (const <a class="el" href="structrmw__node__t.html">rmw_node_t</a> *node)</td></tr>
<tr class="memdesc:a52ca2bdd798c7b8f69da46d85e8d0fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a guard condition which is triggered when the ROS graph changes.  <a href="#a52ca2bdd798c7b8f69da46d85e8d0fb9">More...</a><br /></td></tr>
<tr class="separator:a52ca2bdd798c7b8f69da46d85e8d0fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c375040f79eb4dfa4f49305a4df6d19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a2c375040f79eb4dfa4f49305a4df6d19">rmw_init_publisher_allocation</a> (const rosidl_message_type_support_t *type_support, const rosidl_message_bounds_t *message_bounds, <a class="el" href="structrmw__publisher__allocation__t.html">rmw_publisher_allocation_t</a> *allocation)</td></tr>
<tr class="memdesc:a2c375040f79eb4dfa4f49305a4df6d19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a publisher allocation to be used with later publications.  <a href="#a2c375040f79eb4dfa4f49305a4df6d19">More...</a><br /></td></tr>
<tr class="separator:a2c375040f79eb4dfa4f49305a4df6d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a8ee7b6eef8d2b843484e77ead4992f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a1a8ee7b6eef8d2b843484e77ead4992f">rmw_fini_publisher_allocation</a> (<a class="el" href="structrmw__publisher__allocation__t.html">rmw_publisher_allocation_t</a> *allocation)</td></tr>
<tr class="memdesc:a1a8ee7b6eef8d2b843484e77ead4992f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a publisher allocation object.  <a href="#a1a8ee7b6eef8d2b843484e77ead4992f">More...</a><br /></td></tr>
<tr class="separator:a1a8ee7b6eef8d2b843484e77ead4992f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9f09ef0de72f3f18b401b1253e688a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrmw__publisher__t.html">rmw_publisher_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a1e9f09ef0de72f3f18b401b1253e688a">rmw_create_publisher</a> (const <a class="el" href="structrmw__node__t.html">rmw_node_t</a> *node, const rosidl_message_type_support_t *type_support, const char *topic_name, const <a class="el" href="structrmw__qos__profile__t.html">rmw_qos_profile_t</a> *qos_policies)</td></tr>
<tr class="separator:a1e9f09ef0de72f3f18b401b1253e688a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297f8ae702c5f1eb51c40928e735de74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a297f8ae702c5f1eb51c40928e735de74">rmw_destroy_publisher</a> (<a class="el" href="structrmw__node__t.html">rmw_node_t</a> *node, <a class="el" href="structrmw__publisher__t.html">rmw_publisher_t</a> *publisher)</td></tr>
<tr class="separator:a297f8ae702c5f1eb51c40928e735de74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab625a62ba2f32e3d3a7c7ca1f6e0dbd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#ab625a62ba2f32e3d3a7c7ca1f6e0dbd6">rmw_publish</a> (const <a class="el" href="structrmw__publisher__t.html">rmw_publisher_t</a> *publisher, const void *ros_message, <a class="el" href="structrmw__publisher__allocation__t.html">rmw_publisher_allocation_t</a> *allocation)</td></tr>
<tr class="memdesc:ab625a62ba2f32e3d3a7c7ca1f6e0dbd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish a given ros_message.  <a href="#ab625a62ba2f32e3d3a7c7ca1f6e0dbd6">More...</a><br /></td></tr>
<tr class="separator:ab625a62ba2f32e3d3a7c7ca1f6e0dbd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a046ba6f8ff184ebb01ab269b31a49f33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a046ba6f8ff184ebb01ab269b31a49f33">rmw_publisher_count_matched_subscriptions</a> (const <a class="el" href="structrmw__publisher__t.html">rmw_publisher_t</a> *publisher, size_t *subscription_count)</td></tr>
<tr class="memdesc:a046ba6f8ff184ebb01ab269b31a49f33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the number of matched subscriptions to a publisher.  <a href="#a046ba6f8ff184ebb01ab269b31a49f33">More...</a><br /></td></tr>
<tr class="separator:a046ba6f8ff184ebb01ab269b31a49f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a809010ecc3e404d8880382e2d4b35976"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a809010ecc3e404d8880382e2d4b35976">rmw_publisher_get_actual_qos</a> (const <a class="el" href="structrmw__publisher__t.html">rmw_publisher_t</a> *publisher, <a class="el" href="structrmw__qos__profile__t.html">rmw_qos_profile_t</a> *qos)</td></tr>
<tr class="memdesc:a809010ecc3e404d8880382e2d4b35976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the actual qos settings of the publisher.  <a href="#a809010ecc3e404d8880382e2d4b35976">More...</a><br /></td></tr>
<tr class="separator:a809010ecc3e404d8880382e2d4b35976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca69c33387b6185146c3f115ec2a24a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#abca69c33387b6185146c3f115ec2a24a">rmw_publish_serialized_message</a> (const <a class="el" href="structrmw__publisher__t.html">rmw_publisher_t</a> *publisher, const <a class="el" href="serialized__message_8h.html#ac1f977c2322bf36dc67f58235ee157ed">rmw_serialized_message_t</a> *serialized_message, <a class="el" href="structrmw__publisher__allocation__t.html">rmw_publisher_allocation_t</a> *allocation)</td></tr>
<tr class="memdesc:abca69c33387b6185146c3f115ec2a24a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish an already serialized message.  <a href="#abca69c33387b6185146c3f115ec2a24a">More...</a><br /></td></tr>
<tr class="separator:abca69c33387b6185146c3f115ec2a24a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6344964f669c3d092606625bd9b9f5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#ad6344964f669c3d092606625bd9b9f5e">rmw_get_serialized_message_size</a> (const rosidl_message_type_support_t *type_support, const rosidl_message_bounds_t *message_bounds, size_t *size)</td></tr>
<tr class="memdesc:ad6344964f669c3d092606625bd9b9f5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the size of a serialized message.  <a href="#ad6344964f669c3d092606625bd9b9f5e">More...</a><br /></td></tr>
<tr class="separator:ad6344964f669c3d092606625bd9b9f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4025992c2194103d3fe417d2373e95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a1e4025992c2194103d3fe417d2373e95">rmw_publisher_assert_liveliness</a> (const <a class="el" href="structrmw__publisher__t.html">rmw_publisher_t</a> *publisher)</td></tr>
<tr class="memdesc:a1e4025992c2194103d3fe417d2373e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually assert that this Publisher is alive (for RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC)  <a href="#a1e4025992c2194103d3fe417d2373e95">More...</a><br /></td></tr>
<tr class="separator:a1e4025992c2194103d3fe417d2373e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787c040bb59b0470ba51eee7e2bc04cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a787c040bb59b0470ba51eee7e2bc04cd">rmw_serialize</a> (const void *ros_message, const rosidl_message_type_support_t *type_support, <a class="el" href="serialized__message_8h.html#ac1f977c2322bf36dc67f58235ee157ed">rmw_serialized_message_t</a> *serialized_message)</td></tr>
<tr class="memdesc:a787c040bb59b0470ba51eee7e2bc04cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a ROS message into a rmw_serialized_message_t.  <a href="#a787c040bb59b0470ba51eee7e2bc04cd">More...</a><br /></td></tr>
<tr class="separator:a787c040bb59b0470ba51eee7e2bc04cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dee9c2eed962055a68febe9622f807c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a9dee9c2eed962055a68febe9622f807c">rmw_deserialize</a> (const <a class="el" href="serialized__message_8h.html#ac1f977c2322bf36dc67f58235ee157ed">rmw_serialized_message_t</a> *serialized_message, const rosidl_message_type_support_t *type_support, void *ros_message)</td></tr>
<tr class="memdesc:a9dee9c2eed962055a68febe9622f807c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize a ROS message.  <a href="#a9dee9c2eed962055a68febe9622f807c">More...</a><br /></td></tr>
<tr class="separator:a9dee9c2eed962055a68febe9622f807c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0cbb3c990ae56d2b442bd88ac782b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#aef0cbb3c990ae56d2b442bd88ac782b1">rmw_init_subscription_allocation</a> (const rosidl_message_type_support_t *type_support, const rosidl_message_bounds_t *message_bounds, <a class="el" href="structrmw__subscription__allocation__t.html">rmw_subscription_allocation_t</a> *allocation)</td></tr>
<tr class="memdesc:aef0cbb3c990ae56d2b442bd88ac782b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a subscription allocation to be used with later <code>take</code>s.  <a href="#aef0cbb3c990ae56d2b442bd88ac782b1">More...</a><br /></td></tr>
<tr class="separator:aef0cbb3c990ae56d2b442bd88ac782b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e2408746a0e03bdaa290ef32780253"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a26e2408746a0e03bdaa290ef32780253">rmw_fini_subscription_allocation</a> (<a class="el" href="structrmw__subscription__allocation__t.html">rmw_subscription_allocation_t</a> *allocation)</td></tr>
<tr class="memdesc:a26e2408746a0e03bdaa290ef32780253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a publisher allocation object.  <a href="#a26e2408746a0e03bdaa290ef32780253">More...</a><br /></td></tr>
<tr class="separator:a26e2408746a0e03bdaa290ef32780253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fdd7d9de256254f4d020730baf40572"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrmw__subscription__t.html">rmw_subscription_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a1fdd7d9de256254f4d020730baf40572">rmw_create_subscription</a> (const <a class="el" href="structrmw__node__t.html">rmw_node_t</a> *node, const rosidl_message_type_support_t *type_support, const char *topic_name, const <a class="el" href="structrmw__qos__profile__t.html">rmw_qos_profile_t</a> *qos_policies, bool ignore_local_publications)</td></tr>
<tr class="separator:a1fdd7d9de256254f4d020730baf40572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606270f7d253dba6eb9c279061bd2b6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a606270f7d253dba6eb9c279061bd2b6c">rmw_destroy_subscription</a> (<a class="el" href="structrmw__node__t.html">rmw_node_t</a> *node, <a class="el" href="structrmw__subscription__t.html">rmw_subscription_t</a> *subscription)</td></tr>
<tr class="separator:a606270f7d253dba6eb9c279061bd2b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f83284d1a1a2de0cbbc270fab7e2254"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a7f83284d1a1a2de0cbbc270fab7e2254">rmw_subscription_count_matched_publishers</a> (const <a class="el" href="structrmw__subscription__t.html">rmw_subscription_t</a> *subscription, size_t *publisher_count)</td></tr>
<tr class="memdesc:a7f83284d1a1a2de0cbbc270fab7e2254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the number of matched publishers to a subscription.  <a href="#a7f83284d1a1a2de0cbbc270fab7e2254">More...</a><br /></td></tr>
<tr class="separator:a7f83284d1a1a2de0cbbc270fab7e2254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9bf29af7069593e2f8dfa2296710080"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#af9bf29af7069593e2f8dfa2296710080">rmw_take</a> (const <a class="el" href="structrmw__subscription__t.html">rmw_subscription_t</a> *subscription, void *ros_message, bool *taken, <a class="el" href="structrmw__subscription__allocation__t.html">rmw_subscription_allocation_t</a> *allocation)</td></tr>
<tr class="memdesc:af9bf29af7069593e2f8dfa2296710080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take an incoming message from a subscription.  <a href="#af9bf29af7069593e2f8dfa2296710080">More...</a><br /></td></tr>
<tr class="separator:af9bf29af7069593e2f8dfa2296710080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8498c763a02e0fe9203ab6c9dfba0408"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a8498c763a02e0fe9203ab6c9dfba0408">rmw_take_with_info</a> (const <a class="el" href="structrmw__subscription__t.html">rmw_subscription_t</a> *subscription, void *ros_message, bool *taken, <a class="el" href="structrmw__message__info__t.html">rmw_message_info_t</a> *message_info, <a class="el" href="structrmw__subscription__allocation__t.html">rmw_subscription_allocation_t</a> *allocation)</td></tr>
<tr class="memdesc:a8498c763a02e0fe9203ab6c9dfba0408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take an incoming message from a subscription with additional metadata.  <a href="#a8498c763a02e0fe9203ab6c9dfba0408">More...</a><br /></td></tr>
<tr class="separator:a8498c763a02e0fe9203ab6c9dfba0408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef04c20dab1bc6cdb27343046ccab28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a8ef04c20dab1bc6cdb27343046ccab28">rmw_take_serialized_message</a> (const <a class="el" href="structrmw__subscription__t.html">rmw_subscription_t</a> *subscription, <a class="el" href="serialized__message_8h.html#ac1f977c2322bf36dc67f58235ee157ed">rmw_serialized_message_t</a> *serialized_message, bool *taken, <a class="el" href="structrmw__subscription__allocation__t.html">rmw_subscription_allocation_t</a> *allocation)</td></tr>
<tr class="memdesc:a8ef04c20dab1bc6cdb27343046ccab28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a message without deserializing it.  <a href="#a8ef04c20dab1bc6cdb27343046ccab28">More...</a><br /></td></tr>
<tr class="separator:a8ef04c20dab1bc6cdb27343046ccab28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a8f380a5f4a5b37a48396a74a3238c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a16a8f380a5f4a5b37a48396a74a3238c">rmw_take_serialized_message_with_info</a> (const <a class="el" href="structrmw__subscription__t.html">rmw_subscription_t</a> *subscription, <a class="el" href="serialized__message_8h.html#ac1f977c2322bf36dc67f58235ee157ed">rmw_serialized_message_t</a> *serialized_message, bool *taken, <a class="el" href="structrmw__message__info__t.html">rmw_message_info_t</a> *message_info, <a class="el" href="structrmw__subscription__allocation__t.html">rmw_subscription_allocation_t</a> *allocation)</td></tr>
<tr class="memdesc:a16a8f380a5f4a5b37a48396a74a3238c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a message without deserializing it and with its additional message information.  <a href="#a16a8f380a5f4a5b37a48396a74a3238c">More...</a><br /></td></tr>
<tr class="separator:a16a8f380a5f4a5b37a48396a74a3238c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208bb1dd4d3c77cceee53ceba7abb8ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrmw__client__t.html">rmw_client_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a208bb1dd4d3c77cceee53ceba7abb8ac">rmw_create_client</a> (const <a class="el" href="structrmw__node__t.html">rmw_node_t</a> *node, const rosidl_service_type_support_t *type_support, const char *service_name, const <a class="el" href="structrmw__qos__profile__t.html">rmw_qos_profile_t</a> *qos_policies)</td></tr>
<tr class="separator:a208bb1dd4d3c77cceee53ceba7abb8ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da675215fe98e4bcb8cf202c3503c5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a3da675215fe98e4bcb8cf202c3503c5e">rmw_destroy_client</a> (<a class="el" href="structrmw__node__t.html">rmw_node_t</a> *node, <a class="el" href="structrmw__client__t.html">rmw_client_t</a> *client)</td></tr>
<tr class="separator:a3da675215fe98e4bcb8cf202c3503c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9abc3e631cd2529f168d04be97f1db29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a9abc3e631cd2529f168d04be97f1db29">rmw_send_request</a> (const <a class="el" href="structrmw__client__t.html">rmw_client_t</a> *client, const void *ros_request, int64_t *sequence_id)</td></tr>
<tr class="separator:a9abc3e631cd2529f168d04be97f1db29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3ffcbe0c717050a4c6d0ae15ef2ece"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a9f3ffcbe0c717050a4c6d0ae15ef2ece">rmw_take_response</a> (const <a class="el" href="structrmw__client__t.html">rmw_client_t</a> *client, <a class="el" href="structrmw__request__id__t.html">rmw_request_id_t</a> *request_header, void *ros_response, bool *taken)</td></tr>
<tr class="separator:a9f3ffcbe0c717050a4c6d0ae15ef2ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cac43fcb2ffd40268e472e94159ee5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrmw__service__t.html">rmw_service_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a41cac43fcb2ffd40268e472e94159ee5">rmw_create_service</a> (const <a class="el" href="structrmw__node__t.html">rmw_node_t</a> *node, const rosidl_service_type_support_t *type_support, const char *service_name, const <a class="el" href="structrmw__qos__profile__t.html">rmw_qos_profile_t</a> *qos_policies)</td></tr>
<tr class="separator:a41cac43fcb2ffd40268e472e94159ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39dc6f857dfa69a69bb198dc7fa96fed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a39dc6f857dfa69a69bb198dc7fa96fed">rmw_destroy_service</a> (<a class="el" href="structrmw__node__t.html">rmw_node_t</a> *node, <a class="el" href="structrmw__service__t.html">rmw_service_t</a> *service)</td></tr>
<tr class="separator:a39dc6f857dfa69a69bb198dc7fa96fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f11e3ac68ac7dda65a335e28bbad59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a04f11e3ac68ac7dda65a335e28bbad59">rmw_take_request</a> (const <a class="el" href="structrmw__service__t.html">rmw_service_t</a> *service, <a class="el" href="structrmw__request__id__t.html">rmw_request_id_t</a> *request_header, void *ros_request, bool *taken)</td></tr>
<tr class="separator:a04f11e3ac68ac7dda65a335e28bbad59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb55ba2b2a957cefb0a77b77ddc5afda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#abb55ba2b2a957cefb0a77b77ddc5afda">rmw_send_response</a> (const <a class="el" href="structrmw__service__t.html">rmw_service_t</a> *service, <a class="el" href="structrmw__request__id__t.html">rmw_request_id_t</a> *request_header, void *ros_response)</td></tr>
<tr class="separator:abb55ba2b2a957cefb0a77b77ddc5afda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6994bb0042f3a057aa2657149b9f79b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrmw__guard__condition__t.html">rmw_guard_condition_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a6994bb0042f3a057aa2657149b9f79b4">rmw_create_guard_condition</a> (<a class="el" href="structrmw__context__t.html">rmw_context_t</a> *context)</td></tr>
<tr class="memdesc:a6994bb0042f3a057aa2657149b9f79b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a guard condition and return a handle to that guard condition.  <a href="#a6994bb0042f3a057aa2657149b9f79b4">More...</a><br /></td></tr>
<tr class="separator:a6994bb0042f3a057aa2657149b9f79b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdbd5e36cc0c98e9ab4b018d3a13dfe2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#acdbd5e36cc0c98e9ab4b018d3a13dfe2">rmw_destroy_guard_condition</a> (<a class="el" href="structrmw__guard__condition__t.html">rmw_guard_condition_t</a> *guard_condition)</td></tr>
<tr class="memdesc:acdbd5e36cc0c98e9ab4b018d3a13dfe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a given guard condition handle, reclaim the resources, and deallocate the handle.  <a href="#acdbd5e36cc0c98e9ab4b018d3a13dfe2">More...</a><br /></td></tr>
<tr class="separator:acdbd5e36cc0c98e9ab4b018d3a13dfe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c06507746a703e9a053c87c4a711fdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a2c06507746a703e9a053c87c4a711fdc">rmw_trigger_guard_condition</a> (const <a class="el" href="structrmw__guard__condition__t.html">rmw_guard_condition_t</a> *guard_condition)</td></tr>
<tr class="separator:a2c06507746a703e9a053c87c4a711fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29d471adffff01c7738ec165f571aca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrmw__wait__set__t.html">rmw_wait_set_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#ac29d471adffff01c7738ec165f571aca">rmw_create_wait_set</a> (<a class="el" href="structrmw__context__t.html">rmw_context_t</a> *context, size_t max_conditions)</td></tr>
<tr class="memdesc:ac29d471adffff01c7738ec165f571aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a wait set to store conditions that the middleware will block on.  <a href="#ac29d471adffff01c7738ec165f571aca">More...</a><br /></td></tr>
<tr class="separator:ac29d471adffff01c7738ec165f571aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42465b1d9fddb3556a1a9f5d44d60b6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a42465b1d9fddb3556a1a9f5d44d60b6c">rmw_destroy_wait_set</a> (<a class="el" href="structrmw__wait__set__t.html">rmw_wait_set_t</a> *wait_set)</td></tr>
<tr class="separator:a42465b1d9fddb3556a1a9f5d44d60b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f480dd59075e80288fb596b2951be2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a5f480dd59075e80288fb596b2951be2b">rmw_wait</a> (<a class="el" href="structrmw__subscriptions__t.html">rmw_subscriptions_t</a> *subscriptions, <a class="el" href="structrmw__guard__conditions__t.html">rmw_guard_conditions_t</a> *guard_conditions, <a class="el" href="structrmw__services__t.html">rmw_services_t</a> *services, <a class="el" href="structrmw__clients__t.html">rmw_clients_t</a> *clients, <a class="el" href="structrmw__events__t.html">rmw_events_t</a> *events, <a class="el" href="structrmw__wait__set__t.html">rmw_wait_set_t</a> *wait_set, const <a class="el" href="structrmw__time__t.html">rmw_time_t</a> *wait_timeout)</td></tr>
<tr class="memdesc:a5f480dd59075e80288fb596b2951be2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits on sets of different waitable entities and returns when one is ready.  <a href="#a5f480dd59075e80288fb596b2951be2b">More...</a><br /></td></tr>
<tr class="separator:a5f480dd59075e80288fb596b2951be2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a897976680c178e0be5ef4d4a17f9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a64a897976680c178e0be5ef4d4a17f9f">rmw_get_node_names</a> (const <a class="el" href="structrmw__node__t.html">rmw_node_t</a> *node, <a class="elRef" doxygen="/home/jacob/ws/gendocs_ws/doxygen_tag_files/rcutils.tag:http://docs.ros2.org/dashing/api/rcutils/" href="http://docs.ros2.org/dashing/api/rcutils/structrcutils__string__array__t.html">rcutils_string_array_t</a> *node_names, <a class="elRef" doxygen="/home/jacob/ws/gendocs_ws/doxygen_tag_files/rcutils.tag:http://docs.ros2.org/dashing/api/rcutils/" href="http://docs.ros2.org/dashing/api/rcutils/structrcutils__string__array__t.html">rcutils_string_array_t</a> *node_namespaces)</td></tr>
<tr class="memdesc:a64a897976680c178e0be5ef4d4a17f9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of node name and namespaces discovered via a node.  <a href="#a64a897976680c178e0be5ef4d4a17f9f">More...</a><br /></td></tr>
<tr class="separator:a64a897976680c178e0be5ef4d4a17f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c761fb53a29f44b41fc299ffbb9cb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a83c761fb53a29f44b41fc299ffbb9cb4">rmw_count_publishers</a> (const <a class="el" href="structrmw__node__t.html">rmw_node_t</a> *node, const char *topic_name, size_t *count)</td></tr>
<tr class="separator:a83c761fb53a29f44b41fc299ffbb9cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d48df829636837092ef47f91514675e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a3d48df829636837092ef47f91514675e">rmw_count_subscribers</a> (const <a class="el" href="structrmw__node__t.html">rmw_node_t</a> *node, const char *topic_name, size_t *count)</td></tr>
<tr class="separator:a3d48df829636837092ef47f91514675e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a846898b23af992f7f3eaa17eaf741e9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a846898b23af992f7f3eaa17eaf741e9f">rmw_get_gid_for_publisher</a> (const <a class="el" href="structrmw__publisher__t.html">rmw_publisher_t</a> *publisher, <a class="el" href="structrmw__gid__t.html">rmw_gid_t</a> *gid)</td></tr>
<tr class="separator:a846898b23af992f7f3eaa17eaf741e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280fd9c0cf4fc49fbe6786b64b835194"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a280fd9c0cf4fc49fbe6786b64b835194">rmw_compare_gids_equal</a> (const <a class="el" href="structrmw__gid__t.html">rmw_gid_t</a> *gid1, const <a class="el" href="structrmw__gid__t.html">rmw_gid_t</a> *gid2, bool *result)</td></tr>
<tr class="separator:a280fd9c0cf4fc49fbe6786b64b835194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0cec9687e5e4738aba7e061014eb3d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#af0cec9687e5e4738aba7e061014eb3d5">rmw_service_server_is_available</a> (const <a class="el" href="structrmw__node__t.html">rmw_node_t</a> *node, const <a class="el" href="structrmw__client__t.html">rmw_client_t</a> *client, bool *is_available)</td></tr>
<tr class="memdesc:af0cec9687e5e4738aba7e061014eb3d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a service server is available for the given service client.  <a href="#af0cec9687e5e4738aba7e061014eb3d5">More...</a><br /></td></tr>
<tr class="separator:af0cec9687e5e4738aba7e061014eb3d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95cc3dd8de47abb8a105d0b8a30419c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rmw_8h.html#a95cc3dd8de47abb8a105d0b8a30419c9">rmw_set_log_severity</a> (<a class="el" href="types_8h.html#ae7d26f1a8dd291ab2209b7b0c9ca634c">rmw_log_severity_t</a> severity)</td></tr>
<tr class="separator:a95cc3dd8de47abb8a105d0b8a30419c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6dfb314c4e5edf3c28b1fb1ffe992b0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dfb314c4e5edf3c28b1fb1ffe992b0c">&#9670;&nbsp;</a></span>rmw_get_implementation_identifier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rmw_get_implementation_identifier </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a77d6ce17ee198857a68292a73016f6a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d6ce17ee198857a68292a73016f6a4">&#9670;&nbsp;</a></span>rmw_get_serialization_format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rmw_get_serialization_format </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the unique serialization format for this middleware. </p>
<p>Return the format in which binary data is serialized. One middleware can only have one encoding. In contrast to the implementation identifier, the serialization format can be equal between multiple RMW implementations. This means, that the same binary messages can be deserialized by RMW implementations with the same format. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="rmw_8h.html#a787c040bb59b0470ba51eee7e2bc04cd" title="Serialize a ROS message into a rmw_serialized_message_t. ">rmw_serialize</a> </dd>
<dd>
<a class="el" href="rmw_8h.html#a9dee9c2eed962055a68febe9622f807c" title="Deserialize a ROS message. ">rmw_deserialize</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>serialization format </dd></dl>

</div>
</div>
<a id="a48a535e951e3f996282be4044ac56cca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a535e951e3f996282be4044ac56cca">&#9670;&nbsp;</a></span>rmw_create_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrmw__node__t.html">rmw_node_t</a>* rmw_create_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrmw__context__t.html">rmw_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>namespace_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>domain_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrmw__node__security__options__t.html">rmw_node_security_options_t</a> *&#160;</td>
          <td class="paramname"><em>security_options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a node and return a handle to that node. </p>
<p>This function can fail, and therefore return <code>NULL</code>, if:</p><ul>
<li>context, name, namespace_, or security_options is <code>NULL</code></li>
<li>context, security_options is invalid</li>
<li>memory allocation fails during node creation</li>
<li>an unspecified error occurs</li>
</ul>
<p>The context must be non-null and valid, i.e. it has been initialized by <code><a class="el" href="init_8h.html#af74e9a1b897e41dc8f4c94a74bb9b1a5" title="Initialize the middleware with the given options, and yielding an context. ">rmw_init()</a></code> and has not been finalized by <code><a class="el" href="init_8h.html#a36ece6fcb6294f21a0b69cb091e3ee5a" title="Shutdown the middleware for a given context. ">rmw_shutdown()</a></code>.</p>
<p>The name and namespace_ should be valid node name and namespace, and this should be asserted by the caller (e.g. <code>rcl</code>).</p>
<p>The domain ID should be used to physically separate nodes at the communication graph level by the middleware. For RTPS/DDS this maps naturally to their concept of domain id.</p>
<p>The security options should always be non-null and encapsulate the essential security configurations for the node and its entities.</p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>Yes </td></tr>
<tr>
<td>Thread-Safe </td><td>No </td></tr>
<tr>
<td>Uses Atomics </td><td>No [1] </td></tr>
<tr>
<td>Lock-Free </td><td>No [1] </td></tr>
</table>
<p><em>[1] rmw implementation defined, check the implementation documentation</em></p>
<p>This should be defined by the rmw implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>init context that this node should be associated with </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>the node name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">namespace_</td><td>the node namespace </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">domain_id</td><td>the id of the domain that the node should join </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">security_options</td><td>the security configurations for the node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rmw node handle or <code>NULL</code> if there was an error </dd></dl>

</div>
</div>
<a id="a0a2c3d9d51ebf753d6c531ab3b42253b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a2c3d9d51ebf753d6c531ab3b42253b">&#9670;&nbsp;</a></span>rmw_destroy_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_destroy_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrmw__node__t.html">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a given node handle, reclaim the resources, and deallocate the node handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node handle to be destroyed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if node is null, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="ab43ddabd6febd7b1ba0ea60a1a61498f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab43ddabd6febd7b1ba0ea60a1a61498f">&#9670;&nbsp;</a></span>rmw_node_assert_liveliness()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_node_assert_liveliness </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__node__t.html">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Manually assert that this node is alive (for RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_NODE) </p>
<p>If the rmw Liveliness policy is set to RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_NODE, the creator of this node may manually call <code>assert_liveliness</code> at some point in time to signal to the rest of the system that this Node is still alive.</p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>No </td></tr>
<tr>
<td>Thread-Safe </td><td>Yes </td></tr>
<tr>
<td>Uses Atomics </td><td>No </td></tr>
<tr>
<td>Lock-Free </td><td>Yes </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>handle to the node that needs liveliness to be asserted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if the liveliness assertion was completed successfully, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unspecified error occurs, or </dd>
<dd>
<code>RMW_RET_UNSUPPORTED</code> if the rmw implementation does not support asserting liveliness. </dd></dl>

</div>
</div>
<a id="a52ca2bdd798c7b8f69da46d85e8d0fb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52ca2bdd798c7b8f69da46d85e8d0fb9">&#9670;&nbsp;</a></span>rmw_node_get_graph_guard_condition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structrmw__guard__condition__t.html">rmw_guard_condition_t</a>* rmw_node_get_graph_guard_condition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__node__t.html">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a guard condition which is triggered when the ROS graph changes. </p>
<p>The handle returned is a pointer to an internally held rmw guard condition. This function can fail, and therefore return <code>NULL</code>, if:</p><ul>
<li>node is <code>NULL</code></li>
<li>node is invalid</li>
</ul>
<p>The returned handle is made invalid if the node is destroyed or if <a class="el" href="init_8h.html#a36ece6fcb6294f21a0b69cb091e3ee5a" title="Shutdown the middleware for a given context. ">rmw_shutdown()</a> is called.</p>
<p>The guard condition will be triggered anytime a change to the ROS graph occurs. A ROS graph change includes things like (but not limited to) a new publisher advertises, a new subscription is created, a new service becomes available, a subscription is canceled, etc.</p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>No </td></tr>
<tr>
<td>Thread-Safe </td><td>Yes </td></tr>
<tr>
<td>Uses Atomics </td><td>No </td></tr>
<tr>
<td>Lock-Free </td><td>Yes </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>pointer to the rmw node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rmw guard condition handle if successful, otherwise <code>NULL</code> </dd></dl>

</div>
</div>
<a id="a2c375040f79eb4dfa4f49305a4df6d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c375040f79eb4dfa4f49305a4df6d19">&#9670;&nbsp;</a></span>rmw_init_publisher_allocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_init_publisher_allocation </td>
          <td>(</td>
          <td class="paramtype">const rosidl_message_type_support_t *&#160;</td>
          <td class="paramname"><em>type_support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rosidl_message_bounds_t *&#160;</td>
          <td class="paramname"><em>message_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__publisher__allocation__t.html">rmw_publisher_allocation_t</a> *&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a publisher allocation to be used with later publications. </p>
<p>This creates an allocation object that can be used in conjunction with the rmw_publish method to perform more carefully control memory allocations.</p>
<p>This will allow the middleware to preallocate the correct amount of memory for a given message type and message bounds. As allocation is performed in this method, it will not be necessary to allocate in the <code>rmw_publish</code> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_support</td><td>Type support of the message to be preallocated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message_bounds</td><td>Bounds structure of the message to be preallocated. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">allocation</td><td>Allocation structure to be passed to <code>rmw_publish</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if an argument is null, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a1a8ee7b6eef8d2b843484e77ead4992f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a8ee7b6eef8d2b843484e77ead4992f">&#9670;&nbsp;</a></span>rmw_fini_publisher_allocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_fini_publisher_allocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrmw__publisher__allocation__t.html">rmw_publisher_allocation_t</a> *&#160;</td>
          <td class="paramname"><em>allocation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a publisher allocation object. </p>
<p>This deallocates any memory allocated by <code>rmw_init_publisher_allocation</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allocation</td><td>Allocation object to be destroyed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if argument is null, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a1e9f09ef0de72f3f18b401b1253e688a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e9f09ef0de72f3f18b401b1253e688a">&#9670;&nbsp;</a></span>rmw_create_publisher()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrmw__publisher__t.html">rmw_publisher_t</a>* rmw_create_publisher </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__node__t.html">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rosidl_message_type_support_t *&#160;</td>
          <td class="paramname"><em>type_support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrmw__qos__profile__t.html">rmw_qos_profile_t</a> *&#160;</td>
          <td class="paramname"><em>qos_policies</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a297f8ae702c5f1eb51c40928e735de74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a297f8ae702c5f1eb51c40928e735de74">&#9670;&nbsp;</a></span>rmw_destroy_publisher()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_destroy_publisher </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrmw__node__t.html">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__publisher__t.html">rmw_publisher_t</a> *&#160;</td>
          <td class="paramname"><em>publisher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab625a62ba2f32e3d3a7c7ca1f6e0dbd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab625a62ba2f32e3d3a7c7ca1f6e0dbd6">&#9670;&nbsp;</a></span>rmw_publish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_publish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__publisher__t.html">rmw_publisher_t</a> *&#160;</td>
          <td class="paramname"><em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ros_message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__publisher__allocation__t.html">rmw_publisher_allocation_t</a> *&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Publish a given ros_message. </p>
<p>Publish a given ROS message via a publisher.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">publisher</td><td>Publisher to be used to send message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ros_message</td><td>Message to be sent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocation</td><td>Specify preallocated memory to use (may be NULL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if publisher or ros_message is null, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a046ba6f8ff184ebb01ab269b31a49f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a046ba6f8ff184ebb01ab269b31a49f33">&#9670;&nbsp;</a></span>rmw_publisher_count_matched_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_publisher_count_matched_subscriptions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__publisher__t.html">rmw_publisher_t</a> *&#160;</td>
          <td class="paramname"><em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>subscription_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the number of matched subscriptions to a publisher. </p>
<p>Query the underlying middleware to determine how many subscriptions are matched to a given publisher.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">publisher</td><td>the publisher object to inspect </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">subscription_count</td><td>the number of subscriptions matched </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if either argument is null, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a809010ecc3e404d8880382e2d4b35976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a809010ecc3e404d8880382e2d4b35976">&#9670;&nbsp;</a></span>rmw_publisher_get_actual_qos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_publisher_get_actual_qos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__publisher__t.html">rmw_publisher_t</a> *&#160;</td>
          <td class="paramname"><em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__qos__profile__t.html">rmw_qos_profile_t</a> *&#160;</td>
          <td class="paramname"><em>qos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the actual qos settings of the publisher. </p>
<p>Query the underlying middleware to determine the qos settings of the publisher. The actual configuration applied when using RMW_*_SYSTEM_DEFAULT can only be resolved after the creation of the publisher, and it depends on the underlying rmw implementation. If the underlying setting in use can't be represented in ROS terms, it will be set to RMW_*_UNKNOWN. The value of avoid_ros_namespace_conventions field is not resolved with this function. The rcl function rcl_publisher_get_actual_qos resolves it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">publisher</td><td>the publisher object to inspect </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">qos</td><td>the actual qos settings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if either argument is null, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="abca69c33387b6185146c3f115ec2a24a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abca69c33387b6185146c3f115ec2a24a">&#9670;&nbsp;</a></span>rmw_publish_serialized_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_publish_serialized_message </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__publisher__t.html">rmw_publisher_t</a> *&#160;</td>
          <td class="paramname"><em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="serialized__message_8h.html#ac1f977c2322bf36dc67f58235ee157ed">rmw_serialized_message_t</a> *&#160;</td>
          <td class="paramname"><em>serialized_message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__publisher__allocation__t.html">rmw_publisher_allocation_t</a> *&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Publish an already serialized message. </p>
<p>The publisher must already be registered with the correct message type support so that it can send serialized data corresponding to that type. This function sends the serialized byte stream directly over the wire without having to serialize the message first. A ROS message can be serialized manually using the <a class="el" href="rmw_8h.html#a787c040bb59b0470ba51eee7e2bc04cd" title="Serialize a ROS message into a rmw_serialized_message_t. ">rmw_serialize()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">publisher</td><td>The publisher object registered to send the message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">serialized_message</td><td>The serialized message holding the byte stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocation</td><td>Specify preallocated memory to use (may be NULL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="ad6344964f669c3d092606625bd9b9f5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6344964f669c3d092606625bd9b9f5e">&#9670;&nbsp;</a></span>rmw_get_serialized_message_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_get_serialized_message_size </td>
          <td>(</td>
          <td class="paramtype">const rosidl_message_type_support_t *&#160;</td>
          <td class="paramname"><em>type_support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rosidl_message_bounds_t *&#160;</td>
          <td class="paramname"><em>message_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the size of a serialized message. </p>
<p>Given a message definition and bounds, compute the serialized size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_support</td><td>The type support of the message to compute. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bounds</td><td>Artifical bounds to use on unbounded fields. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size</td><td>The computed size of the serialized message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if either argument is null, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a1e4025992c2194103d3fe417d2373e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4025992c2194103d3fe417d2373e95">&#9670;&nbsp;</a></span>rmw_publisher_assert_liveliness()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_publisher_assert_liveliness </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__publisher__t.html">rmw_publisher_t</a> *&#160;</td>
          <td class="paramname"><em>publisher</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Manually assert that this Publisher is alive (for RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC) </p>
<p>If the rmw Liveliness policy is set to RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC, the creator of this publisher may manually call <code>assert_liveliness</code> at some point in time to signal to the rest of the system that this Node is still alive.</p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>No </td></tr>
<tr>
<td>Thread-Safe </td><td>Yes </td></tr>
<tr>
<td>Uses Atomics </td><td>No </td></tr>
<tr>
<td>Lock-Free </td><td>Yes </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">publisher</td><td>handle to the publisher that needs liveliness to be asserted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if the liveliness assertion was completed successfully, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unspecified error occurs, or </dd>
<dd>
<code>RMW_RET_UNSUPPORTED</code> if the rmw implementation does not support asserting liveliness. </dd></dl>

</div>
</div>
<a id="a787c040bb59b0470ba51eee7e2bc04cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a787c040bb59b0470ba51eee7e2bc04cd">&#9670;&nbsp;</a></span>rmw_serialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_serialize </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ros_message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rosidl_message_type_support_t *&#160;</td>
          <td class="paramname"><em>type_support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="serialized__message_8h.html#ac1f977c2322bf36dc67f58235ee157ed">rmw_serialized_message_t</a> *&#160;</td>
          <td class="paramname"><em>serialized_message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize a ROS message into a rmw_serialized_message_t. </p>
<p>The ROS message is serialized into a byte stream contained within the rmw_serialized_message_t structure. The serialization format depends on the underlying middleware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ros_message</td><td>the typed ROS message </td></tr>
    <tr><td class="paramname">type_support</td><td>the typesupport for the ROS message </td></tr>
    <tr><td class="paramname">serialized_message</td><td>the destination for the serialize ROS message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_BAD_ALLOC</code> if memory allocation failed, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a9dee9c2eed962055a68febe9622f807c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dee9c2eed962055a68febe9622f807c">&#9670;&nbsp;</a></span>rmw_deserialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_deserialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="serialized__message_8h.html#ac1f977c2322bf36dc67f58235ee157ed">rmw_serialized_message_t</a> *&#160;</td>
          <td class="paramname"><em>serialized_message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rosidl_message_type_support_t *&#160;</td>
          <td class="paramname"><em>type_support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ros_message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserialize a ROS message. </p>
<p>The given rmw_serialized_message_t's internal byte stream buffer is deserialized into the given ROS message. The ROS message must already be allocated and initialized, and must match the given typesupport structure. The serialization format expected in the rmw_serialized_message_t depends on the underlying middleware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serialized_message</td><td>the serialized message holding the byte stream </td></tr>
    <tr><td class="paramname">type_support</td><td>the typesupport for the typed ros message </td></tr>
    <tr><td class="paramname">ros_message</td><td>destination for the deserialized ROS message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_BAD_ALLOC</code> if memory allocation failed, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="aef0cbb3c990ae56d2b442bd88ac782b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef0cbb3c990ae56d2b442bd88ac782b1">&#9670;&nbsp;</a></span>rmw_init_subscription_allocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_init_subscription_allocation </td>
          <td>(</td>
          <td class="paramtype">const rosidl_message_type_support_t *&#160;</td>
          <td class="paramname"><em>type_support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rosidl_message_bounds_t *&#160;</td>
          <td class="paramname"><em>message_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__subscription__allocation__t.html">rmw_subscription_allocation_t</a> *&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a subscription allocation to be used with later <code>take</code>s. </p>
<p>This creates an allocation object that can be used in conjunction with the rmw_take method to perform more carefully control memory allocations.</p>
<p>This will allow the middleware to preallocate the correct amount of memory for a given message type and message bounds. As allocation is performed in this method, it will not be necessary to allocate in the <code>rmw_take</code> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_support</td><td>Type support of the message to be preallocated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message_bounds</td><td>Bounds structure of the message to be preallocated. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">allocation</td><td>Allocation structure to be passed to <code>rmw_take</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if an argument is null, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a26e2408746a0e03bdaa290ef32780253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e2408746a0e03bdaa290ef32780253">&#9670;&nbsp;</a></span>rmw_fini_subscription_allocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_fini_subscription_allocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrmw__subscription__allocation__t.html">rmw_subscription_allocation_t</a> *&#160;</td>
          <td class="paramname"><em>allocation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a publisher allocation object. </p>
<p>This deallocates memory allocated by <code>rmw_init_subscription_allocation</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allocation</td><td>Allocation object to be destroyed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if argument is null, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a1fdd7d9de256254f4d020730baf40572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fdd7d9de256254f4d020730baf40572">&#9670;&nbsp;</a></span>rmw_create_subscription()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrmw__subscription__t.html">rmw_subscription_t</a>* rmw_create_subscription </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__node__t.html">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rosidl_message_type_support_t *&#160;</td>
          <td class="paramname"><em>type_support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrmw__qos__profile__t.html">rmw_qos_profile_t</a> *&#160;</td>
          <td class="paramname"><em>qos_policies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_local_publications</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a606270f7d253dba6eb9c279061bd2b6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a606270f7d253dba6eb9c279061bd2b6c">&#9670;&nbsp;</a></span>rmw_destroy_subscription()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_destroy_subscription </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrmw__node__t.html">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__subscription__t.html">rmw_subscription_t</a> *&#160;</td>
          <td class="paramname"><em>subscription</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f83284d1a1a2de0cbbc270fab7e2254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f83284d1a1a2de0cbbc270fab7e2254">&#9670;&nbsp;</a></span>rmw_subscription_count_matched_publishers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_subscription_count_matched_publishers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__subscription__t.html">rmw_subscription_t</a> *&#160;</td>
          <td class="paramname"><em>subscription</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>publisher_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the number of matched publishers to a subscription. </p>
<p>Query the underlying middleware to determine how many publishers are matched to a given subscription.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subscription</td><td>the subscription object to inspect </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">publisher_count</td><td>the number of publishers matched </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if either argument is null, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="af9bf29af7069593e2f8dfa2296710080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9bf29af7069593e2f8dfa2296710080">&#9670;&nbsp;</a></span>rmw_take()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_take </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__subscription__t.html">rmw_subscription_t</a> *&#160;</td>
          <td class="paramname"><em>subscription</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ros_message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>taken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__subscription__allocation__t.html">rmw_subscription_allocation_t</a> *&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take an incoming message from a subscription. </p>
<p>Take an incoming ROS message from a given subscription.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subscription</td><td>The subscription object to take from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ros_message</td><td>The ROS message data on success. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">taken</td><td>Boolean flag indicating if a message was taken or not. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocation</td><td>Preallocated buffer to use (may be NULL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a8498c763a02e0fe9203ab6c9dfba0408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8498c763a02e0fe9203ab6c9dfba0408">&#9670;&nbsp;</a></span>rmw_take_with_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_take_with_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__subscription__t.html">rmw_subscription_t</a> *&#160;</td>
          <td class="paramname"><em>subscription</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ros_message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>taken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__message__info__t.html">rmw_message_info_t</a> *&#160;</td>
          <td class="paramname"><em>message_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__subscription__allocation__t.html">rmw_subscription_allocation_t</a> *&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take an incoming message from a subscription with additional metadata. </p>
<p>Take an incoming ROS message from a given subscription.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subscription</td><td>The subscription object to take from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ros_message</td><td>The ROS message data on success. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">taken</td><td>Boolean flag indicating if a message was taken or not. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">message_info</td><td>Additional message metadata. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocation</td><td>Preallocated buffer to use (may be NULL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a8ef04c20dab1bc6cdb27343046ccab28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ef04c20dab1bc6cdb27343046ccab28">&#9670;&nbsp;</a></span>rmw_take_serialized_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_take_serialized_message </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__subscription__t.html">rmw_subscription_t</a> *&#160;</td>
          <td class="paramname"><em>subscription</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="serialized__message_8h.html#ac1f977c2322bf36dc67f58235ee157ed">rmw_serialized_message_t</a> *&#160;</td>
          <td class="paramname"><em>serialized_message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>taken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__subscription__allocation__t.html">rmw_subscription_allocation_t</a> *&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a message without deserializing it. </p>
<p>The message is taken in its serialized form. In contrast to rmw_take, the message is not deserialized in its ROS type but rather returned as a byte stream. The subscriber has to be registered for a specific type. But instead of receiving the message as its corresponding message type, it is taken as a byte stream. If needed, this byte stream can then be deserialized in a ROS message with a call to rmw_deserialize.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subscription</td><td>Subscription object to take from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">serialized_message</td><td>The destination in which to store the serialized message. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">taken</td><td>Boolean flag indicating if a message was taken or not. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocation</td><td>Preallocated buffer to use (may be NULL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_BAD_ALLOC</code> if memory allocation failed, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a16a8f380a5f4a5b37a48396a74a3238c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16a8f380a5f4a5b37a48396a74a3238c">&#9670;&nbsp;</a></span>rmw_take_serialized_message_with_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_take_serialized_message_with_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__subscription__t.html">rmw_subscription_t</a> *&#160;</td>
          <td class="paramname"><em>subscription</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="serialized__message_8h.html#ac1f977c2322bf36dc67f58235ee157ed">rmw_serialized_message_t</a> *&#160;</td>
          <td class="paramname"><em>serialized_message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>taken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__message__info__t.html">rmw_message_info_t</a> *&#160;</td>
          <td class="paramname"><em>message_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__subscription__allocation__t.html">rmw_subscription_allocation_t</a> *&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a message without deserializing it and with its additional message information. </p>
<p>The same as <a class="el" href="rmw_8h.html#a8ef04c20dab1bc6cdb27343046ccab28" title="Take a message without deserializing it. ">rmw_take_serialized_message()</a>, except it also includes the <a class="el" href="structrmw__message__info__t.html">rmw_message_info_t</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subscription</td><td>Subscription object to take from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">serialized_message</td><td>The destination in which to store the serialized message. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">taken</td><td>Boolean flag indicating if a message was taken or not. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">message_info</td><td>A structure containing meta information about the taken message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocation</td><td>Preallocated buffer to use (may be NULL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_BAD_ALLOC</code> if memory allocation failed, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a208bb1dd4d3c77cceee53ceba7abb8ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a208bb1dd4d3c77cceee53ceba7abb8ac">&#9670;&nbsp;</a></span>rmw_create_client()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrmw__client__t.html">rmw_client_t</a>* rmw_create_client </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__node__t.html">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rosidl_service_type_support_t *&#160;</td>
          <td class="paramname"><em>type_support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>service_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrmw__qos__profile__t.html">rmw_qos_profile_t</a> *&#160;</td>
          <td class="paramname"><em>qos_policies</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3da675215fe98e4bcb8cf202c3503c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3da675215fe98e4bcb8cf202c3503c5e">&#9670;&nbsp;</a></span>rmw_destroy_client()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_destroy_client </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrmw__node__t.html">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__client__t.html">rmw_client_t</a> *&#160;</td>
          <td class="paramname"><em>client</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9abc3e631cd2529f168d04be97f1db29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9abc3e631cd2529f168d04be97f1db29">&#9670;&nbsp;</a></span>rmw_send_request()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_send_request </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__client__t.html">rmw_client_t</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ros_request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>sequence_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f3ffcbe0c717050a4c6d0ae15ef2ece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f3ffcbe0c717050a4c6d0ae15ef2ece">&#9670;&nbsp;</a></span>rmw_take_response()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_take_response </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__client__t.html">rmw_client_t</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__request__id__t.html">rmw_request_id_t</a> *&#160;</td>
          <td class="paramname"><em>request_header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ros_response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>taken</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a41cac43fcb2ffd40268e472e94159ee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41cac43fcb2ffd40268e472e94159ee5">&#9670;&nbsp;</a></span>rmw_create_service()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrmw__service__t.html">rmw_service_t</a>* rmw_create_service </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__node__t.html">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rosidl_service_type_support_t *&#160;</td>
          <td class="paramname"><em>type_support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>service_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrmw__qos__profile__t.html">rmw_qos_profile_t</a> *&#160;</td>
          <td class="paramname"><em>qos_policies</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a39dc6f857dfa69a69bb198dc7fa96fed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39dc6f857dfa69a69bb198dc7fa96fed">&#9670;&nbsp;</a></span>rmw_destroy_service()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_destroy_service </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrmw__node__t.html">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__service__t.html">rmw_service_t</a> *&#160;</td>
          <td class="paramname"><em>service</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a04f11e3ac68ac7dda65a335e28bbad59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04f11e3ac68ac7dda65a335e28bbad59">&#9670;&nbsp;</a></span>rmw_take_request()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_take_request </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__service__t.html">rmw_service_t</a> *&#160;</td>
          <td class="paramname"><em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__request__id__t.html">rmw_request_id_t</a> *&#160;</td>
          <td class="paramname"><em>request_header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ros_request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>taken</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abb55ba2b2a957cefb0a77b77ddc5afda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb55ba2b2a957cefb0a77b77ddc5afda">&#9670;&nbsp;</a></span>rmw_send_response()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_send_response </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__service__t.html">rmw_service_t</a> *&#160;</td>
          <td class="paramname"><em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__request__id__t.html">rmw_request_id_t</a> *&#160;</td>
          <td class="paramname"><em>request_header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ros_response</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6994bb0042f3a057aa2657149b9f79b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6994bb0042f3a057aa2657149b9f79b4">&#9670;&nbsp;</a></span>rmw_create_guard_condition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrmw__guard__condition__t.html">rmw_guard_condition_t</a>* rmw_create_guard_condition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrmw__context__t.html">rmw_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a guard condition and return a handle to that guard condition. </p>
<p>This function can fail, and therefore return <code>NULL</code>, if:</p><ul>
<li>context is <code>NULL</code></li>
<li>context is invalid</li>
<li>memory allocation fails during guard condition creation</li>
<li>an unspecified error occurs</li>
</ul>
<p>The context must be non-null and valid, i.e. it has been initialized by <code><a class="el" href="init_8h.html#af74e9a1b897e41dc8f4c94a74bb9b1a5" title="Initialize the middleware with the given options, and yielding an context. ">rmw_init()</a></code> and has not been finalized by <code><a class="el" href="init_8h.html#a36ece6fcb6294f21a0b69cb091e3ee5a" title="Shutdown the middleware for a given context. ">rmw_shutdown()</a></code>.</p>
<hr/>
 <table class="doxtable">
<tr>
<th>Attribute </th><th>Adherence  </th></tr>
<tr>
<td>Allocates Memory </td><td>Yes </td></tr>
<tr>
<td>Thread-Safe </td><td>No </td></tr>
<tr>
<td>Uses Atomics </td><td>No [1] </td></tr>
<tr>
<td>Lock-Free </td><td>No [1] </td></tr>
</table>
<p><em>[1] rmw implementation defined, check the implementation documentation</em></p>
<p>This should be defined by the rmw implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>init context that this node should be associated with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rmw guard condition handle or <code>NULL</code> if there was an error </dd></dl>

</div>
</div>
<a id="acdbd5e36cc0c98e9ab4b018d3a13dfe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdbd5e36cc0c98e9ab4b018d3a13dfe2">&#9670;&nbsp;</a></span>rmw_destroy_guard_condition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_destroy_guard_condition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrmw__guard__condition__t.html">rmw_guard_condition_t</a> *&#160;</td>
          <td class="paramname"><em>guard_condition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a given guard condition handle, reclaim the resources, and deallocate the handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guard_condition</td><td>the guard condition handle to be destroyed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if successful, or </dd>
<dd>
<code>RMW_RET_INVALID_ARGUMENT</code> if guard_condition is null, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unexpected error occurs. </dd></dl>

</div>
</div>
<a id="a2c06507746a703e9a053c87c4a711fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c06507746a703e9a053c87c4a711fdc">&#9670;&nbsp;</a></span>rmw_trigger_guard_condition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_trigger_guard_condition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__guard__condition__t.html">rmw_guard_condition_t</a> *&#160;</td>
          <td class="paramname"><em>guard_condition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac29d471adffff01c7738ec165f571aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac29d471adffff01c7738ec165f571aca">&#9670;&nbsp;</a></span>rmw_create_wait_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrmw__wait__set__t.html">rmw_wait_set_t</a>* rmw_create_wait_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrmw__context__t.html">rmw_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_conditions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a wait set to store conditions that the middleware will block on. </p>
<p>This function can fail, and therefore return <code>NULL</code>, if:</p><ul>
<li>context is <code>NULL</code></li>
<li>context is invalid</li>
<li>memory allocation fails during wait set creation</li>
<li>an unspecified error occurs</li>
</ul>
<p>If <code>max_conditions</code> is <code>0</code>, the wait set can store an unbounded number of conditions to wait on. If <code>max_conditions</code> is greater than <code>0</code>, the number of conditions that can be attached to the wait set is bounded at <code>max_conditions</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>init context that this node should be associated with </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_conditions</td><td>The maximum number of conditions that can be attached to the wait set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the created wait set, <code>NULL</code> if an error occurred. </dd></dl>

</div>
</div>
<a id="a42465b1d9fddb3556a1a9f5d44d60b6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42465b1d9fddb3556a1a9f5d44d60b6c">&#9670;&nbsp;</a></span>rmw_destroy_wait_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_destroy_wait_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrmw__wait__set__t.html">rmw_wait_set_t</a> *&#160;</td>
          <td class="paramname"><em>wait_set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f480dd59075e80288fb596b2951be2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f480dd59075e80288fb596b2951be2b">&#9670;&nbsp;</a></span>rmw_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrmw__subscriptions__t.html">rmw_subscriptions_t</a> *&#160;</td>
          <td class="paramname"><em>subscriptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__guard__conditions__t.html">rmw_guard_conditions_t</a> *&#160;</td>
          <td class="paramname"><em>guard_conditions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__services__t.html">rmw_services_t</a> *&#160;</td>
          <td class="paramname"><em>services</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__clients__t.html">rmw_clients_t</a> *&#160;</td>
          <td class="paramname"><em>clients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__events__t.html">rmw_events_t</a> *&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__wait__set__t.html">rmw_wait_set_t</a> *&#160;</td>
          <td class="paramname"><em>wait_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrmw__time__t.html">rmw_time_t</a> *&#160;</td>
          <td class="paramname"><em>wait_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits on sets of different waitable entities and returns when one is ready. </p>
<p>Add conditions to the wait set and wait until a response comes in, or until the timeout is reached. The arrays contain type-erased representations of waitable entities. This function casts the pointers to middleware-specific conditions and adds them to the wait set.</p>
<p>The count variables in the arrays represents the number of valid pointers in the array. <code>NULL</code> pointers are in the array considered invalid. If they are encountered, an error is returned.</p>
<p>The array structs are allocated and deallocated outside of this function. They do not have any information about how much memory is allocated for the arrays.</p>
<p>After the wait wakes up, the entries in each array that correspond to conditions that were not triggered are set to <code>NULL</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subscriptions</td><td>Array of subscriptions to wait on </td></tr>
    <tr><td class="paramname">guard_conditions</td><td>Array of guard conditions to wait on </td></tr>
    <tr><td class="paramname">services</td><td>Array of services to wait on </td></tr>
    <tr><td class="paramname">clients</td><td>Array of clients to wait on </td></tr>
    <tr><td class="paramname">wait_set</td><td>Storage for the wait set </td></tr>
    <tr><td class="paramname">wait_timeout</td><td>If NULL, block until a condition is ready. If zero, check only for immediately available conditions and don't block. Else, this represents the maximum time to wait for a response from the wait set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if success, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if error, or </dd>
<dd>
<code>RMW_RET_TIMEOUT</code> if wait timed out. </dd></dl>

</div>
</div>
<a id="a64a897976680c178e0be5ef4d4a17f9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64a897976680c178e0be5ef4d4a17f9f">&#9670;&nbsp;</a></span>rmw_get_node_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_get_node_names </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__node__t.html">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="/home/jacob/ws/gendocs_ws/doxygen_tag_files/rcutils.tag:http://docs.ros2.org/dashing/api/rcutils/" href="http://docs.ros2.org/dashing/api/rcutils/structrcutils__string__array__t.html">rcutils_string_array_t</a> *&#160;</td>
          <td class="paramname"><em>node_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="/home/jacob/ws/gendocs_ws/doxygen_tag_files/rcutils.tag:http://docs.ros2.org/dashing/api/rcutils/" href="http://docs.ros2.org/dashing/api/rcutils/structrcutils__string__array__t.html">rcutils_string_array_t</a> *&#160;</td>
          <td class="paramname"><em>node_namespaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a list of node name and namespaces discovered via a node. </p>
<p>This function will return a list of node names and a list of node namespaces that are discovered via the middleware. The two lists represent pairs of namespace and name for each discovered node. The lists will be the same length and the same position will refer to the same node across lists.</p>
<p>The node parameter must not be <code>NULL</code>, and must point to a valid node.</p>
<p>The node_names parameter must not be <code>NULL</code>, and must point to a valid string array.</p>
<p>The node_namespaces parameter must not be <code>NULL</code>, and must point to a valid string array.</p>
<p>This function does manipulate heap memory. This function is not thread-safe. This function is lock-free.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>the handle to the node being used to query the ROS graph </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">node_names</td><td>a list of discovered node names </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">node_namespaces</td><td>a list of discovered node namespaces </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if node the query was made successfully, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a id="a83c761fb53a29f44b41fc299ffbb9cb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83c761fb53a29f44b41fc299ffbb9cb4">&#9670;&nbsp;</a></span>rmw_count_publishers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_count_publishers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__node__t.html">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d48df829636837092ef47f91514675e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d48df829636837092ef47f91514675e">&#9670;&nbsp;</a></span>rmw_count_subscribers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_count_subscribers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__node__t.html">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a846898b23af992f7f3eaa17eaf741e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a846898b23af992f7f3eaa17eaf741e9f">&#9670;&nbsp;</a></span>rmw_get_gid_for_publisher()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_get_gid_for_publisher </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__publisher__t.html">rmw_publisher_t</a> *&#160;</td>
          <td class="paramname"><em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmw__gid__t.html">rmw_gid_t</a> *&#160;</td>
          <td class="paramname"><em>gid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a280fd9c0cf4fc49fbe6786b64b835194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a280fd9c0cf4fc49fbe6786b64b835194">&#9670;&nbsp;</a></span>rmw_compare_gids_equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_compare_gids_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__gid__t.html">rmw_gid_t</a> *&#160;</td>
          <td class="paramname"><em>gid1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrmw__gid__t.html">rmw_gid_t</a> *&#160;</td>
          <td class="paramname"><em>gid2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af0cec9687e5e4738aba7e061014eb3d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0cec9687e5e4738aba7e061014eb3d5">&#9670;&nbsp;</a></span>rmw_service_server_is_available()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_service_server_is_available </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrmw__node__t.html">rmw_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrmw__client__t.html">rmw_client_t</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_available</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a service server is available for the given service client. </p>
<p>This function will return true for <code>is_available</code> if there is a service server available for the given client.</p>
<p>The node parameter must not be <code>NULL</code>, and must point to a valid node.</p>
<p>The client parameter must not be <code>NULL</code>, and must point to a valid client.</p>
<p>The given client and node must match, i.e. the client must have been created using the given node.</p>
<p>The is_available parameter must not be <code>NULL</code>, and must point to a bool variable. The result of the check will be stored in the is_available parameter.</p>
<p>This function does manipulate heap memory. This function is not thread-safe. This function is lock-free.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>the handle to the node being used to query the ROS graph </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">client</td><td>the handle to the service client being queried </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_available</td><td>set to true if there is a service server available, else false </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>RMW_RET_OK</code> if node the check was made successfully, or </dd>
<dd>
<code>RMW_RET_ERROR</code> if an unspecified error occurs. </dd></dl>

</div>
</div>
<a id="a95cc3dd8de47abb8a105d0b8a30419c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95cc3dd8de47abb8a105d0b8a30419c9">&#9670;&nbsp;</a></span>rmw_set_log_severity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ret__types_8h.html#a58f6b3792cb4f09b26362e504f4c7caa">rmw_ret_t</a> rmw_set_log_severity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#ae7d26f1a8dd291ab2209b7b0c9ca634c">rmw_log_severity_t</a>&#160;</td>
          <td class="paramname"><em>severity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
