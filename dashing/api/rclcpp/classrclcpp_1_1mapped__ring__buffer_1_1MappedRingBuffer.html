<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rclcpp: rclcpp::mapped_ring_buffer::MappedRingBuffer&lt; T, Alloc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rclcpp
   &#160;<span id="projectnumber">master</span>
   </div>
   <div id="projectbrief">C++ ROS Client Library API</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacerclcpp.html">rclcpp</a></li><li class="navelem"><a class="el" href="namespacerclcpp_1_1mapped__ring__buffer.html">mapped_ring_buffer</a></li><li class="navelem"><a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html">MappedRingBuffer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rclcpp::mapped_ring_buffer::MappedRingBuffer&lt; T, Alloc &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Ring buffer container of shared_ptr's or unique_ptr's of T, which can be accessed by a key.  
 <a href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mapped__ring__buffer_8hpp_source.html">mapped_ring_buffer.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for rclcpp::mapped_ring_buffer::MappedRingBuffer&lt; T, Alloc &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer__inherit__graph.png" border="0" usemap="#rclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer_3_01T_00_01Alloc_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="rclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer_3_01T_00_01Alloc_01_4_inherit__map" id="rclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer_3_01T_00_01Alloc_01_4_inherit__map">
<area shape="rect" id="node2" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBufferBase.html" title="rclcpp::mapped_ring\l_buffer::MappedRingBufferBase" alt="" coords="5,5,213,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for rclcpp::mapped_ring_buffer::MappedRingBuffer&lt; T, Alloc &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer__coll__graph.png" border="0" usemap="#rclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer_3_01T_00_01Alloc_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="rclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer_3_01T_00_01Alloc_01_4_coll__map" id="rclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer_3_01T_00_01Alloc_01_4_coll__map">
<area shape="rect" id="node2" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBufferBase.html" title="rclcpp::mapped_ring\l_buffer::MappedRingBufferBase" alt="" coords="5,5,213,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8025658f213836eb8980e8cfc5279c36"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#a8025658f213836eb8980e8cfc5279c36">ElemAllocTraits</a> = <a class="el" href="namespacerclcpp_1_1allocator.html#a89c84a2945dc1cea1d6dfd4fa72a9dcd">allocator::AllocRebind</a>&lt; T, Alloc &gt;</td></tr>
<tr class="separator:a8025658f213836eb8980e8cfc5279c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10db6b24f0fe51e5cf28d739b49097c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#ae10db6b24f0fe51e5cf28d739b49097c">ElemAlloc</a> = typename ElemAllocTraits::allocator_type</td></tr>
<tr class="separator:ae10db6b24f0fe51e5cf28d739b49097c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b6b98ba3a3046b3a39dff98bab7d97"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#a21b6b98ba3a3046b3a39dff98bab7d97">ElemDeleter</a> = <a class="el" href="namespacerclcpp_1_1allocator.html#a885f50f2cbbab914f65ef687a0edd61b">allocator::Deleter</a>&lt; <a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#ae10db6b24f0fe51e5cf28d739b49097c">ElemAlloc</a>, T &gt;</td></tr>
<tr class="separator:a21b6b98ba3a3046b3a39dff98bab7d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc5a89cbe9db8e7012cd96d2e78746e8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#abc5a89cbe9db8e7012cd96d2e78746e8">ConstElemSharedPtr</a> = <a class="elRef" doxygen="/home/jacob/ws/gendocs_ws/doxygen_tag_files/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; const T &gt;</td></tr>
<tr class="separator:abc5a89cbe9db8e7012cd96d2e78746e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada14be27bb3a40e30bdeb12a01c6abdb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#ada14be27bb3a40e30bdeb12a01c6abdb">ElemUniquePtr</a> = <a class="elRef" doxygen="/home/jacob/ws/gendocs_ws/doxygen_tag_files/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; T, <a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#a21b6b98ba3a3046b3a39dff98bab7d97">ElemDeleter</a> &gt;</td></tr>
<tr class="separator:ada14be27bb3a40e30bdeb12a01c6abdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2736f1b2c51b6f0acbd8d2b9e39e9037"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#a2736f1b2c51b6f0acbd8d2b9e39e9037">MappedRingBuffer</a> (size_t size, <a class="elRef" doxygen="/home/jacob/ws/gendocs_ws/doxygen_tag_files/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; Alloc &gt; allocator=nullptr)</td></tr>
<tr class="memdesc:a2736f1b2c51b6f0acbd8d2b9e39e9037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a2736f1b2c51b6f0acbd8d2b9e39e9037">More...</a><br /></td></tr>
<tr class="separator:a2736f1b2c51b6f0acbd8d2b9e39e9037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d85597642e946e8aa8d339eac6089c"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#a49d85597642e946e8aa8d339eac6089c">~MappedRingBuffer</a> ()</td></tr>
<tr class="separator:a49d85597642e946e8aa8d339eac6089c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7028ce18f290655ae7fe307536b4e2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#ac7028ce18f290655ae7fe307536b4e2a">get</a> (uint64_t key, <a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#ada14be27bb3a40e30bdeb12a01c6abdb">ElemUniquePtr</a> &amp;value)</td></tr>
<tr class="memdesc:ac7028ce18f290655ae7fe307536b4e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the value stored in the ring buffer at the given key.  <a href="#ac7028ce18f290655ae7fe307536b4e2a">More...</a><br /></td></tr>
<tr class="separator:ac7028ce18f290655ae7fe307536b4e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db07e99928ca2d71a58699614f00d25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#a1db07e99928ca2d71a58699614f00d25">get</a> (uint64_t key, <a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#abc5a89cbe9db8e7012cd96d2e78746e8">ConstElemSharedPtr</a> &amp;value)</td></tr>
<tr class="memdesc:a1db07e99928ca2d71a58699614f00d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Share ownership of the value stored in the ring buffer at the given key.  <a href="#a1db07e99928ca2d71a58699614f00d25">More...</a><br /></td></tr>
<tr class="separator:a1db07e99928ca2d71a58699614f00d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598864aa23a66ff3b5082ae095b2d362"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#a598864aa23a66ff3b5082ae095b2d362">pop</a> (uint64_t key, <a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#ada14be27bb3a40e30bdeb12a01c6abdb">ElemUniquePtr</a> &amp;value)</td></tr>
<tr class="memdesc:a598864aa23a66ff3b5082ae095b2d362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give the ownership of the stored value to the caller if possible, or copy and release.  <a href="#a598864aa23a66ff3b5082ae095b2d362">More...</a><br /></td></tr>
<tr class="separator:a598864aa23a66ff3b5082ae095b2d362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24074126d17a9065bcba4ea84be62e16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#a24074126d17a9065bcba4ea84be62e16">pop</a> (uint64_t key, <a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#abc5a89cbe9db8e7012cd96d2e78746e8">ConstElemSharedPtr</a> &amp;value)</td></tr>
<tr class="memdesc:a24074126d17a9065bcba4ea84be62e16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give the ownership of the stored value to the caller, at the given key.  <a href="#a24074126d17a9065bcba4ea84be62e16">More...</a><br /></td></tr>
<tr class="separator:a24074126d17a9065bcba4ea84be62e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678f45ae68a32a3e149934fe910179b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#a678f45ae68a32a3e149934fe910179b4">push_and_replace</a> (uint64_t key, <a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#abc5a89cbe9db8e7012cd96d2e78746e8">ConstElemSharedPtr</a> value)</td></tr>
<tr class="memdesc:a678f45ae68a32a3e149934fe910179b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a key-value pair, displacing an existing pair if necessary.  <a href="#a678f45ae68a32a3e149934fe910179b4">More...</a><br /></td></tr>
<tr class="separator:a678f45ae68a32a3e149934fe910179b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af66afdee799cbc65f46e9e827c049959"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#af66afdee799cbc65f46e9e827c049959">push_and_replace</a> (uint64_t key, <a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#ada14be27bb3a40e30bdeb12a01c6abdb">ElemUniquePtr</a> value)</td></tr>
<tr class="memdesc:af66afdee799cbc65f46e9e827c049959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a key-value pair, displacing an existing pair if necessary.  <a href="#af66afdee799cbc65f46e9e827c049959">More...</a><br /></td></tr>
<tr class="separator:af66afdee799cbc65f46e9e827c049959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b417e8bfaa257f9d357d0a7a854f58"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#a10b417e8bfaa257f9d357d0a7a854f58">has_key</a> (uint64_t key)</td></tr>
<tr class="memdesc:a10b417e8bfaa257f9d357d0a7a854f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the key is found in the ring buffer, otherwise false.  <a href="#a10b417e8bfaa257f9d357d0a7a854f58">More...</a><br /></td></tr>
<tr class="separator:a10b417e8bfaa257f9d357d0a7a854f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename Alloc = std::allocator&lt;void&gt;&gt;<br />
class rclcpp::mapped_ring_buffer::MappedRingBuffer&lt; T, Alloc &gt;</h3>

<p>Ring buffer container of shared_ptr's or unique_ptr's of T, which can be accessed by a key. </p>
<p>T must be a CopyConstructable and CopyAssignable. This class can be used in a container by using the base class <a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBufferBase.html">MappedRingBufferBase</a>. This class must have a positive, non-zero size. This class cannot be resized nor can it reserve additional space after construction. This class is not CopyConstructable nor CopyAssignable.</p>
<p>The key's are not guaranteed to be unique because push_and_replace does not check for colliding keys. It is up to the user to only use unique keys. A side effect of this is that when get_copy_at_key or pop_at_key are called, they return the first encountered instance of the key. But iteration does not begin with the ring buffer's head, and therefore there is no guarantee on which value is returned if a key is used multiple times. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a8025658f213836eb8980e8cfc5279c36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8025658f213836eb8980e8cfc5279c36">&#9670;&nbsp;</a></span>ElemAllocTraits</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html">rclcpp::mapped_ring_buffer::MappedRingBuffer</a>&lt; T, Alloc &gt;::<a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#a8025658f213836eb8980e8cfc5279c36">ElemAllocTraits</a> =  <a class="el" href="namespacerclcpp_1_1allocator.html#a89c84a2945dc1cea1d6dfd4fa72a9dcd">allocator::AllocRebind</a>&lt;T, Alloc&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae10db6b24f0fe51e5cf28d739b49097c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae10db6b24f0fe51e5cf28d739b49097c">&#9670;&nbsp;</a></span>ElemAlloc</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html">rclcpp::mapped_ring_buffer::MappedRingBuffer</a>&lt; T, Alloc &gt;::<a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#ae10db6b24f0fe51e5cf28d739b49097c">ElemAlloc</a> =  typename ElemAllocTraits::allocator_type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a21b6b98ba3a3046b3a39dff98bab7d97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21b6b98ba3a3046b3a39dff98bab7d97">&#9670;&nbsp;</a></span>ElemDeleter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html">rclcpp::mapped_ring_buffer::MappedRingBuffer</a>&lt; T, Alloc &gt;::<a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#a21b6b98ba3a3046b3a39dff98bab7d97">ElemDeleter</a> =  <a class="el" href="namespacerclcpp_1_1allocator.html#a885f50f2cbbab914f65ef687a0edd61b">allocator::Deleter</a>&lt;<a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#ae10db6b24f0fe51e5cf28d739b49097c">ElemAlloc</a>, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abc5a89cbe9db8e7012cd96d2e78746e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc5a89cbe9db8e7012cd96d2e78746e8">&#9670;&nbsp;</a></span>ConstElemSharedPtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html">rclcpp::mapped_ring_buffer::MappedRingBuffer</a>&lt; T, Alloc &gt;::<a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#abc5a89cbe9db8e7012cd96d2e78746e8">ConstElemSharedPtr</a> =  <a class="elRef" doxygen="/home/jacob/ws/gendocs_ws/doxygen_tag_files/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt;const T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ada14be27bb3a40e30bdeb12a01c6abdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada14be27bb3a40e30bdeb12a01c6abdb">&#9670;&nbsp;</a></span>ElemUniquePtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html">rclcpp::mapped_ring_buffer::MappedRingBuffer</a>&lt; T, Alloc &gt;::<a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#ada14be27bb3a40e30bdeb12a01c6abdb">ElemUniquePtr</a> =  <a class="elRef" doxygen="/home/jacob/ws/gendocs_ws/doxygen_tag_files/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt;T, <a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#a21b6b98ba3a3046b3a39dff98bab7d97">ElemDeleter</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2736f1b2c51b6f0acbd8d2b9e39e9037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2736f1b2c51b6f0acbd8d2b9e39e9037">&#9670;&nbsp;</a></span>MappedRingBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html">rclcpp::mapped_ring_buffer::MappedRingBuffer</a>&lt; T, Alloc &gt;::<a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html">MappedRingBuffer</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="/home/jacob/ws/gendocs_ws/doxygen_tag_files/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; Alloc &gt;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>The constructor will allocate memory while reserving space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>size of the ring buffer; must be positive and non-zero. </td></tr>
    <tr><td class="paramname">allocator</td><td>optional custom allocator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49d85597642e946e8aa8d339eac6089c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49d85597642e946e8aa8d339eac6089c">&#9670;&nbsp;</a></span>~MappedRingBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html">rclcpp::mapped_ring_buffer::MappedRingBuffer</a>&lt; T, Alloc &gt;::~<a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html">MappedRingBuffer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac7028ce18f290655ae7fe307536b4e2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7028ce18f290655ae7fe307536b4e2a">&#9670;&nbsp;</a></span>get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html">rclcpp::mapped_ring_buffer::MappedRingBuffer</a>&lt; T, Alloc &gt;::get </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#ada14be27bb3a40e30bdeb12a01c6abdb">ElemUniquePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a copy of the value stored in the ring buffer at the given key. </p>
<p>The key is matched if an element in the ring buffer has a matching key. This method will allocate in order to return a copy.</p>
<p>The key is not guaranteed to be unique, see the class docs for more.</p>
<p>The contents of value before the method is called are discarded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key associated with the stored value </td></tr>
    <tr><td class="paramname">value</td><td>if the key is found, the value is stored in this parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1db07e99928ca2d71a58699614f00d25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db07e99928ca2d71a58699614f00d25">&#9670;&nbsp;</a></span>get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html">rclcpp::mapped_ring_buffer::MappedRingBuffer</a>&lt; T, Alloc &gt;::get </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#abc5a89cbe9db8e7012cd96d2e78746e8">ConstElemSharedPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Share ownership of the value stored in the ring buffer at the given key. </p>
<p>The key is matched if an element in the ring buffer has a matching key.</p>
<p>The key is not guaranteed to be unique, see the class docs for more.</p>
<p>The contents of value before the method is called are discarded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key associated with the stored value </td></tr>
    <tr><td class="paramname">value</td><td>if the key is found, the value is stored in this parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a598864aa23a66ff3b5082ae095b2d362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a598864aa23a66ff3b5082ae095b2d362">&#9670;&nbsp;</a></span>pop() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html">rclcpp::mapped_ring_buffer::MappedRingBuffer</a>&lt; T, Alloc &gt;::pop </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#ada14be27bb3a40e30bdeb12a01c6abdb">ElemUniquePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Give the ownership of the stored value to the caller if possible, or copy and release. </p>
<p>The key is matched if an element in the ring buffer has a matching key. This method may allocate in order to return a copy.</p>
<p>If the stored value is a shared_ptr, it is not possible to downgrade it to a unique_ptr. In that case, a copy is returned and the stored value is released.</p>
<p>The key is not guaranteed to be unique, see the class docs for more.</p>
<p>The contents of value before the method is called are discarded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key associated with the stored value </td></tr>
    <tr><td class="paramname">value</td><td>if the key is found, the value is stored in this parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24074126d17a9065bcba4ea84be62e16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24074126d17a9065bcba4ea84be62e16">&#9670;&nbsp;</a></span>pop() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html">rclcpp::mapped_ring_buffer::MappedRingBuffer</a>&lt; T, Alloc &gt;::pop </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#abc5a89cbe9db8e7012cd96d2e78746e8">ConstElemSharedPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Give the ownership of the stored value to the caller, at the given key. </p>
<p>The key is matched if an element in the ring buffer has a matching key.</p>
<p>The key is not guaranteed to be unique, see the class docs for more.</p>
<p>The contents of value before the method is called are discarded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key associated with the stored value </td></tr>
    <tr><td class="paramname">value</td><td>if the key is found, the value is stored in this parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a678f45ae68a32a3e149934fe910179b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a678f45ae68a32a3e149934fe910179b4">&#9670;&nbsp;</a></span>push_and_replace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html">rclcpp::mapped_ring_buffer::MappedRingBuffer</a>&lt; T, Alloc &gt;::push_and_replace </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#abc5a89cbe9db8e7012cd96d2e78746e8">ConstElemSharedPtr</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a key-value pair, displacing an existing pair if necessary. </p>
<p>The key's uniqueness is not checked on insertion. It is up to the user to ensure the key is unique. This method should not allocate memory.</p>
<p>After insertion the value will be a nullptr. If a pair were replaced, its smart pointer is reset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key associated with the value to be stored </td></tr>
    <tr><td class="paramname">value</td><td>the value to store, and optionally the value displaced </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af66afdee799cbc65f46e9e827c049959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af66afdee799cbc65f46e9e827c049959">&#9670;&nbsp;</a></span>push_and_replace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html">rclcpp::mapped_ring_buffer::MappedRingBuffer</a>&lt; T, Alloc &gt;::push_and_replace </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html#ada14be27bb3a40e30bdeb12a01c6abdb">ElemUniquePtr</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a key-value pair, displacing an existing pair if necessary. </p>
<p>See <code>bool push_and_replace(uint64_t key, const ConstElemSharedPtr &amp; value)</code>. </p>

</div>
</div>
<a id="a10b417e8bfaa257f9d357d0a7a854f58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b417e8bfaa257f9d357d0a7a854f58">&#9670;&nbsp;</a></span>has_key()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc  = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classrclcpp_1_1mapped__ring__buffer_1_1MappedRingBuffer.html">rclcpp::mapped_ring_buffer::MappedRingBuffer</a>&lt; T, Alloc &gt;::has_key </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the key is found in the ring buffer, otherwise false. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/rclcpp/<a class="el" href="mapped__ring__buffer_8hpp_source.html">mapped_ring_buffer.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
